#!/bin/bash

#==============================================================================
# MoonFRP - Advanced FRP Management Script (Refactored)
# Version: 1.1.0
# Author: MoonFRP Team
# Description: Modular FRP configuration and service management tool
# Refactored: 2025-01-26 - Eliminated redundancy, improved structure
#==============================================================================
#
# Performance Notes:
# - Server settings in frps.toml:
#   * maxPortsPerClient: Limit ports per client (default: 10)
#   * userConnTimeout: Maximum wait time for connections (default: 10s)
#   * transport.maxPoolCount: Limit connection pool size (default: 5)
#   * transport.quic.maxIncomingStreams: Limit QUIC streams (default: 100)
#
# - Client settings in frpc.toml:
#   * loginFailExit: Exit on login failure (default: true)
#   * transport.poolCount: Connection pool size (default: 5)
#   * transport.dialServerKeepalive: Keep-alive interval (default: 300s)
#   * transport.bandwidthLimit: Bandwidth limit (default: "10MB")
#
#==============================================================================
# FUNCTION INDEX
#==============================================================================
# SECTION 1: INITIALIZATION & CONFIGURATION
#   - create_directories()           - Setup required directories
#   - setup_signal_handlers()        - Configure signal handling
#   - init()                         - Initialize script environment
#   - cleanup_and_exit()             - Cleanup and exit gracefully
#
# SECTION 2: UTILITY & HELPER FUNCTIONS  
#   - log()                          - Centralized logging function
#   - safe_read()                    - Safe input reading with Ctrl+C handling
#   - safe_read_menu()               - Menu-specific input reading
#   - show_spinner()                 - Display loading spinner
#   - format_bytes()                 - Format byte values for display
#   - generate_token()               - Generate secure authentication tokens
#
# SECTION 3: VALIDATION & ERROR HANDLING
#   - validate()                     - Unified validation function
#   - safe_execute()                 - Safe command execution wrapper
#   - handle_error()                 - Centralized error handling
#   - check_root()                   - Verify root privileges
#   - check_dependencies()           - Verify system dependencies
#   - validate_command()             - Validate command dependencies
#   - validate_permissions()         - Validate file/directory permissions
#   - sanitize_input()               - Sanitize input to prevent injection attacks
#
# SECTION 4: FRP CONFIGURATION GENERATORS
#   - generate_proxy_config()        - Unified proxy configuration generator
#   - generate_frps_config()         - Server configuration generator
#   - generate_frpc_config()         - Client configuration generator
#   - generate_visitor_config()      - Visitor configuration generator
#   - apply_config_template()        - Apply configuration templates
#   - backup_config()                - Backup configuration files
#   - validate_config_syntax()      - Validate TOML/JSON/YAML syntax
#   - create_config_template()      - Create configuration templates
#
# SECTION 5: SERVICE MANAGEMENT
#   - manage_service()               - Unified service management
#   - create_systemd_service()       - Create systemd service files
#   - list_frp_services()            - List all FRP services
#   - get_service_status()           - Get detailed service status
#   - setup_cron_job()               - Setup automatic restart cron job
#   - batch_systemctl_operation()     - Batch systemctl operations for performance
#
# SECTION 6: MENU SYSTEM
#   - render_menu()                  - Unified menu rendering
#   - handle_menu_choice()          - Unified menu input handling
#   - run_menu()                     - Unified menu loop function
#   - main_menu()                    - Main application menu
#   - service_management_menu()      - Service management submenu
#   - config_creation_menu()         - Configuration creation submenu
#   - troubleshooting_menu()         - Troubleshooting submenu
#
# SECTION 7: DIAGNOSTICS & TROUBLESHOOTING
#   - view_logs()                    - Unified log viewing system
#   - check_all_proxy_conflicts()    - Check for proxy name conflicts
#   - check_all_port_conflicts()     - Check for port conflicts
#   - validate_all_connections()    - Validate server connections
#   - fix_common_issues()            - Fix common configuration issues
#   - generate_diagnostic_report()   - Generate system diagnostic report
#   - monitor_all_proxies()          - Monitor proxy performance
#
# SECTION 8: CONFIG TEMPLATE SYSTEM
#   - apply_config_template()        - Apply configuration template with variables
#   - backup_config()                - Backup configuration file with timestamp
#   - cleanup_old_backups()          - Clean up old backup files
#   - validate_config_syntax()      - Validate configuration file syntax
#   - validate_toml_syntax()         - Validate TOML syntax
#   - validate_json_syntax()         - Validate JSON syntax
#   - validate_yaml_syntax()         - Validate YAML syntax
#   - create_config_template()      - Create configuration template
#   - create_frpc_template()         - Create FRP client template
#   - create_frps_template()         - Create FRP server template
#   - create_custom_template()       - Create custom template
#
# SECTION 9: CLEANUP SYSTEM
#   - cleanup()                      - Unified cleanup function
#   - cleanup_services()             - Cleanup services (stop, disable, remove)
#   - cleanup_configs()              - Cleanup configuration files
#   - cleanup_logs()                 - Cleanup log files
#   - cleanup_temp_files()           - Cleanup temporary files
#   - cleanup_backups()              - Cleanup backup files
#   - cleanup_all()                  - Cleanup everything
#   - cleanup_selective()            - Selective cleanup based on criteria
#   - cleanup_inactive_services()   - Cleanup inactive services
#   - cleanup_old_logs()             - Cleanup old log files
#   - cleanup_unused_configs()       - Cleanup unused config files
#
# SECTION 10: PERFORMANCE OPTIMIZATION
#   - manage_cache()                 - Enhanced cache management with TTL
#   - get_cached_value()             - Get cached value with TTL check
#   - set_cached_value()             - Set cached value with timestamp
#   - clear_cache_entry()            - Clear specific cache entry
#   - invalidate_cache_entry()       - Invalidate cache entry
#   - show_cache_stats()             - Show cache statistics
#   - calculate_cache_hit_ratio()    - Calculate cache hit ratio
#   - batch_systemctl_operation()   - Batch systemctl operations
#   - get_services_optimized()       - Optimized service listing with caching
#   - get_service_status_optimized() - Optimized service status checking
#   - monitor_performance()          - Performance monitoring and optimization
#   - clear_performance_caches()     - Clear all performance caches
#   - optimize_systemctl()           - Optimize systemctl daemon operations
#
# SECTION 11: MAIN EXECUTION
#   - main()                         - Main execution function
#==============================================================================

# Use safer bash settings, but allow for graceful error handling
set -uo pipefail

# Performance optimizations
export TERM=${TERM:-xterm}
export SYSTEMD_COLORS=0
export SYSTEMD_PAGER=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

#==============================================================================
# SECTION 1: INITIALIZATION & CONFIGURATION
#==============================================================================

# Global variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FRP_VERSION="0.65.0"
FRP_ARCH="linux_amd64"
FRP_DIR="/opt/frp"
CONFIG_DIR="/etc/frp"
SERVICE_DIR="/etc/systemd/system"
LOG_DIR="/var/log/frp"
TEMP_DIR="/tmp/moonfrp"

# MoonFRP Repository Settings
MOONFRP_VERSION="1.1.1"
MOONFRP_REPO_URL="https://api.github.com/repos/k4lantar4/moonfrp/releases/latest"
MOONFRP_SCRIPT_URL="https://raw.githubusercontent.com/k4lantar4/moonfrp/main/moonfrp.sh"
MOONFRP_INSTALL_PATH="/usr/local/bin/moonfrp"

# Consolidated global state using associative arrays
declare -A TEMPLATE_CONFIG=(
    ["proxy_type"]=""
    ["proxy_name"]=""
    ["ports"]=""
    ["name"]=""
    ["description"]=""
    ["custom_domains"]=""
)

declare -A MENU_STATE=(
    ["depth"]="0"
    ["stack"]=""
    ["ctrl_c_pressed"]="false"
)

declare -A CACHE_DATA=(
    ["services"]=""
    ["services_time"]="0"
    ["frp_installation"]=""
    ["update_check_done"]="false"
    ["last_update_check"]=""
)

# Create required directories
#==============================================================================
# INITIALIZATION & CONFIGURATION FUNCTIONS
#==============================================================================

# Create required directories for MoonFRP
# Creates all necessary directories for configs, logs, services, backups, and templates
# Returns: 0 on success, 1 on failure
create_directories() {
    local dirs=("$FRP_DIR" "$CONFIG_DIR" "$LOG_DIR" "$TEMP_DIR")
    for dir in "${dirs[@]}"; do
        [[ ! -d "$dir" ]] && mkdir -p "$dir"
    done
}

# Centralized logging function with color coding and timestamp
# Usage: log LEVEL "message"
# Levels: DEBUG, INFO, WARN, ERROR
# Colors: DEBUG=gray, INFO=green, WARN=yellow, ERROR=red
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    case "$level" in
        "INFO")  echo -e "${GREEN}[INFO]${NC} $message" ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC} $message" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $message" ;;
        "DEBUG") echo -e "${BLUE}[DEBUG]${NC} $message" ;;
    esac

    # Safe logging to file
    if [[ -d "$LOG_DIR" ]]; then
        echo "[$timestamp] [$level] $message" >> "$LOG_DIR/moonfrp.log" 2>/dev/null || true
    fi
}

# Error handling
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo -e "${RED}[ERROR]${NC} Script failed at line $line_number with exit code $exit_code"
    # Don't exit immediately, just log the error
    return 0
}

# Only trap errors for critical functions, not the entire script
# trap 'handle_error $LINENO' ERR

# Signal handler for Ctrl+C
signal_handler() {
    echo -e "\n${YELLOW}[CTRL+C] Operation cancelled...${NC}"

    # If we're in main menu (depth 0), exit gracefully
    if [[ ${MENU_STATE["depth"]} -eq 0 ]]; then
        echo -e "${GREEN}Exiting MoonFRP. Goodbye! 🚀${NC}"
        cleanup_and_exit
    else
        # In submenu, return to previous menu
        echo -e "${CYAN}Returning to previous menu...${NC}"
        sleep 1
        MENU_STATE["ctrl_c_pressed"]="true"
        return 130  # Standard exit code for SIGINT
    fi
}

# Setup signal trapping
# Setup signal handlers for graceful shutdown
# Configures SIGINT (Ctrl+C) and SIGTERM handlers for clean exit
# Uses MENU_STATE associative array for tracking menu depth and Ctrl+C state
setup_signal_handlers() {
    trap signal_handler SIGINT
}

# Enter a submenu (increase depth)
enter_submenu() {
    local menu_name="$1"
    ((MENU_STATE["depth"]++))
    MENU_STATE["stack"]+="$menu_name "
    MENU_STATE["ctrl_c_pressed"]="false"
}

# Exit a submenu (decrease depth)
exit_submenu() {
    if [[ ${MENU_STATE["depth"]} -gt 0 ]]; then
        ((MENU_STATE["depth"]--))
        # Remove last menu from stack
        MENU_STATE["stack"]="${MENU_STATE["stack"]% *}"
    fi
    MENU_STATE["ctrl_c_pressed"]="false"
}

# Function to check if Ctrl+C was pressed during input
check_ctrl_c() {
    if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
        MENU_STATE["ctrl_c_pressed"]="false"
        return 1  # Return to main menu
    fi
    return 0
}

# Enhanced read function that handles Ctrl+C properly
safe_read() {
    local prompt="$1"
    local var_name="$2"
    local default_value="${3:-}"

    # Reset Ctrl+C flag
    MENU_STATE["ctrl_c_pressed"]="false"

    # Use regular read but check for Ctrl+C interrupt
    if read -r $var_name; then
        # Input received successfully
        local input_value=$(eval echo \$$var_name)
        if [[ -z "$input_value" && -n "$default_value" ]]; then
            eval $var_name="$default_value"
        fi
        return 0
    else
        # Read was interrupted (likely by Ctrl+C)
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            return 1  # Ctrl+C was pressed
        fi
        return 0  # Normal completion
    fi
}

# Safe read with automatic Ctrl+C handling for menus
safe_read_menu() {
    local prompt="$1"
    local var_name="$2"
    local default_value="${3:-}"

    echo -e "$prompt"
    read -r $var_name

    # Check for Ctrl+C after read
    if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
        MENU_STATE["ctrl_c_pressed"]="false"
        return 1
    fi

    # Apply default value if needed
    local input_value=$(eval echo \$$var_name)
    if [[ -z "$input_value" && -n "$default_value" ]]; then
        eval $var_name="$default_value"
    fi

    return 0
}

# Enhanced read function with Ctrl+C handling and return to menu
safe_read_with_return() {
    local prompt="$1"
    local var_name="$2"
    local default_value="${3:-}"

    echo -e "$prompt"
    read -r $var_name

    # Check for Ctrl+C after read
    if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
        MENU_STATE["ctrl_c_pressed"]="false"
        echo -e "${CYAN}Returning to menu...${NC}"
        return 1  # Signal to return to menu
    fi

    # Apply default value if needed
    local input_value=$(eval echo \$$var_name)
    if [[ -z "$input_value" && -n "$default_value" ]]; then
        eval $var_name="$default_value"
    fi

    return 0
}

# Wrapper function for read operations in configuration functions
read_with_ctrl_c_check() {
    local prompt="$1"
    local var_name="$2"
    local default_value="${3:-}"

    echo -e "$prompt"
    read -r $var_name

    # Check for Ctrl+C and return to menu if detected
    if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
        MENU_STATE["ctrl_c_pressed"]="false"
        echo -e "${CYAN}Returning to menu...${NC}"
        return 1
    fi

    # Apply default value if needed
    local input_value=$(eval echo \$$var_name)
    if [[ -z "$input_value" && -n "$default_value" ]]; then
        eval $var_name="$default_value"
    fi

    return 0
}

# Quick help for common errors
show_quick_help() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║         MoonFRP Quick Help           ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    echo -e "\n${RED}❌ Common Error: 'proxy already exists'${NC}"
    echo -e "${CYAN}Solution:${NC}"
    echo -e "  1. Stop all FRP services: ${GREEN}systemctl stop moonfrp-*${NC}"
    echo -e "  2. Remove old configs: ${GREEN}rm -f /etc/frp/frpc_*.toml${NC}"
    echo -e "  3. Use MoonFRP menu option 6 → 5 → 2 to reset configs"
    echo -e "  4. Recreate configurations with unique names"

    echo -e "\n${RED}❌ Common Error: 'port unavailable'${NC}"
    echo -e "${CYAN}Solution:${NC}"
    echo -e "  1. Check server allowPorts config: ${GREEN}/etc/frp/frps.toml${NC}"
    echo -e "  2. Ensure port range includes your ports (1000-65535)"
    echo -e "  3. Check if port is already used: ${GREEN}netstat -tlnp | grep :PORT${NC}"
    echo -e "  4. Try different ports or free the conflicting ones"

    echo -e "\n${RED}❌ Common Error: 'connection refused'${NC}"
    echo -e "${CYAN}Solution:${NC}"
    echo -e "  1. Verify server is running: ${GREEN}systemctl status moonfrp-server${NC}"
    echo -e "  2. Check firewall allows port 7000: ${GREEN}ufw allow 7000/tcp${NC}"
    echo -e "  3. Verify server IP and token match client config"
    echo -e "  4. Test connection: ${GREEN}nc -z SERVER_IP 7000${NC}"

    echo -e "\n${RED}❌ Common Error: 'authentication failed'${NC}"
    echo -e "${CYAN}Solution:${NC}"
    echo -e "  1. Ensure server and client tokens match exactly"
    echo -e "  2. Check server config: ${GREEN}/etc/frp/frps.toml${NC}"
    echo -e "  3. Check client config: ${GREEN}/etc/frp/frpc_*.toml${NC}"
    echo -e "  4. Regenerate token if needed"

    echo -e "\n${RED}❌ Common Error: 'HTTP 503 - Web Panel'${NC}"
    echo -e "${CYAN}Solution:${NC}"
    echo -e "  1. Check if FRP server is running: ${GREEN}systemctl status moonfrp-server${NC}"
    echo -e "  2. Verify dashboard port in config: ${GREEN}/etc/frp/frps.toml${NC}"
    echo -e "  3. Check firewall allows dashboard port: ${GREEN}ufw allow 7500/tcp${NC}"
    echo -e "  4. Use menu option 6 → 8 for web panel diagnostics"
    echo -e "  5. Try restarting: ${GREEN}systemctl status moonfrp-server${NC}"

    echo -e "\n${YELLOW}💡 Pro Tips:${NC}"
    echo -e "  • Use menu option 6 for detailed diagnostics"
    echo -e "  • Check logs: ${GREEN}journalctl -u moonfrp-* -f${NC}"
    echo -e "  • Backup configs before changes"
    echo -e "  • Use unique proxy names with timestamps"
    echo -e "  • Web panel usually runs on port 7500"

    read -p "Press Enter to continue..."
}

#==============================================================================
# SECTION 3: VALIDATION & ERROR HANDLING
#==============================================================================

# Input validation functions
validate_ip() {
    local ip="$1"
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        IFS='.' read -ra ADDR <<< "$ip"
        for i in "${ADDR[@]}"; do
            [[ $i -gt 255 ]] && return 1
        done
        return 0
    fi
    return 1
}

validate_port() {
    local port="$1"
    [[ $port =~ ^[0-9]+$ ]] && [[ $port -ge 1 ]] && [[ $port -le 65535 ]]
}

validate_ports_list() {
    local ports="$1"
    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        validate_port "$port" || return 1
    done
    return 0
}

validate_ips_list() {
    local ips="$1"
    IFS=',' read -ra IP_ARRAY <<< "$ips"
    for ip in "${IP_ARRAY[@]}"; do
        ip=$(echo "$ip" | tr -d ' ')
        validate_ip "$ip" || return 1
    done
    return 0
}

# Enhanced validation for domain names
validate_domain() {
    local domain="$1"

    # Basic domain validation regex
    if [[ "$domain" =~ ^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]$ ]] &&
       [[ ! "$domain" =~ \.\. ]] &&
       [[ ! "$domain" =~ ^- ]] &&
       [[ ! "$domain" =~ -$ ]] &&
       [[ ${#domain} -le 253 ]]; then
        return 0
    else
        return 1
    fi
}

# Proxy type selection menu
select_proxy_type() {
    while true; do
        # Check for Ctrl+C signal
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return 1
        fi

        clear
        echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║            MoonFRP                   ║${NC}"
        echo -e "${PURPLE}║        Proxy Type Selection          ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

        echo -e "\n${CYAN}Select Proxy Type:${NC}"
        echo -e "${GREEN}1. TCP${NC} ${YELLOW}(Basic port forwarding - Default)${NC}"
        echo -e "   • Direct port-to-port mapping"
        echo -e "   • Suitable for: SSH, databases, custom apps"
        echo -e "   • Example: local:22 → remote:22"

        echo -e "\n${GREEN}2. HTTP${NC} ${YELLOW}(Web services with domain names)${NC}"
        echo -e "   • Domain-based routing via Host header"
        echo -e "   • Suitable for: websites, web APIs, dev servers"
        echo -e "   • Example: myapp.example.com → local:3000"

        echo -e "\n${GREEN}3. HTTPS${NC} ${YELLOW}(Secure web services with SSL)${NC}"
        echo -e "   • Encrypted domain-based routing"
        echo -e "   • Suitable for: production websites, secure APIs"
        echo -e "   • Example: secure.example.com → local:443"

        echo -e "\n${GREEN}4. UDP${NC} ${YELLOW}(Games, DNS, streaming)${NC}"
        echo -e "   • UDP protocol forwarding"
        echo -e "   • Suitable for: game servers, DNS, video streaming"
        echo -e "   • Example: local:25565 → remote:25565"

        echo -e "\n${GREEN}5. TCPMUX${NC} ${YELLOW}(TCP multiplexing over HTTP CONNECT)${NC}"
        echo -e "   • HTTP CONNECT based TCP multiplexing"
        echo -e "   • Suitable for: HTTP proxy tunneling, corporate firewalls"
        echo -e "   • Example: tunnel1.example.com → local:8080"

        echo -e "\n${GREEN}6. STCP${NC} ${YELLOW}(Secret TCP - P2P secure tunneling)${NC}"
        echo -e "   • Secure point-to-point TCP tunneling"
        echo -e "   • Suitable for: private services, secure remote access"
        echo -e "   • Requires: secret key authentication"

        echo -e "\n${GREEN}7. SUDP${NC} ${YELLOW}(Secret UDP - P2P secure tunneling)${NC}"
        echo -e "   • Secure point-to-point UDP tunneling"
        echo -e "   • Suitable for: private games, secure UDP services"
        echo -e "   • Requires: secret key authentication"

        echo -e "\n${GREEN}8. TCPMUX-Direct${NC} ${YELLOW}(TCP-like access with TCPMUX benefits)${NC}"
        echo -e "   • Provides TCP-like access while maintaining TCPMUX benefits"
        echo -e "   • Suitable for: corporate firewalls, secure remote access"
        echo -e "   • Requires: secret key authentication"

        echo -e "\n${GREEN}9. XTCP${NC} ${YELLOW}(P2P TCP - Direct peer-to-peer connection)${NC}"
        echo -e "   • True P2P TCP connection with NAT traversal"
        echo -e "   • Suitable for: gaming, real-time applications, direct access"
        echo -e "   • Features: NAT hole punching, fallback options"

        echo -e "\n${GREEN}10. Plugin System${NC} ${YELLOW}(Unix sockets, HTTP/SOCKS5 proxy, Static files)${NC}"
        echo -e "   • Unix domain socket forwarding"
        echo -e "   • HTTP/SOCKS5 proxy server functionality"
        echo -e "   • Static file server with authentication"

        echo -e "\n${CYAN}0. Back${NC}"

        echo -e "\n${YELLOW}Enter your choice [0-10] (default: 1):${NC} "
        read -r choice

        # Check for Ctrl+C after read
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return 1
        fi

        # Default to TCP if no input
        [[ -z "$choice" ]] && choice=1

        case $choice in
            1)
                SELECTED_PROXY_TYPE="tcp"
                SELECTED_PROXY_NAME="TCP"
                return 0
                ;;
            2)
                SELECTED_PROXY_TYPE="http"
                SELECTED_PROXY_NAME="HTTP"
                return 0
                ;;
            3)
                SELECTED_PROXY_TYPE="https"
                SELECTED_PROXY_NAME="HTTPS"
                return 0
                ;;
            4)
                SELECTED_PROXY_TYPE="udp"
                SELECTED_PROXY_NAME="UDP"
                return 0
                ;;
            5)
                SELECTED_PROXY_TYPE="tcpmux"
                SELECTED_PROXY_NAME="TCPMUX"
                return 0
                ;;
            6)
                SELECTED_PROXY_TYPE="stcp"
                SELECTED_PROXY_NAME="STCP"
                return 0
                ;;
            7)
                SELECTED_PROXY_TYPE="sudp"
                SELECTED_PROXY_NAME="SUDP"
                return 0
                ;;
            8)
                SELECTED_PROXY_TYPE="tcpmux-direct"
                SELECTED_PROXY_NAME="TCPMUX-Direct"
                return 0
                ;;
            9)
                SELECTED_PROXY_TYPE="xtcp"
                SELECTED_PROXY_NAME="XTCP"
                return 0
                ;;
            10)
                # Call plugin selection submenu
                if select_plugin_type; then
                    return 0
                else
                    continue
                fi
                ;;
            0)
                return 1
                ;;
            *)
                log "WARN" "Invalid choice. Please try again."
                sleep 2
                ;;
        esac
    done
}

# Plugin type selection menu
select_plugin_type() {
    while true; do
        # Check for Ctrl+C signal
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return 1
        fi

        clear
        echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║            MoonFRP                   ║${NC}"
        echo -e "${PURPLE}║        Plugin Type Selection        ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

        echo -e "\n${CYAN}Select Plugin Type:${NC}"
        echo -e "${GREEN}1. Unix Domain Socket${NC} ${YELLOW}(Forward to Unix socket)${NC}"
        echo -e "   • Connect to Unix domain sockets"
        echo -e "   • Suitable for: Docker API, system sockets"
        echo -e "   • Example: /var/run/docker.sock"

        echo -e "\n${GREEN}2. HTTP Proxy${NC} ${YELLOW}(HTTP proxy server)${NC}"
        echo -e "   • Create HTTP proxy server"
        echo -e "   • Suitable for: web browsing, API access"
        echo -e "   • Features: username/password authentication"

        echo -e "\n${GREEN}3. SOCKS5 Proxy${NC} ${YELLOW}(SOCKS5 proxy server)${NC}"
        echo -e "   • Create SOCKS5 proxy server"
        echo -e "   • Suitable for: general TCP/UDP proxying"
        echo -e "   • Features: username/password authentication"

        echo -e "\n${GREEN}4. Static File Server${NC} ${YELLOW}(Serve static files)${NC}"
        echo -e "   • Serve static files over HTTP"
        echo -e "   • Suitable for: file sharing, web hosting"
        echo -e "   • Features: authentication, path stripping"

        echo -e "\n${GREEN}5. HTTPS2HTTP${NC} ${YELLOW}(HTTPS to HTTP converter)${NC}"
        echo -e "   • Convert HTTPS requests to HTTP"
        echo -e "   • Suitable for: SSL termination, legacy services"
        echo -e "   • Features: certificate handling, header rewriting"

        echo -e "\n${GREEN}6. HTTP2HTTPS${NC} ${YELLOW}(HTTP to HTTPS converter)${NC}"
        echo -e "   • Convert HTTP requests to HTTPS"
        echo -e "   • Suitable for: SSL wrapping, secure backends"
        echo -e "   • Features: certificate handling, header rewriting"

        echo -e "\n${CYAN}0. Back${NC}"

        echo -e "\n${YELLOW}Enter your choice [0-6] (default: 1):${NC} "
        read -r choice

        # Check for Ctrl+C after read
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return 1
        fi

        # Default to Unix Domain Socket if no input
        [[ -z "$choice" ]] && choice=1

        case $choice in
            1)
                SELECTED_PROXY_TYPE="plugin_unix_socket"
                SELECTED_PROXY_NAME="Unix Domain Socket"
                return 0
                ;;
            2)
                SELECTED_PROXY_TYPE="plugin_http_proxy"
                SELECTED_PROXY_NAME="HTTP Proxy"
                return 0
                ;;
            3)
                SELECTED_PROXY_TYPE="plugin_socks5"
                SELECTED_PROXY_NAME="SOCKS5 Proxy"
                return 0
                ;;
            4)
                SELECTED_PROXY_TYPE="plugin_static_file"
                SELECTED_PROXY_NAME="Static File Server"
                return 0
                ;;
            5)
                SELECTED_PROXY_TYPE="plugin_https2http"
                SELECTED_PROXY_NAME="HTTPS2HTTP"
                return 0
                ;;
            6)
                SELECTED_PROXY_TYPE="plugin_http2https"
                SELECTED_PROXY_NAME="HTTP2HTTPS"
                return 0
                ;;
            0)
                return 1
                ;;
            *)
                log "WARN" "Invalid choice. Please try again."
                sleep 2
                ;;
        esac
    done
}

# Domain input for HTTP/HTTPS proxies
get_custom_domains() {
    local ports="$1"
    local domains=""

    echo -e "\n${CYAN}Domain Configuration for ${SELECTED_PROXY_NAME} Proxy:${NC}"
    echo -e "${YELLOW}You can specify custom domains for your services.${NC}"
    echo -e "${YELLOW}Leave empty to use auto-generated domains.${NC}"

    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    local domain_list=()

    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        echo -e "\n${CYAN}Domain for service on port $port:${NC}"
        echo -e "${GREEN}Examples:${NC}"
        echo -e "  • myapp.example.com"
        echo -e "  • api.mydomain.org"
        echo -e "  • subdomain.yourdomain.net"

        read -p "Custom domain (or press Enter for auto): " domain

        if [[ -n "$domain" ]]; then
            # Basic domain validation
            if validate_domain "$domain"; then
                domain_list+=("$domain")
                echo -e "${GREEN}✅ Domain set: $domain → localhost:$port${NC}"
            else
                echo -e "${RED}❌ Invalid domain format. Using auto-generated domain.${NC}"
                domain_list+=("app${port}.moonfrp.local")
            fi
        else
            domain_list+=("app${port}.moonfrp.local")
            echo -e "${YELLOW}Using auto-generated: app${port}.moonfrp.local${NC}"
        fi
    done

    # Join domains with commas
    local IFS=','
    CUSTOM_DOMAINS="${domain_list[*]}"

    echo -e "\n${CYAN}📋 Domain Summary:${NC}"
    for i in "${!PORT_ARRAY[@]}"; do
        echo -e "  ${GREEN}${domain_list[$i]}${NC} → localhost:${PORT_ARRAY[$i]}"
    done
}

# Enhanced FRP configuration validation
validate_frp_config() {
    local config_file="$1"
    local validation_failed=false

    log "INFO" "Validating FRP configuration: $config_file"

    # Check if file exists
    if [[ ! -f "$config_file" ]]; then
        log "ERROR" "Configuration file not found: $config_file"
        return 1
    fi

    # Check if frpc binary exists for validation
    if [[ ! -f "$FRP_DIR/frpc" ]]; then
        log "WARN" "FRP client binary not found, skipping syntax validation"
    else
        # Syntax validation using frpc verify
        if ! "$FRP_DIR/frpc" verify -c "$config_file" >/dev/null 2>&1; then
            log "ERROR" "Configuration syntax error in $config_file"
            validation_failed=true
        else
            log "INFO" "✅ Configuration syntax is valid"
        fi
    fi

    # Check for common configuration issues
    local server_addr=$(grep "serverAddr" "$config_file" | head -1 | cut -d'"' -f2)
    local server_port=$(grep "serverPort" "$config_file" | head -1 | cut -d'=' -f2 | tr -d ' ')

    if [[ -n "$server_addr" && -n "$server_port" ]]; then
        log "INFO" "Testing server connectivity: $server_addr:$server_port"
        if ! timeout 3 nc -z "$server_addr" "$server_port" 2>/dev/null; then
            log "WARN" "⚠️  Cannot connect to server $server_addr:$server_port"
            validation_failed=true
        else
            log "INFO" "✅ Server connectivity confirmed"
        fi
    fi

    # Check for port conflicts across all configurations
    check_global_port_conflicts "$config_file"
    local conflict_result=$?
    if [[ $conflict_result -ne 0 ]]; then
        validation_failed=true
    fi

    # Check for proxy name conflicts
    check_global_proxy_conflicts "$config_file"
    local name_conflict_result=$?
    if [[ $name_conflict_result -ne 0 ]]; then
        validation_failed=true
    fi

    if [[ "$validation_failed" == "true" ]]; then
        log "ERROR" "❌ Configuration validation failed"
        return 1
    else
        log "INFO" "✅ Configuration validation passed"
        return 0
    fi
}

# Check for port conflicts across all FRP configurations
check_global_port_conflicts() {
    local new_config_file="$1"
    local conflicts_found=false

    # Extract ports from new configuration
    local new_ports=()
    while IFS= read -r line; do
        if [[ $line =~ remotePort\ *=\ *([0-9]+) ]]; then
            new_ports+=("${BASH_REMATCH[1]}")
        fi
    done < "$new_config_file"

    # Check against all existing configurations
    for existing_config in "$CONFIG_DIR"/frpc_*.toml; do
        [[ ! -f "$existing_config" ]] && continue
        [[ "$existing_config" == "$new_config_file" ]] && continue

        while IFS= read -r line; do
            if [[ $line =~ remotePort\ *=\ *([0-9]+) ]]; then
                local existing_port="${BASH_REMATCH[1]}"

                for new_port in "${new_ports[@]}"; do
                    if [[ "$new_port" == "$existing_port" ]]; then
                        log "ERROR" "❌ Port conflict: $new_port already used in $existing_config"
                        conflicts_found=true
                    fi
                done
            fi
        done < "$existing_config"
    done

    # Check against system ports
    for port in "${new_ports[@]}"; do
        if netstat -tlnp 2>/dev/null | grep -q ":$port "; then
            log "WARN" "⚠️  Port $port is in use by system process"
        fi
    done

    [[ "$conflicts_found" == "true" ]] && return 1 || return 0
}

# Check for proxy name conflicts across all FRP configurations
check_global_proxy_conflicts() {
    local new_config_file="$1"
    local conflicts_found=false

    # Extract proxy names from new configuration
    local new_names=()
    while IFS= read -r line; do
        if [[ $line =~ name\ *=\ *\"([^\"]+)\" ]]; then
            new_names+=("${BASH_REMATCH[1]}")
        fi
    done < "$new_config_file"

    # Check against all existing configurations
    for existing_config in "$CONFIG_DIR"/frpc_*.toml; do
        [[ ! -f "$existing_config" ]] && continue
        [[ "$existing_config" == "$new_config_file" ]] && continue

        while IFS= read -r line; do
            if [[ $line =~ name\ *=\ *\"([^\"]+)\" ]]; then
                local existing_name="${BASH_REMATCH[1]}"

                for new_name in "${new_names[@]}"; do
                    if [[ "$new_name" == "$existing_name" ]]; then
                        log "ERROR" "❌ Proxy name conflict: '$new_name' already exists in $existing_config"
                        conflicts_found=true
                    fi
                done
            fi
        done < "$existing_config"
    done

    [[ "$conflicts_found" == "true" ]] && return 1 || return 0
}

# Performance monitoring for FRP proxies
monitor_proxy_performance() {
    local proxy_name="$1"
    local admin_port="${2:-7400}"

    log "INFO" "Monitoring performance for proxy: $proxy_name"

    # Try to get stats from FRP dashboard API
    local api_url="http://127.0.0.1:$admin_port/api/proxy/$proxy_name"

    if command -v curl >/dev/null 2>&1; then
        local response=$(curl -s --connect-timeout 3 "$api_url" 2>/dev/null)

        if [[ -n "$response" ]] && echo "$response" | grep -q "name"; then
            echo -e "${CYAN}📊 Performance Stats for $proxy_name:${NC}"

            # Parse JSON response (basic parsing without jq)
            local status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
            local today_in=$(echo "$response" | grep -o '"today_in":[0-9]*' | cut -d':' -f2)
            local today_out=$(echo "$response" | grep -o '"today_out":[0-9]*' | cut -d':' -f2)
            local cur_conns=$(echo "$response" | grep -o '"cur_conns":[0-9]*' | cut -d':' -f2)

            [[ -n "$status" ]] && echo -e "  Status: ${GREEN}$status${NC}"
            [[ -n "$today_in" ]] && echo -e "  Today In: ${CYAN}$(format_bytes $today_in)${NC}"
            [[ -n "$today_out" ]] && echo -e "  Today Out: ${CYAN}$(format_bytes $today_out)${NC}"
            [[ -n "$cur_conns" ]] && echo -e "  Active Connections: ${YELLOW}$cur_conns${NC}"
        else
            log "WARN" "Unable to retrieve performance data for $proxy_name"
        fi
    else
        log "WARN" "curl not available for performance monitoring"
    fi
}

# Format bytes to human readable format
format_bytes() {
    local bytes="$1"
    local units=("B" "KB" "MB" "GB" "TB")
    local unit_index=0

    [[ -z "$bytes" || "$bytes" == "0" ]] && echo "0 B" && return

    while [[ $bytes -gt 1024 && $unit_index -lt ${#units[@]} ]]; do
        bytes=$((bytes / 1024))
        ((unit_index++))
    done

    echo "$bytes ${units[$unit_index]}"
}

# Monitor all active proxies
monitor_all_proxies() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║         Proxy Performance            ║${NC}"
    echo -e "${PURPLE}║           Monitoring                 ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    echo -e "\n${CYAN}🔍 Scanning for active FRP services...${NC}"

    local services=($(systemctl list-units --type=service --state=active --no-legend --plain | grep -E "(frpc|frps)" | awk '{print $1}' | sed 's/\.service//'))

    if [[ ${#services[@]} -eq 0 ]]; then
        echo -e "\n${YELLOW}No active FRP services found${NC}"
        return
    fi

    echo -e "\n${GREEN}Found ${#services[@]} active service(s):${NC}"

    for service in "${services[@]}"; do
        echo -e "\n${CYAN}📈 Service: $service${NC}"

        # Get service status
        local status=$(systemctl is-active "$service" 2>/dev/null)
        local status_color="$RED"
        [[ "$status" == "active" ]] && status_color="$GREEN"

        echo -e "  Status: ${status_color}$status${NC}"

        # Get configuration file
        local config_file=""
        if [[ "$service" =~ frpc ]]; then
            local suffix=$(echo "$service" | grep -o '[0-9]\+$')
            [[ -n "$suffix" ]] && config_file="$CONFIG_DIR/frpc_${suffix}.toml"
        elif [[ "$service" =~ frps ]]; then
            config_file="$CONFIG_DIR/frps.toml"
        fi

        if [[ -f "$config_file" ]]; then
            echo -e "  Config: ${CYAN}$config_file${NC}"

            # Show proxy count
            local proxy_count=$(grep -c "^\[\[proxies\]\]" "$config_file" 2>/dev/null || echo "0")
            echo -e "  Proxies: ${YELLOW}$proxy_count${NC}"

            # Get recent log entries
            echo -e "  ${YELLOW}Recent activity:${NC}"
            if journalctl -u "$service" -n 3 --no-pager --since "10 minutes ago" -q 2>/dev/null | head -3; then
                :
            else
                echo -e "    ${GRAY}No recent activity${NC}"
            fi
        else
            echo -e "  ${RED}Configuration file not found${NC}"
        fi

        # Connection test for client services
        if [[ "$service" =~ frpc && -f "$config_file" ]]; then
            local server_addr=$(grep "serverAddr" "$config_file" | head -1 | cut -d'"' -f2)
            local server_port=$(grep "serverPort" "$config_file" | head -1 | cut -d'=' -f2 | tr -d ' ')

            if [[ -n "$server_addr" && -n "$server_port" ]]; then
                echo -e -n "  Server Test: "
                if timeout 2 nc -z "$server_addr" "$server_port" 2>/dev/null; then
                    echo -e "${GREEN}✅ Connected${NC}"
                else
                    echo -e "${RED}❌ Failed${NC}"
                fi
            fi
        fi

        echo -e "  ${GRAY}────────────────────────────────────${NC}"
    done

    echo -e "\n${YELLOW}💡 Tip: Use 'journalctl -u SERVICE_NAME -f' for real-time logs${NC}"
}

# Configuration templates for different use cases
get_config_template() {
    local template_type="$1"

    while true; do
        clear
        echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║      Configuration Templates        ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

        echo -e "\n${CYAN}Available Templates:${NC}"
        echo -e "${GREEN}1. SSH Server${NC} ${YELLOW}(Port 22)${NC}"
        echo -e "   • Secure remote shell access"
        echo -e "   • Port: 22 → 22"

        echo -e "\n${GREEN}2. Web Development${NC} ${YELLOW}(Port 3000, 8080)${NC}"
        echo -e "   • Development servers (React, Node.js, etc.)"
        echo -e "   • Ports: 3000,8080 → 3000,8080"

        echo -e "\n${GREEN}3. Database Server${NC} ${YELLOW}(MySQL, PostgreSQL)${NC}"
        echo -e "   • MySQL: 3306 → 3306"
        echo -e "   • PostgreSQL: 5432 → 5432"

        echo -e "\n${GREEN}4. Game Server${NC} ${YELLOW}(Minecraft, CS)${NC}"
        echo -e "   • Minecraft: 25565 → 25565"
        echo -e "   • Counter-Strike: 27015 → 27015"

        echo -e "\n${GREEN}5. Web Server${NC} ${YELLOW}(HTTP/HTTPS)${NC}"
        echo -e "   • HTTP: 80 → 80"
        echo -e "   • HTTPS: 443 → 443"

        echo -e "\n${GREEN}6. Remote Desktop${NC} ${YELLOW}(RDP, VNC)${NC}"
        echo -e "   • RDP: 3389 → 3389"
        echo -e "   • VNC: 5900 → 5900"

        echo -e "\n${GREEN}7. File Transfer${NC} ${YELLOW}(FTP, SFTP)${NC}"
        echo -e "   • FTP: 21 → 21"
        echo -e "   • SFTP: 22 → 22"

        echo -e "\n${GREEN}8. Custom Ports${NC} ${YELLOW}(Manual configuration)${NC}"
        echo -e "   • Specify your own ports"

        echo -e "\n${GREEN}9. Advanced Protocols${NC} ${YELLOW}(TCPMUX, STCP, SUDP)${NC}"
        echo -e "   • Modern tunneling protocols"
        echo -e "   • Secure P2P connections"

        echo -e "\n${CYAN}0. Back${NC}"

        echo -e "\n${YELLOW}Select template [0-8]:${NC} "
        read -r template_choice

        case $template_choice in
            1)
                TEMPLATE_CONFIG["ports"]="22"
                TEMPLATE_CONFIG["name"]="SSH Server"
                TEMPLATE_CONFIG["description"]="Secure Shell remote access"
                TEMPLATE_CONFIG["proxy_type"]="tcp"
                return 0
                ;;
            2)
                TEMPLATE_CONFIG["ports"]="3000,8080"
                TEMPLATE_CONFIG["name"]="Web Development"
                TEMPLATE_CONFIG["description"]="Development servers (React, Node.js, etc.)"
                TEMPLATE_CONFIG["proxy_type"]="http"
                return 0
                ;;
            3)
                echo -e "\n${CYAN}Select Database Type:${NC}"
                echo "1. MySQL (Port 3306)"
                echo "2. PostgreSQL (Port 5432)"
                echo "3. Both MySQL & PostgreSQL"
                read -p "Choice [1-3]: " db_choice

                case $db_choice in
                    1) TEMPLATE_CONFIG["ports"]="3306" ;;
                    2) TEMPLATE_CONFIG["ports"]="5432" ;;
                    3) TEMPLATE_CONFIG["ports"]="3306,5432" ;;
                    *) continue ;;
                esac

                TEMPLATE_CONFIG["name"]="Database Server"
                TEMPLATE_CONFIG["description"]="Database server access"
                TEMPLATE_CONFIG["proxy_type"]="tcp"
                return 0
                ;;
            4)
                echo -e "\n${CYAN}Select Game Server Type:${NC}"
                echo "1. Minecraft (Port 25565)"
                echo "2. Counter-Strike (Port 27015)"
                echo "3. Custom Game Port"
                read -p "Choice [1-3]: " game_choice

                case $game_choice in
                    1) TEMPLATE_CONFIG["ports"]="25565" ;;
                    2) TEMPLATE_CONFIG["ports"]="27015" ;;
                    3)
                        read -p "Enter custom game port: " custom_port
                        if validate_port "$custom_port"; then
                            TEMPLATE_CONFIG["ports"]="$custom_port"
                        else
                            log "ERROR" "Invalid port number"
                            continue
                        fi
                        ;;
                    *) continue ;;
                esac

                TEMPLATE_CONFIG["name"]="Game Server"
                TEMPLATE_CONFIG["description"]="Game server access"
                TEMPLATE_CONFIG["proxy_type"]="tcp"
                return 0
                ;;
            5)
                TEMPLATE_CONFIG["ports"]="80,443"
                TEMPLATE_CONFIG["name"]="Web Server"
                TEMPLATE_CONFIG["description"]="HTTP/HTTPS web server"
                TEMPLATE_CONFIG["proxy_type"]="http"
                return 0
                ;;
            6)
                echo -e "\n${CYAN}Select Remote Desktop Type:${NC}"
                echo "1. Windows RDP (Port 3389)"
                echo "2. VNC (Port 5900)"
                echo "3. Both RDP & VNC"
                read -p "Choice [1-3]: " rdp_choice

                case $rdp_choice in
                    1) TEMPLATE_CONFIG["ports"]="3389" ;;
                    2) TEMPLATE_CONFIG["ports"]="5900" ;;
                    3) TEMPLATE_CONFIG["ports"]="3389,5900" ;;
                    *) continue ;;
                esac

                TEMPLATE_CONFIG["name"]="Remote Desktop"
                TEMPLATE_CONFIG["description"]="Remote desktop access"
                TEMPLATE_CONFIG["proxy_type"]="tcp"
                return 0
                ;;
            7)
                TEMPLATE_CONFIG["ports"]="21,22"
                TEMPLATE_CONFIG["name"]="File Transfer"
                TEMPLATE_CONFIG["description"]="FTP/SFTP file transfer"
                TEMPLATE_CONFIG["proxy_type"]="tcp"
                return 0
                ;;
            8)
                echo -e "\n${CYAN}Custom Port Configuration:${NC}"
                read -p "Enter ports (comma-separated, e.g., 1111,2222,3333): " custom_ports

                if ! validate_ports_list "$custom_ports"; then
                    log "ERROR" "Invalid port format"
                    read -p "Press Enter to continue..."
                    continue
                fi

                TEMPLATE_CONFIG["ports"]="$custom_ports"
                TEMPLATE_CONFIG["name"]="Custom Configuration"
                TEMPLATE_CONFIG["description"]="Custom port configuration"
                TEMPLATE_CONFIG["proxy_type"]="tcp"
                return 0
                ;;
            9)
                echo -e "\n${CYAN}Advanced Protocol Selection:${NC}"
                echo "1. TCPMUX (HTTP CONNECT multiplexing)"
                echo "2. STCP (Secure TCP P2P)"
                echo "3. SUDP (Secure UDP P2P)"
                echo "4. XTCP (P2P TCP with NAT traversal)"

                read -p "Choose protocol [1-4]: " proto_choice
                case $proto_choice in
                    1)
                        TEMPLATE_CONFIG["ports"]="8080,8081,8082"
                        TEMPLATE_CONFIG["name"]="TCPMUX Tunneling"
                        TEMPLATE_CONFIG["description"]="HTTP CONNECT based TCP multiplexing"
                        TEMPLATE_CONFIG["proxy_type"]="tcpmux"
                        ;;
                    2)
                        TEMPLATE_CONFIG["ports"]="2222,3333,4444"
                        TEMPLATE_CONFIG["name"]="STCP Secure Tunneling"
                        TEMPLATE_CONFIG["description"]="Secure TCP P2P tunneling"
                        TEMPLATE_CONFIG["proxy_type"]="stcp"
                        ;;
                    3)
                        TEMPLATE_CONFIG["ports"]="5555,6666,7777"
                        TEMPLATE_CONFIG["name"]="SUDP Secure Tunneling"
                        TEMPLATE_CONFIG["description"]="Secure UDP P2P tunneling"
                        TEMPLATE_CONFIG["proxy_type"]="sudp"
                        ;;
                    4)
                        TEMPLATE_CONFIG["ports"]="8888,9999,10000"
                        TEMPLATE_CONFIG["name"]="XTCP P2P Tunneling"
                        TEMPLATE_CONFIG["description"]="P2P TCP with NAT traversal"
                        TEMPLATE_CONFIG["proxy_type"]="xtcp"
                        ;;
                    *)
                        log "WARN" "Invalid choice"
                        continue
                        ;;
                esac
                return 0
                ;;
            0)
                return 1
                ;;
            *)
                log "WARN" "Invalid choice. Please try again."
                sleep 2
                ;;
        esac
    done
}

# Show template summary and confirmation
confirm_template_configuration() {
    echo -e "\n${CYAN}📋 Template Configuration Summary:${NC}"
    echo -e "${GREEN}Template:${NC} $TEMPLATE_CONFIG["name"]"
    echo -e "${GREEN}Description:${NC} $TEMPLATE_CONFIG["description"]"
    echo -e "${GREEN}Proxy Type:${NC} $TEMPLATE_CONFIG["proxy_type"]"
    echo -e "${GREEN}Ports:${NC} $TEMPLATE_CONFIG["ports"]"

    # Show port mapping
    echo -e "\n${CYAN}Port Mapping:${NC}"
    IFS=',' read -ra PORT_ARRAY <<< "$TEMPLATE_CONFIG["ports"]"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        echo -e "  ${YELLOW}$port${NC} → ${GREEN}$port${NC}"
    done

    echo -e "\n${YELLOW}Continue with this template? (Y/n):${NC} "
    read -r confirm_template

    if [[ "$confirm_template" =~ ^[Nn]$ ]]; then
        return 1
    else
        return 0
    fi
}

# Generate random token (shorter and more user-friendly)
generate_token() {
    # Generate a shorter 12-character token for easier management
    openssl rand -hex 6 2>/dev/null || head -c 12 /dev/urandom | base64 | tr -d '=+/' | cut -c1-12
}

# Enhanced proxy conflict detection for both client and server configs
check_proxy_conflicts() {
    local config_dir="$1"
    local new_proxy_name="$2"
    local new_port="$3"
    local check_type="${4:-client}"  # client or server

    if [[ ! -d "$config_dir" ]]; then
        return 0  # No conflicts if config dir doesn't exist
    fi

    local conflicts_found=false

    if [[ "$check_type" == "client" ]]; then
        # Check for proxy name conflicts in client configs
        for config_file in "$config_dir"/frpc_*.toml; do
            [[ ! -f "$config_file" ]] && continue

            if grep -q "name = \"$new_proxy_name\"" "$config_file" 2>/dev/null; then
                log "WARN" "Client proxy name conflict detected: $new_proxy_name in $config_file"
                conflicts_found=true
            fi
        done

        # Check for port conflicts in client configs
        for config_file in "$config_dir"/frpc_*.toml; do
            [[ ! -f "$config_file" ]] && continue

            if grep -q "remotePort = $new_port" "$config_file" 2>/dev/null; then
                log "WARN" "Client port conflict detected: $new_port in $config_file"
                conflicts_found=true
            fi
        done
    fi

    if [[ "$check_type" == "server" ]] || [[ "$check_type" == "both" ]]; then
        # Check for port conflicts in server configs
        for config_file in "$config_dir"/frps*.toml; do
            [[ ! -f "$config_file" ]] && continue

            local server_bind_port=$(grep "bindPort" "$config_file" 2>/dev/null | awk '{print $3}' | tr -d '"')
            local dashboard_port=$(grep "webServer.port" "$config_file" 2>/dev/null | awk '{print $3}' | tr -d '"')

            if [[ -n "$server_bind_port" && "$server_bind_port" == "$new_port" ]]; then
                log "WARN" "Server bind port conflict detected: $new_port in $config_file"
                conflicts_found=true
            fi

            if [[ -n "$dashboard_port" && "$dashboard_port" == "$new_port" ]]; then
                log "WARN" "Server dashboard port conflict detected: $new_port in $config_file"
                conflicts_found=true
            fi
        done
    fi

    [[ "$conflicts_found" == "true" ]] && return 1 || return 0
}

# Clean up old/conflicting configurations
cleanup_old_configs() {
    local action="$1"

    case "$action" in
        "backup")
            local backup_dir="/etc/frp/backup_$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$backup_dir"

            for config_file in "$CONFIG_DIR"/frpc_*.toml; do
                [[ -f "$config_file" ]] && cp "$config_file" "$backup_dir/"
            done

            log "INFO" "Backed up existing configurations to: $backup_dir"
            ;;
        "remove")
            echo -e "\n${YELLOW}⚠️  Existing FRP client configurations found.${NC}"
            echo -e "${CYAN}Remove existing configurations? (Y/n):${NC} "
            read -r remove_choice

            if [[ ! "$remove_choice" =~ ^[Nn]$ ]]; then
                # Backup first
                cleanup_old_configs "backup"
                # Remove old configs
                rm -f "$CONFIG_DIR"/frpc_*.toml
                log "INFO" "Removed existing client configurations"
            else
                log "WARN" "Keeping existing configs - conflicts may occur"
            fi
            ;;
    esac

    return 0
}

# Validate server connection
validate_server_connection() {
    local server_ip="$1"
    local server_port="$2"

    log "INFO" "Validating connection to $server_ip:$server_port..."

    if timeout 5 nc -z "$server_ip" "$server_port" 2>/dev/null; then
        log "INFO" "✅ Server connection successful"
        return 0
    else
        log "WARN" "❌ Cannot connect to server $server_ip:$server_port"
        log "WARN" "Please ensure:"
        log "WARN" "  1. Server is running and accessible"
        log "WARN" "  2. Firewall allows connection to port $server_port"
        log "WARN" "  3. Network connectivity is available"
        return 1
    fi
}

#==============================================================================
# SECTION 4: FRP CONFIGURATION GENERATORS
#==============================================================================

# Generate frps.toml configuration
generate_frps_config() {
    local token="${1:-$(generate_token)}"
    local bind_port="${2:-7000}"
    local dashboard_port="${3:-}"
    local dashboard_user="${4:-}"
    local dashboard_password="${5:-}"
    local enable_kcp="${6:-true}"
    local enable_quic="${7:-false}"
    local custom_subdomain="${8:-moonfrp.local}"
    local max_clients="${9:-50}"
    local config_suffix="${10:-}"

    # Validate inputs
    if ! validate_port "$bind_port"; then
        log "ERROR" "Invalid bind port: $bind_port"
        return 1
    fi

    if [[ -n "$dashboard_port" ]] && ! validate_port "$dashboard_port"; then
        log "ERROR" "Invalid dashboard port: $dashboard_port"
        return 1
    fi

    # Determine config file name
    local config_file="$CONFIG_DIR/frps.toml"
    if [[ -n "$config_suffix" ]]; then
        config_file="$CONFIG_DIR/frps_${config_suffix}.toml"
    fi

    # Create complete and advanced configuration file based on official FRP v0.65.0 format
    cat > "$config_file" << EOF
# MoonFRP Server Configuration
# Generated on $(date)
# Compatible with FRP v0.65.0

bindAddr = "0.0.0.0"
bindPort = $bind_port

auth.method = "token"
auth.token = "$token"

log.to = "$LOG_DIR/frps$([ -n "$config_suffix" ] && echo "_$config_suffix" || echo "").log"
log.level = "warn"
log.maxDays = 2
log.disablePrintColor = false

vhostHTTPPort = 80
vhostHTTPSPort = 443
vhostHTTPTimeout = 60

tcpmuxHTTPConnectPort = 5002
tcpmuxPassthrough = false

transport.maxPoolCount = 50
transport.tcpMux = true
transport.tcpMuxKeepaliveInterval = 5
transport.heartbeatTimeout = 90
transport.tcpKeepalive = 300

transport.tls.force = false

subDomainHost = "$custom_subdomain"

maxPortsPerClient = 0
userConnTimeout = 10

allowPorts = [
    { start = 1000, end = 65535 }
]

detailedErrorsToClient = false
enablePrometheus = true
udpPacketSize = 1500
natholeAnalysisDataReserveHours = 168

EOF

    # Add dashboard settings only if enabled
    if [[ -n "$dashboard_port" && -n "$dashboard_user" && -n "$dashboard_password" ]]; then
        cat >> "$CONFIG_DIR/frps.toml" << EOF
# Dashboard settings
webServer.addr = "0.0.0.0"
webServer.port = $dashboard_port
webServer.user = "$dashboard_user"
webServer.password = "$dashboard_password"

EOF
    fi

    # Add KCP support if enabled
    if [[ "$enable_kcp" == "true" ]]; then
        cat >> "$CONFIG_DIR/frps.toml" << EOF
# 🚀 KCP Protocol support (UDP-based, better for poor networks)
kcpBindPort = $bind_port
# KCP can use same port as main bind port

EOF
    fi

    # Add QUIC support if enabled
    if [[ "$enable_quic" == "true" ]]; then
        local quic_port=$((bind_port + 1))
        cat >> "$CONFIG_DIR/frps.toml" << EOF
# 🚀 QUIC Protocol support (modern, encrypted UDP)
quicBindPort = $quic_port

# QUIC Protocol advanced options
transport.quic.keepalivePeriod = 10
transport.quic.maxIdleTimeout = 30
transport.quic.maxIncomingStreams = 100

EOF
    fi

    # Add SSH Tunnel Gateway support (optional advanced feature)
    cat >> "$CONFIG_DIR/frps.toml" << EOF
# SSH Tunnel Gateway (disabled by default)
# Uncomment to enable SSH gateway on port 2200
# sshTunnelGateway.bindPort = 2200
# sshTunnelGateway.privateKeyFile = "/home/frp-user/.ssh/id_rsa"
# sshTunnelGateway.autoGenPrivateKeyPath = ""
# sshTunnelGateway.authorizedKeysFile = "/home/frp-user/.ssh/authorized_keys"

EOF

    # Verify configuration file was created successfully
    if [[ -f "$config_file" && -s "$config_file" ]]; then
        log "INFO" "Generated advanced frps configuration with full protocol support: $config_file"
        if [[ -n "$dashboard_port" ]]; then
            log "INFO" "Dashboard: http://server-ip:$dashboard_port (User: $dashboard_user, Pass: $dashboard_password)"
        fi
        log "INFO" "Token: $token"
        log "INFO" "Main Port: $bind_port (TCP/FRP Protocol)"
        log "INFO" "HTTP Port: 80, HTTPS Port: 443"
        log "INFO" "TCPMUX Port: 5002 (HTTP CONNECT multiplexing)"
        [[ "$enable_kcp" == "true" ]] && log "INFO" "KCP Port: $bind_port (UDP-based protocol)"
        [[ "$enable_quic" == "true" ]] && log "INFO" "QUIC Port: $((bind_port + 1)) (Modern encrypted UDP)"
        log "INFO" "Allowed ports: 1000-65535 (extended ranges)"
        log "WARN" "🔥 CRITICAL: Configure firewall to allow these ports:"
        log "WARN" "   • Main: $bind_port (TCP)"
        log "WARN" "   • HTTP/HTTPS: 80, 443 (TCP)"
        log "WARN" "   • TCPMUX: 5002 (TCP)"
        [[ "$enable_kcp" == "true" ]] && log "WARN" "   • KCP: $bind_port (UDP)"
        [[ "$enable_quic" == "true" ]] && log "WARN" "   • QUIC: $((bind_port + 1)) (UDP)"
        log "WARN" "   • Client ports: 1000-65535 (TCP/UDP)"
        return 0
    else
        log "ERROR" "Configuration file was not created or is empty"
        return 1
    fi
}

# Generate frpc.toml configuration for multiple IPs and proxy types
generate_frpc_config() {
    local server_ip="$1"
    local server_port="$2"
    local token="$3"
    local client_ips="$4"
    local ports="$5"
    local ip_suffix="$6"
    local proxy_type="${7:-tcp}"  # Default to TCP if not specified
    local custom_domains="${8:-}" # For HTTP/HTTPS proxies
    local transport_protocol="${9:-tcp}" # Transport protocol: tcp/kcp/quic/websocket/wss

    local config_file="$CONFIG_DIR/frpc_${ip_suffix}.toml"
    local timestamp=$(date +%s)

    # Create complete and advanced client configuration based on official FRP v0.65.0 format
    cat > "$config_file" << EOF
# MoonFRP Client Configuration for IP ending with $ip_suffix
# Generated on $(date)
# Compatible with FRP v0.65.0

serverAddr = "$server_ip"
serverPort = $server_port

auth.method = "token"
auth.token = "$token"

log.to = "$LOG_DIR/frpc_${ip_suffix}.log"
log.level = "warn"
log.maxDays = 2
log.disablePrintColor = false

transport.poolCount = 10
transport.protocol = "$transport_protocol"
transport.heartbeatTimeout = 90
transport.heartbeatInterval = 5
transport.dialServerTimeout = 5
transport.dialServerKeepalive = 300
transport.tcpMux = true
transport.tcpMuxKeepaliveInterval = 5

transport.tls.enable = false

loginFailExit = true

user = "moonfrp_${ip_suffix}_${timestamp}"

udpPacketSize = 1500

EOF

    # Add feature gates for advanced features
    local needs_feature_gates=false
    case "$proxy_type" in
        "plugin_virtual_net")
            needs_feature_gates=true
            ;;
    esac

    if [[ "$needs_feature_gates" == "true" ]]; then
        cat >> "$config_file" << EOF
# Feature gates for experimental features
featureGates = { VirtualNet = true }

# Virtual network address configuration
virtualNet.address = "100.86.1.1/24"

EOF
    fi

    # Add protocol-specific settings
    case "$transport_protocol" in
        "kcp")
            cat >> "$config_file" << EOF
# KCP Protocol specific settings
# Note: Server must have KCP enabled (kcpBindPort configured)
# KCP provides better performance over poor network conditions

EOF
            ;;
        "quic")
            cat >> "$config_file" << EOF
# QUIC Protocol specific settings
# Note: Server must have QUIC enabled (quicBindPort configured)
transport.quic.keepalivePeriod = 10
transport.quic.maxIdleTimeout = 30
transport.quic.maxIncomingStreams = 100

EOF
            ;;
        "websocket")
            cat >> "$config_file" << EOF
# WebSocket Protocol specific settings
# Useful for bypassing firewalls that block other protocols

EOF
            ;;
        "wss")
            cat >> "$config_file" << EOF
# WebSocket Secure (WSS) Protocol specific settings
# Encrypted WebSocket over TLS

EOF
            ;;
    esac

    # Bandwidth management flag (will be passed from caller)
    local enable_bandwidth="${9:-false}"

    # Add proxy configurations based on type using unified generator
    case "$proxy_type" in
        "tcp")
            generate_proxy_config "tcp" "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "http")
            generate_proxy_config "http" "$config_file" "$ports" "$ip_suffix" "$timestamp" "$custom_domains" "false"
            ;;
        "https")
            generate_proxy_config "http" "$config_file" "$ports" "$ip_suffix" "$timestamp" "$custom_domains" "true"
            ;;
        "udp")
            generate_proxy_config "udp" "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "tcpmux")
            generate_proxy_config "tcpmux" "$config_file" "$ports" "$ip_suffix" "$timestamp" "$custom_domains"
            ;;
        "stcp")
            generate_proxy_config "stcp" "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "sudp")
            generate_proxy_config "sudp" "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "tcpmux-direct")
            generate_proxy_config "tcpmux" "$config_file" "$ports" "$ip_suffix" "$timestamp" "$custom_domains"
            ;;
        "xtcp")
            generate_proxy_config "xtcp" "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "plugin_"*)
            generate_proxy_config "plugin" "$config_file" "$ports" "$ip_suffix" "$timestamp" "" "" "$proxy_type"
            ;;
        *)
            log "WARN" "Unknown proxy type: $proxy_type, defaulting to TCP"
            generate_proxy_config "tcp" "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
    esac

    # Generate visitor configuration for STCP/XTCP proxies
    if [[ "$proxy_type" == "stcp" || "$proxy_type" == "xtcp" ]]; then
        local secret_key="moonfrp-${proxy_type}-${ip_suffix}-${timestamp}"
        local visitor_config=$(generate_visitor_config "$server_ip" "$server_port" "$token" "$config_file" "$secret_key" "$proxy_type" "$ports" "$ip_suffix" "$transport_protocol")
        log "INFO" "Generated visitor configuration: $visitor_config"
    fi

    # Verify configuration was created successfully
    if [[ -f "$config_file" && -s "$config_file" ]]; then
        log "INFO" "Generated frpc configuration: $config_file (Type: $proxy_type)"
        return 0
    else
        log "ERROR" "Failed to generate configuration file or file is empty: $config_file"
        return 1
    fi
}

# Global bandwidth configuration (set during initial setup)
GLOBAL_BANDWIDTH_PROFILE=""
GLOBAL_BANDWIDTH_IN=""
GLOBAL_BANDWIDTH_OUT=""

# Global transport protocol configuration
GLOBAL_TRANSPORT_PROTOCOL="tcp"

# Configure transport protocol globally
configure_transport_protocol() {
    echo -e "\n${CYAN}🚀 Transport Protocol Selection:${NC}"
    echo -e "${YELLOW}Choose the transport protocol for client connections${NC}"
    echo "1. TCP (Default) - Standard reliable connection"
    echo "2. KCP - UDP-based, better for poor networks"
    echo "3. QUIC - Modern encrypted UDP, low latency"
    echo "4. WebSocket - HTTP-based, firewall-friendly"
    echo "5. WSS - Secure WebSocket over TLS"

    read -p "Select transport protocol [1-5] (default: 1): " protocol_choice
    [[ -z "$protocol_choice" ]] && protocol_choice=1

    case $protocol_choice in
        1)
            GLOBAL_TRANSPORT_PROTOCOL="tcp"
            log "INFO" "Selected TCP protocol (reliable, standard)"
            ;;
        2)
            GLOBAL_TRANSPORT_PROTOCOL="kcp"
            log "INFO" "Selected KCP protocol (UDP-based, better for poor networks)"
            log "WARN" "⚠️  Server must have KCP enabled (kcpBindPort configured)"
            ;;
        3)
            GLOBAL_TRANSPORT_PROTOCOL="quic"
            log "INFO" "Selected QUIC protocol (modern encrypted UDP)"
            log "WARN" "⚠️  Server must have QUIC enabled (quicBindPort configured)"
            ;;
        4)
            GLOBAL_TRANSPORT_PROTOCOL="websocket"
            log "INFO" "Selected WebSocket protocol (HTTP-based, firewall-friendly)"
            ;;
        5)
            GLOBAL_TRANSPORT_PROTOCOL="wss"
            log "INFO" "Selected WSS protocol (secure WebSocket over TLS)"
            ;;
        *)
            log "WARN" "Invalid choice, using TCP (default)"
            GLOBAL_TRANSPORT_PROTOCOL="tcp"
            ;;
    esac

    echo -e "\n${GREEN}✅ Transport protocol configured: $GLOBAL_TRANSPORT_PROTOCOL${NC}"

    # Show protocol-specific warnings
    case $GLOBAL_TRANSPORT_PROTOCOL in
        "kcp"|"quic")
            echo -e "${YELLOW}📝 Note: Make sure the server has $GLOBAL_TRANSPORT_PROTOCOL protocol enabled${NC}"
            ;;
        "websocket"|"wss")
            echo -e "${YELLOW}📝 Note: WebSocket protocols are useful for bypassing restrictive firewalls${NC}"
            ;;
    esac
}

# Configure bandwidth limits globally
configure_global_bandwidth() {
    echo -e "\n${CYAN}🚀 Bandwidth Management (Optional):${NC}"
    echo -e "${YELLOW}Configure bandwidth limits for better performance control${NC}"
    echo "1. No limits (Default)"
    echo "2. Light usage (1MB/s in, 500KB/s out)"
    echo "3. Medium usage (5MB/s in, 2MB/s out)"
    echo "4. Heavy usage (10MB/s in, 5MB/s out)"
    echo "5. Custom limits"

    read -p "Select bandwidth profile [1-5] (default: 1): " bw_choice
    [[ -z "$bw_choice" ]] && bw_choice=1

    case $bw_choice in
        1)
            GLOBAL_BANDWIDTH_PROFILE="none"
            ;;
        2)
            GLOBAL_BANDWIDTH_PROFILE="light"
            GLOBAL_BANDWIDTH_IN="1MB"
            GLOBAL_BANDWIDTH_OUT="500KB"
            ;;
        3)
            GLOBAL_BANDWIDTH_PROFILE="medium"
            GLOBAL_BANDWIDTH_IN="5MB"
            GLOBAL_BANDWIDTH_OUT="2MB"
            ;;
        4)
            GLOBAL_BANDWIDTH_PROFILE="heavy"
            GLOBAL_BANDWIDTH_IN="10MB"
            GLOBAL_BANDWIDTH_OUT="5MB"
            ;;
        5)
            GLOBAL_BANDWIDTH_PROFILE="custom"
            echo -e "\n${CYAN}Custom Bandwidth Configuration:${NC}"
            read -p "Incoming bandwidth limit (e.g., 2MB, 500KB): " GLOBAL_BANDWIDTH_IN
            read -p "Outgoing bandwidth limit (e.g., 1MB, 200KB): " GLOBAL_BANDWIDTH_OUT

            if [[ -z "$GLOBAL_BANDWIDTH_IN" || -z "$GLOBAL_BANDWIDTH_OUT" ]]; then
                log "WARN" "Invalid bandwidth values, using no limits"
                GLOBAL_BANDWIDTH_PROFILE="none"
            fi
            ;;
        *)
            log "WARN" "Invalid choice, using no limits"
            GLOBAL_BANDWIDTH_PROFILE="none"
            ;;
    esac

    if [[ "$GLOBAL_BANDWIDTH_PROFILE" != "none" ]]; then
        log "INFO" "Bandwidth profile selected: $GLOBAL_BANDWIDTH_PROFILE"
        [[ -n "$GLOBAL_BANDWIDTH_IN" ]] && log "INFO" "Incoming limit: $GLOBAL_BANDWIDTH_IN"
        [[ -n "$GLOBAL_BANDWIDTH_OUT" ]] && log "INFO" "Outgoing limit: $GLOBAL_BANDWIDTH_OUT"
    fi
}

# Apply bandwidth limits to proxy configuration
apply_bandwidth_limits() {
    local config_file="$1"
    local proxy_name="$2"

    if [[ "$GLOBAL_BANDWIDTH_PROFILE" == "none" ]]; then
        return 0
    fi

    # Add bandwidth limiting configuration
    cat >> "$config_file" << EOF
# Bandwidth limits for $proxy_name (Profile: $GLOBAL_BANDWIDTH_PROFILE)
transport.bandwidthLimit = "$GLOBAL_BANDWIDTH_IN"
transport.bandwidthLimitMode = "client"

EOF

    log "INFO" "Applied bandwidth limits to $proxy_name: $GLOBAL_BANDWIDTH_IN"
}

#==============================================================================
# UNIFIED PROXY CONFIGURATION GENERATOR
#==============================================================================

# Unified proxy configuration generator
generate_proxy_config() {
    local type="$1"        # tcp|http|udp|tcpmux|stcp|sudp|xtcp|plugin
    local config_file="$2"
    local ports="$3"
    local ip_suffix="$4"
    local timestamp="$5"
    local custom_domains="${6:-}"
    local enable_https="${7:-false}"
    local additional_params="${8:-}"

    # Validate inputs
    if [[ -z "$type" || -z "$config_file" || -z "$ports" || -z "$ip_suffix" || -z "$timestamp" ]]; then
        log "ERROR" "Missing required parameters for proxy configuration"
        return 1
    fi

    # Parse ports
    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    
    # Parse domains if provided
    local DOMAIN_ARRAY=()
    if [[ -n "$custom_domains" ]]; then
        IFS=',' read -ra DOMAIN_ARRAY <<< "$custom_domains"
    fi

    # Generate proxy configurations based on type
    case "$type" in
        "tcp")
            generate_tcp_proxies_unified "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "http")
            generate_http_proxies_unified "$config_file" "$ports" "$ip_suffix" "$timestamp" "$custom_domains" "$enable_https"
            ;;
        "udp")
            generate_udp_proxies_unified "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "tcpmux")
            generate_tcpmux_proxies_unified "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "stcp")
            generate_stcp_proxies_unified "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "sudp")
            generate_sudp_proxies_unified "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "xtcp")
            generate_xtcp_proxies_unified "$config_file" "$ports" "$ip_suffix" "$timestamp"
            ;;
        "plugin")
            generate_plugin_proxies_unified "$config_file" "$ports" "$ip_suffix" "$timestamp" "$additional_params"
            ;;
        *)
            log "ERROR" "Unknown proxy type: $type"
            echo -e "${CYAN}Available types:${NC} tcp, http, udp, tcpmux, stcp, sudp, xtcp, plugin"
            return 1
            ;;
    esac
}

# TCP proxy generator (unified)
generate_tcp_proxies_unified() {
    local config_file="$1"
    local ports="$2"
    local ip_suffix="$3"
    local timestamp="$4"

    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        local unique_name="tcp-${port}-${ip_suffix}"
        cat >> "$config_file" << EOF
[[proxies]]
name = "$unique_name"
type = "tcp"
localIP = "127.0.0.1"
localPort = $port
remotePort = $port

# Health check configuration
healthCheck.type = "tcp"
healthCheck.timeoutSeconds = 5
healthCheck.maxFailed = 3
healthCheck.intervalSeconds = 30

# Load balancing configuration
loadBalancer.group = "moonfrp_group_${port}"
loadBalancer.groupKey = "moonfrp_${port}_static"

# Metadata for monitoring
metadatas.port = "$port"
metadatas.type = "tcp"
metadatas.created = "$timestamp"
metadatas.ip_suffix = "$ip_suffix"

EOF
    done
}

# HTTP proxy generator (unified)
generate_http_proxies_unified() {
    local config_file="$1"
    local ports="$2"
    local ip_suffix="$3"
    local timestamp="$4"
    local custom_domains="$5"
    local enable_https="$6"

    local proxy_type="http"
    [[ "$enable_https" == "true" ]] && proxy_type="https"

    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    IFS=',' read -ra DOMAIN_ARRAY <<< "$custom_domains"

    local port_index=0
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        local unique_name="${proxy_type}-${port}-${ip_suffix}"
        local domain=""

        # Use corresponding domain if available, otherwise generate default
        if [[ $port_index -lt ${#DOMAIN_ARRAY[@]} ]] && [[ -n "${DOMAIN_ARRAY[$port_index]}" ]]; then
            domain="${DOMAIN_ARRAY[$port_index]}"
            domain=$(echo "$domain" | tr -d ' ')
        else
            domain="app${port}.moonfrp.local"
        fi

        cat >> "$config_file" << EOF
[[proxies]]
name = "$unique_name"
type = "$proxy_type"
localIP = "127.0.0.1"
localPort = $port
customDomains = ["$domain"]

# Health check configuration
healthCheck.type = "$proxy_type"
healthCheck.path = "/health"
healthCheck.timeoutSeconds = 5
healthCheck.maxFailed = 3
healthCheck.intervalSeconds = 30

# Load balancing configuration
loadBalancer.group = "moonfrp_group_${port}"
loadBalancer.groupKey = "moonfrp_${port}_static"

# Metadata for monitoring
metadatas.port = "$port"
metadatas.type = "$proxy_type"
metadatas.domain = "$domain"
metadatas.created = "$timestamp"
metadatas.ip_suffix = "$ip_suffix"

EOF
        ((port_index++))
    done
}

# UDP proxy generator (unified)
generate_udp_proxies_unified() {
    local config_file="$1"
    local ports="$2"
    local ip_suffix="$3"
    local timestamp="$4"

    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        local unique_name="udp-${port}-${ip_suffix}"
        cat >> "$config_file" << EOF
[[proxies]]
name = "$unique_name"
type = "udp"
localIP = "127.0.0.1"
localPort = $port
remotePort = $port

# Metadata for monitoring
metadatas.port = "$port"
metadatas.type = "udp"
metadatas.created = "$timestamp"
metadatas.ip_suffix = "$ip_suffix"

EOF
    done
}

# TCPMUX proxy generator (unified)
generate_tcpmux_proxies_unified() {
    local config_file="$1"
    local ports="$2"
    local ip_suffix="$3"
    local timestamp="$4"

    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        local unique_name="tcpmux-${port}-${ip_suffix}"
        cat >> "$config_file" << EOF
[[proxies]]
name = "$unique_name"
type = "tcpmux"
multiplexer = "httpconnect"
localIP = "127.0.0.1"
localPort = $port
customDomains = ["app${port}.moonfrp.local"]

# Metadata for monitoring
metadatas.port = "$port"
metadatas.type = "tcpmux"
metadatas.created = "$timestamp"
metadatas.ip_suffix = "$ip_suffix"

EOF
    done
}

# STCP proxy generator (unified)
generate_stcp_proxies_unified() {
    local config_file="$1"
    local ports="$2"
    local ip_suffix="$3"
    local timestamp="$4"

    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        local unique_name="stcp-${port}-${ip_suffix}"
        cat >> "$config_file" << EOF
[[proxies]]
name = "$unique_name"
type = "stcp"
secretKey = "moonfrp_secret_${port}_${ip_suffix}"
localIP = "127.0.0.1"
localPort = $port

# Metadata for monitoring
metadatas.port = "$port"
metadatas.type = "stcp"
metadatas.created = "$timestamp"
metadatas.ip_suffix = "$ip_suffix"

EOF
    done
}

# SUDP proxy generator (unified)
generate_sudp_proxies_unified() {
    local config_file="$1"
    local ports="$2"
    local ip_suffix="$3"
    local timestamp="$4"

    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        local unique_name="sudp-${port}-${ip_suffix}"
        cat >> "$config_file" << EOF
[[proxies]]
name = "$unique_name"
type = "sudp"
secretKey = "moonfrp_secret_${port}_${ip_suffix}"
localIP = "127.0.0.1"
localPort = $port

# Metadata for monitoring
metadatas.port = "$port"
metadatas.type = "sudp"
metadatas.created = "$timestamp"
metadatas.ip_suffix = "$ip_suffix"

EOF
    done
}

# XTCP proxy generator (unified)
generate_xtcp_proxies_unified() {
    local config_file="$1"
    local ports="$2"
    local ip_suffix="$3"
    local timestamp="$4"

    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        local unique_name="xtcp-${port}-${ip_suffix}"
        cat >> "$config_file" << EOF
[[proxies]]
name = "$unique_name"
type = "xtcp"
secretKey = "moonfrp_secret_${port}_${ip_suffix}"
localIP = "127.0.0.1"
localPort = $port

# Metadata for monitoring
metadatas.port = "$port"
metadatas.type = "xtcp"
metadatas.created = "$timestamp"
metadatas.ip_suffix = "$ip_suffix"

EOF
    done
}

# Plugin proxy generator (unified)
generate_plugin_proxies_unified() {
    local config_file="$1"
    local ports="$2"
    local ip_suffix="$3"
    local timestamp="$4"
    local plugin_type="${5:-unix_domain_socket}"

    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        local unique_name="plugin-${port}-${ip_suffix}"
        cat >> "$config_file" << EOF
[[proxies]]
name = "$unique_name"
type = "plugin"
plugin = "$plugin_type"
pluginLocalAddr = "127.0.0.1:$port"

# Metadata for monitoring
metadatas.port = "$port"
metadatas.type = "plugin"
metadatas.plugin_type = "$plugin_type"
metadatas.created = "$timestamp"
metadatas.ip_suffix = "$ip_suffix"

EOF
    done
}

# Legacy function removed - replaced by generate_proxy_config()


# Generate visitor configuration for STCP/XTCP proxies
generate_visitor_config() {
    local server_ip="$1"
    local server_port="$2"
    local token="$3"
    local config_file="$4"
    local secret_key="$5"
    local proxy_type="$6"  # stcp or xtcp
    local ports="$7"
    local ip_suffix="$8"
    local transport_protocol="${9:-tcp}"  # Transport protocol

    local visitor_config_file="$CONFIG_DIR/frpc_visitor_${ip_suffix}.toml"

    # Create visitor configuration
    cat > "$visitor_config_file" << EOF
# MoonFRP Visitor Configuration for IP ending with $ip_suffix
# Generated on $(date)
# This configuration allows you to connect to ${proxy_type^^} proxies

serverAddr = "$server_ip"
serverPort = $server_port

auth.method = "token"
auth.token = "$token"

loginFailExit = true

log.to = "$LOG_DIR/frpc_visitor_${ip_suffix}.log"
log.level = "warn"
log.maxDays = 2
log.disablePrintColor = false

transport.poolCount = 10
transport.protocol = "$transport_protocol"
transport.heartbeatTimeout = 90
transport.heartbeatInterval = 5
transport.dialServerTimeout = 5
transport.dialServerKeepalive = 300
transport.tcpMux = true
transport.tcpMuxKeepaliveInterval = 5

transport.tls.force = false

user = "moonfrp_${ip_suffix}_$(date +%s)"

udpPacketSize = 1500

EOF

    # Add protocol-specific settings for visitor
    case "$transport_protocol" in
        "kcp")
            cat >> "$visitor_config_file" << EOF
EOF
            ;;
        "quic")
            cat >> "$visitor_config_file" << EOF
EOF
            ;;
        "websocket")
            cat >> "$visitor_config_file" << EOF
EOF
            ;;
        "wss")
            cat >> "$visitor_config_file" << EOF
EOF
            ;;
    esac

    # Generate visitor configurations for each port
    IFS=',' read -ra PORT_ARRAY <<< "$ports"
    local visitor_port=8000

    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')
        local server_name="${proxy_type}-${port}-${ip_suffix}"
        local visitor_name="${proxy_type}_visitor_${port}_${ip_suffix}"

        # Use port-specific bind ports to avoid conflicts
        local bind_port
        case "$port" in
            "2096") bind_port=8096 ;;  # X-UI
            "9005") bind_port=8005 ;;  # Xray
            "22")   bind_port=8022 ;;  # SSH
            "3389") bind_port=8389 ;;  # RDP
            "5900") bind_port=8900 ;;  # VNC
            *) bind_port=$((8000 + (port % 1000))) ;;  # Dynamic assignment
        esac

        cat >> "$visitor_config_file" << EOF
[[visitors]]
name = "$visitor_name"
type = "$proxy_type"
serverName = "$server_name"
secretKey = "$secret_key"
bindAddr = "127.0.0.1"
bindPort = $bind_port
EOF

        # Add XTCP-specific options
        if [[ "$proxy_type" == "xtcp" ]]; then
            cat >> "$visitor_config_file" << EOF
keepTunnelOpen = true
maxRetriesAnHour = 8
minRetryInterval = 90
fallbackTo = "stcp_${server_name}"
fallbackTimeoutMs = 1000
EOF
        fi

        # Add STCP-specific options
        if [[ "$proxy_type" == "stcp" ]]; then
            cat >> "$visitor_config_file" << EOF
# STCP options - Secure tunneling settings
# Optional: Enable specific user connections only
# serverUser = "specific_user"
EOF
        fi

        cat >> "$visitor_config_file" << EOF

EOF
    done

    # Add usage instructions
    cat >> "$visitor_config_file" << EOF
# ${proxy_type^^} Visitor Configuration Instructions:
#
# This configuration file allows you to connect to ${proxy_type^^} proxies running on another machine.
#
# 🚀 How to use:
# 1. Install FRP client on the machine where you want to access the services
# 2. Copy this configuration file to the client machine
# 3. Run: frpc -c $visitor_config_file
# 4. Access services via the local bind ports listed above
#
# 📋 Service Access:
EOF

    # Add service access information
    for port in "${PORT_ARRAY[@]}"; do
        port=$(echo "$port" | tr -d ' ')

        # Use same port mapping logic as above
        local bind_port
        case "$port" in
            "2096") bind_port=8096 ;;  # X-UI
            "9005") bind_port=8005 ;;  # Xray
            "22")   bind_port=8022 ;;  # SSH
            "3389") bind_port=8389 ;;  # RDP
            "5900") bind_port=8900 ;;  # VNC
            *) bind_port=$((8000 + (port % 1000))) ;;  # Dynamic assignment
        esac

        cat >> "$visitor_config_file" << EOF
# • Access service on port $port via: localhost:$bind_port
EOF
    done

    cat >> "$visitor_config_file" << EOF
#
# 🔧 Examples:
EOF

    case "$proxy_type" in
        "stcp")
            cat >> "$visitor_config_file" << EOF
# • SSH: ssh -p 8022 user@localhost (if port 22 is configured)
# • HTTP: curl http://localhost:8096 (if port 2096 is configured)
# • X-UI Panel: http://localhost:8096 (access X-UI on port 2096)
# • Database: connect to localhost:BIND_PORT instead of remote host
EOF
            ;;
        "xtcp")
            cat >> "$visitor_config_file" << EOF
# • SSH: ssh -p 8022 user@localhost (P2P direct connection)
# • HTTP: curl http://localhost:8096 (P2P direct connection)
# • X-UI Panel: http://localhost:8096 (direct P2P access to X-UI)
# • Gaming: connect to localhost:BIND_PORT (low latency P2P)
# • Note: XTCP provides direct P2P connection when possible
EOF
            ;;
    esac

    cat >> "$visitor_config_file" << EOF
#
# 🔍 Troubleshooting:
# • Check logs: tail -f $LOG_DIR/frpc_visitor_${ip_suffix}.log
# • Verify server is running and accessible
# • Ensure secret key matches between server and visitor
# • For XTCP: Check NAT traversal capability
EOF

    echo "$visitor_config_file"
}

#==============================================================================
# SECTION 5: SERVICE MANAGEMENT
#==============================================================================

# Create systemd service file
create_systemd_service() {
    local service_name="$1"
    local service_type="$2"  # frps or frpc
    local config_file="$3"
    local ip_suffix="${4:-}"

    # Validate inputs
    if [[ -z "$service_name" || -z "$service_type" || -z "$config_file" ]]; then
        log "ERROR" "Missing required parameters for service creation"
        return 1
    fi

    # Check if FRP binary exists
    if [[ ! -f "$FRP_DIR/$service_type" ]]; then
        log "ERROR" "FRP binary not found: $FRP_DIR/$service_type"
        log "ERROR" "Please install FRP first using menu option 3"
        return 1
    fi

    # Check if config file exists
    if [[ ! -f "$config_file" ]]; then
        log "ERROR" "Configuration file not found: $config_file"
        return 1
    fi

    local service_file="$SERVICE_DIR/${service_name}.service"
    local description="MoonFRP ${service_type^^} Service"

    if [[ -n "$ip_suffix" ]]; then
        description="$description (IP suffix: $ip_suffix)"
    fi

    # Create service file
    if cat > "$service_file" << EOF
[Unit]
Description=$description
After=network.target
Wants=network.target

[Service]
Type=simple
User=root
Group=root
ExecStart=$FRP_DIR/$service_type -c $config_file
ExecReload=/bin/kill -HUP \$MAINPID
KillMode=mixed
Restart=always
RestartSec=5
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF
    then
        # Reload systemd daemon
        if systemctl daemon-reload; then
            # Clear all performance caches
            clear_performance_caches
            log "INFO" "Created systemd service: $service_name"
            return 0
        else
            log "ERROR" "Failed to reload systemd daemon"
            return 1
        fi
    else
        log "ERROR" "Failed to create service file: $service_file"
        return 1
    fi
}

# Clear all performance caches
clear_performance_caches() {
    CACHE_DATA["services"]=""
    CACHE_DATA["services_time"]="0"
    log "DEBUG" "Performance caches cleared"
}

# Service management functions
start_service() {
    local service_name="$1"

    if [[ -z "$service_name" ]]; then
        log "ERROR" "Service name is required"
        return 1
    fi

    # Check if service file exists
    if [[ ! -f "$SERVICE_DIR/${service_name}.service" ]]; then
        log "ERROR" "Service file not found: $SERVICE_DIR/${service_name}.service"
        return 1
    fi

    # Start service
    if systemctl start "$service_name"; then
        log "INFO" "Started service: $service_name"

        # Clear caches after service change
        clear_performance_caches

        # Enable service
        if systemctl enable "$service_name"; then
            log "INFO" "Enabled service: $service_name"
            return 0
        else
            log "WARN" "Service started but failed to enable: $service_name"
            return 0  # Still consider this success as service is running
        fi
    else
        log "ERROR" "Failed to start service: $service_name"
        return 1
    fi
}

stop_service() {
    local service_name="$1"
    systemctl stop "$service_name" 2>/dev/null || true
    systemctl disable "$service_name" 2>/dev/null || true
    # Clear caches after service change
    clear_performance_caches
    log "INFO" "Stopped and disabled service: $service_name"
}

restart_service() {
    local service_name="$1"
    systemctl restart "$service_name"
    # Clear caches after service change
    clear_performance_caches
    log "INFO" "Restarted service: $service_name"
}

# Improved service status with caching
declare -A SERVICE_STATUS_CACHE
SERVICE_STATUS_CACHE_TIME=0

get_service_status() {
    local service_name="$1"
    local current_time=$(date +%s)

    # Use cached status if available and not expired (5 seconds)
    if [[ -n "${SERVICE_STATUS_CACHE[$service_name]}" ]] && [[ $((current_time - SERVICE_STATUS_CACHE_TIME)) -lt 5 ]]; then
        echo "${SERVICE_STATUS_CACHE[$service_name]}"
        return
    fi

    # Get fresh status and cache it
    local status=$(systemctl is-active "$service_name" 2>/dev/null || echo "inactive")
    SERVICE_STATUS_CACHE[$service_name]="$status"
    SERVICE_STATUS_CACHE_TIME=$current_time

    echo "$status"
}

# Enhanced service management with conflict prevention
manage_service_safely() {
    local action="$1"
    local service_name="$2"

    case "$action" in
        "start")
            # Check for port conflicts before starting
            local config_file=""
            if [[ "$service_name" =~ moonfrps.*server ]]; then
                # Find server config file
                config_file=$(find "$CONFIG_DIR" -name "frps*.toml" -exec grep -l "$service_name\|server" {} \; | head -1)
            elif [[ "$service_name" =~ moonfrpc.*client ]]; then
                # Extract IP suffix from service name
                local ip_suffix=$(echo "$service_name" | grep -o 'client-[0-9]\+' | cut -d'-' -f2)
                if [[ -n "$ip_suffix" ]]; then
                    config_file="$CONFIG_DIR/frpc_${ip_suffix}.toml"
                fi
            fi

            if [[ -n "$config_file" && -f "$config_file" ]]; then
                # Validate config before starting
                if validate_frp_config "$config_file"; then
                    systemctl start "$service_name" && return 0 || return 1
                else
                    log "ERROR" "Configuration validation failed for $service_name"
                    return 1
                fi
            else
                # Start without validation if config not found
                systemctl start "$service_name" && return 0 || return 1
            fi
            ;;
        "stop")
            systemctl stop "$service_name" && return 0 || return 1
            ;;
        "restart")
            systemctl restart "$service_name" && return 0 || return 1
            ;;
        *)
            log "ERROR" "Unknown action: $action"
            return 1
            ;;
    esac
}

#==============================================================================
# UNIFIED SERVICE MANAGEMENT FUNCTION
#==============================================================================

# Unified service management function
manage_service() {
    local action="$1"      # start|stop|restart|reload|status|enable|disable
    local service="$2"     # service name
    local options="$3"     # optional flags (e.g., "force", "validate")

    # Validate inputs
    if [[ -z "$action" || -z "$service" ]]; then
        log "ERROR" "Missing required parameters: action and service name"
        return 1
    fi

    # Check if service file exists
    if [[ ! -f "$SERVICE_DIR/${service}.service" ]]; then
        log "ERROR" "Service file not found: $SERVICE_DIR/${service}.service"
        return 1
    fi

    # Handle different actions
    case "$action" in
        "start")
            # Validate configuration before starting if requested
            if [[ "$options" == *"validate"* ]]; then
                local config_file=""
                if [[ "$service" =~ moonfrps.*server ]]; then
                    config_file=$(find "$CONFIG_DIR" -name "frps*.toml" -exec grep -l "$service\|server" {} \; | head -1)
                elif [[ "$service" =~ moonfrpc.*client ]]; then
                    local ip_suffix=$(echo "$service" | grep -o 'client-[0-9]\+' | cut -d'-' -f2)
                    if [[ -n "$ip_suffix" ]]; then
                        config_file="$CONFIG_DIR/frpc_${ip_suffix}.toml"
                    fi
                fi

                if [[ -n "$config_file" && -f "$config_file" ]]; then
                    if ! validate_frp_config "$config_file"; then
                        log "ERROR" "Configuration validation failed for $service"
                        return 1
                    fi
                fi
            fi

            # Start service
            if systemctl start "$service"; then
                log "INFO" "Started service: $service"
                
                # Enable service
                if systemctl enable "$service"; then
                    log "INFO" "Enabled service: $service"
                else
                    log "WARN" "Service started but failed to enable: $service"
                fi
                
                clear_performance_caches
                return 0
            else
                log "ERROR" "Failed to start service: $service"
                return 1
            fi
            ;;
            
        "stop")
            if systemctl stop "$service"; then
                log "INFO" "Stopped service: $service"
                
                # Disable service
                if systemctl disable "$service"; then
                    log "INFO" "Disabled service: $service"
                else
                    log "WARN" "Service stopped but failed to disable: $service"
                fi
                
                clear_performance_caches
                return 0
            else
                log "ERROR" "Failed to stop service: $service"
                return 1
            fi
            ;;
            
        "restart")
            if systemctl restart "$service"; then
                log "INFO" "Restarted service: $service"
                clear_performance_caches
                return 0
            else
                log "ERROR" "Failed to restart service: $service"
                return 1
            fi
            ;;
            
        "reload")
            if systemctl reload "$service"; then
                log "INFO" "Reloaded service: $service"
                return 0
            else
                log "ERROR" "Failed to reload service: $service"
                return 1
            fi
            ;;
            
        "status")
            local status=$(systemctl is-active "$service" 2>/dev/null || echo "inactive")
            local enabled=$(systemctl is-enabled "$service" 2>/dev/null || echo "disabled")
            
            echo -e "${CYAN}Service: ${YELLOW}$service${NC}"
            echo -e "  Status: $([ "$status" == "active" ] && echo "${GREEN}🟢 Active${NC}" || echo "${RED}🔴 Inactive${NC}")"
            echo -e "  Enabled: $([ "$enabled" == "enabled" ] && echo "${GREEN}✅ Enabled${NC}" || echo "${YELLOW}⚠️  Disabled${NC}")"
            
            # Show additional info if active
            if [[ "$status" == "active" ]]; then
                local uptime=$(systemctl show "$service" -p ActiveEnterTimestamp --value 2>/dev/null)
                if [[ -n "$uptime" ]]; then
                    local uptime_formatted=$(date -d "$uptime" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
                    echo -e "  Started: ${GREEN}$uptime_formatted${NC}"
                fi
                
                local memory_usage=$(systemctl show "$service" -p MemoryCurrent --value 2>/dev/null)
                if [[ -n "$memory_usage" && "$memory_usage" != "18446744073709551615" ]]; then
                    local memory_mb=$((memory_usage / 1024 / 1024))
                    echo -e "  Memory: ${YELLOW}${memory_mb}MB${NC}"
                fi
            fi
            
            return 0
            ;;
            
        "enable")
            if systemctl enable "$service"; then
                log "INFO" "Enabled service: $service"
                return 0
            else
                log "ERROR" "Failed to enable service: $service"
                return 1
            fi
            ;;
            
        "disable")
            if systemctl disable "$service"; then
                log "INFO" "Disabled service: $service"
                return 0
            else
                log "ERROR" "Failed to disable service: $service"
                return 1
            fi
            ;;
            
        *)
            log "ERROR" "Unknown action: $action"
            echo -e "${CYAN}Available actions:${NC} start, stop, restart, reload, status, enable, disable"
            return 1
            ;;
    esac
}

# Advanced cleanup function for resolving all conflicts
cleanup_all_frp_services() {
    local cleanup_type="${1:-all}"  # all, client, server

    echo -e "${YELLOW}🧹 Advanced FRP Cleanup${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    # Find all FRP-related services
    local all_frp_services=($(systemctl list-units --type=service --all --no-legend --plain 2>/dev/null | grep -E "(frp|moonfrp)" | awk '{print $1}' | sed 's/\.service//'))
    local all_frp_configs=($(ls "$CONFIG_DIR"/{frp*.toml,frpc_*.toml,frps_*.toml,frpc_visitor_*.toml} 2>/dev/null))
    local all_frp_logs=($(ls "$LOG_DIR"/{frp*.log,frpc_*.log,frps_*.log} 2>/dev/null))

    if [[ ${#all_frp_services[@]} -eq 0 && ${#all_frp_configs[@]} -eq 0 && ${#all_frp_logs[@]} -eq 0 ]]; then
        echo -e "${GREEN}✅ No FRP services or configurations found${NC}"
        return 0
    fi

    echo -e "\n${CYAN}📊 Found FRP Components:${NC}"
    [[ ${#all_frp_services[@]} -gt 0 ]] && echo -e "  Services: ${YELLOW}${#all_frp_services[@]}${NC}"
    [[ ${#all_frp_configs[@]} -gt 0 ]] && echo -e "  Configs: ${YELLOW}${#all_frp_configs[@]}${NC}"
    [[ ${#all_frp_logs[@]} -gt 0 ]] && echo -e "  Logs: ${YELLOW}${#all_frp_logs[@]}${NC}"

    echo -e "\n${RED}⚠️  WARNING: This will remove ALL FRP services and configurations!${NC}"
    echo -e "${YELLOW}Continue with cleanup? (y/N):${NC} "
    read -r confirm_cleanup

    if [[ ! "$confirm_cleanup" =~ ^[Yy]$ ]]; then
        echo -e "${GREEN}Cleanup cancelled${NC}"
        return 0
    fi

    echo -e "\n${CYAN}🛑 Stopping all FRP services...${NC}"
    local stopped_count=0
    for service in "${all_frp_services[@]}"; do
        if systemctl stop "$service" 2>/dev/null; then
            echo -e "  ${GREEN}✅ Stopped: $service${NC}"
            ((stopped_count++))
        else
            echo -e "  ${RED}❌ Failed to stop: $service${NC}"
        fi

        if systemctl disable "$service" 2>/dev/null; then
            echo -e "  ${GREEN}✅ Disabled: $service${NC}"
        fi
    done

    echo -e "\n${CYAN}🗑️  Removing service files...${NC}"
    local removed_services=0
    for service in "${all_frp_services[@]}"; do
        local service_file="/etc/systemd/system/${service}.service"
        if [[ -f "$service_file" ]] && rm -f "$service_file"; then
            echo -e "  ${GREEN}✅ Removed: $service_file${NC}"
            ((removed_services++))
        fi
    done

    echo -e "\n${CYAN}🗑️  Removing configuration files...${NC}"
    local removed_configs=0
    for config in "${all_frp_configs[@]}"; do
        if rm -f "$config"; then
            echo -e "  ${GREEN}✅ Removed: $(basename "$config")${NC}"
            ((removed_configs++))
        fi
    done

    echo -e "\n${CYAN}🗑️  Removing log files...${NC}"
    local removed_logs=0
    for log_file in "${all_frp_logs[@]}"; do
        if rm -f "$log_file"; then
            echo -e "  ${GREEN}✅ Removed: $(basename "$log_file")${NC}"
            ((removed_logs++))
        fi
    done

    # Reload systemd daemon
    echo -e "\n${CYAN}🔄 Reloading systemd daemon...${NC}"
    systemctl daemon-reload

    # Clear caches
    clear_performance_caches

    echo -e "\n${GREEN}✅ Cleanup completed successfully!${NC}"
    echo -e "${CYAN}📊 Summary:${NC}"
    echo -e "  Services stopped: ${GREEN}$stopped_count${NC}"
    echo -e "  Service files removed: ${GREEN}$removed_services${NC}"
    echo -e "  Config files removed: ${GREEN}$removed_configs${NC}"
    echo -e "  Log files removed: ${GREEN}$removed_logs${NC}"

    return 0
}

# Check if FRP is already installed
check_frp_installation() {
    if [[ -f "$FRP_DIR/frps" ]] && [[ -f "$FRP_DIR/frpc" ]]; then
        return 0  # Already installed
    else
        return 1  # Not installed
    fi
}

# Download and install FRP
download_and_install_frp() {
    # Check if already installed
    if check_frp_installation; then
        echo -e "\n${YELLOW}FRP is already installed!${NC}"
        echo -e "${CYAN}Current installation:${NC}"
        echo -e "  frps: $FRP_DIR/frps"
        echo -e "  frpc: $FRP_DIR/frpc"
        echo -e "\n${YELLOW}Do you want to reinstall? (y/N):${NC} "
        read -r reinstall

        if [[ ! "$reinstall" =~ ^[Yy]$ ]]; then
            log "INFO" "Installation cancelled by user"
            return 0
        fi

        log "INFO" "Proceeding with reinstallation..."
    fi

    local download_url="https://github.com/fatedier/frp/releases/download/v${FRP_VERSION}/frp_${FRP_VERSION}_${FRP_ARCH}.tar.gz"
    local temp_file="$TEMP_DIR/frp_${FRP_VERSION}_${FRP_ARCH}.tar.gz"

    log "INFO" "Downloading FRP v$FRP_VERSION..."

    if ! curl -L -o "$temp_file" "$download_url"; then
        log "ERROR" "Failed to download FRP"
        return 1
    fi

    log "INFO" "Extracting FRP..."
    tar -xzf "$temp_file" -C "$TEMP_DIR"

    # Copy binaries
    cp "$TEMP_DIR/frp_${FRP_VERSION}_${FRP_ARCH}/frps" "$FRP_DIR/"
    cp "$TEMP_DIR/frp_${FRP_VERSION}_${FRP_ARCH}/frpc" "$FRP_DIR/"

    # Set permissions
    chmod +x "$FRP_DIR/frps" "$FRP_DIR/frpc"

    # Cleanup
    rm -rf "$TEMP_DIR/frp_${FRP_VERSION}_${FRP_ARCH}"
    rm -f "$temp_file"

    # Invalidate cache
    CACHE_DATA["frp_installation"]="installed"

    log "INFO" "FRP v$FRP_VERSION installed successfully"
}

# Install from local archive
install_from_local() {
    # Check if already installed
    if check_frp_installation; then
        echo -e "\n${YELLOW}FRP is already installed!${NC}"
        echo -e "${CYAN}Current installation:${NC}"
        echo -e "  frps: $FRP_DIR/frps"
        echo -e "  frpc: $FRP_DIR/frpc"
        echo -e "\n${YELLOW}Do you want to reinstall from local archive? (y/N):${NC} "
        read -r reinstall

        if [[ ! "$reinstall" =~ ^[Yy]$ ]]; then
            log "INFO" "Installation cancelled by user"
            return 0
        fi

        log "INFO" "Proceeding with reinstallation from local archive..."
    fi

    local archive_path="/root/frp_${FRP_VERSION}_${FRP_ARCH}.tar.gz"

    if [[ ! -f "$archive_path" ]]; then
        log "ERROR" "Local archive not found: $archive_path"
        return 1
    fi

    log "INFO" "Installing FRP from local archive..."

    tar -xzf "$archive_path" -C "$TEMP_DIR"

    # Copy binaries
    cp "$TEMP_DIR/frp_${FRP_VERSION}_${FRP_ARCH}/frps" "$FRP_DIR/"
    cp "$TEMP_DIR/frp_${FRP_VERSION}_${FRP_ARCH}/frpc" "$FRP_DIR/"

    # Set permissions
    chmod +x "$FRP_DIR/frps" "$FRP_DIR/frpc"

    # Cleanup
    rm -rf "$TEMP_DIR/frp_${FRP_VERSION}_${FRP_ARCH}"

    # Invalidate cache
    CACHE_DATA["frp_installation"]="installed"

    log "INFO" "FRP installed from local archive successfully"
}

# Check for MoonFRP updates
check_moonfrp_updates() {
    log "INFO" "Checking for MoonFRP updates..."

    # Since no releases are published, we'll check the script file directly
    # Download the latest script and compare versions
    local temp_script="/tmp/moonfrp_check_$(date +%s).sh"

    if curl -fsSL "$MOONFRP_SCRIPT_URL" -o "$temp_script" 2>/dev/null; then
        # Verify download
        if [[ -f "$temp_script" ]] && [[ -s "$temp_script" ]]; then
            # Extract version from downloaded script
            local remote_version=""
            if grep -q "MOONFRP_VERSION=" "$temp_script"; then
                remote_version=$(grep "MOONFRP_VERSION=" "$temp_script" | head -1 | cut -d'"' -f2)
            fi

            # Clean up temp file
            rm -f "$temp_script"

            if [[ -n "$remote_version" ]]; then
                log "INFO" "Current version: v$MOONFRP_VERSION"
                log "INFO" "Remote version: v$remote_version"

                # Compare versions
                if [[ "$remote_version" != "$MOONFRP_VERSION" ]]; then
                    return 0  # Update available
                else
                    return 1  # Already up to date
                fi
            else
                log "WARN" "Could not extract version from remote script"
                return 2  # Error parsing
            fi
        else
            log "WARN" "Downloaded file is empty or invalid"
            rm -f "$temp_script"
            return 3  # Download error
        fi
    else
        log "WARN" "Could not download script from repository"
        return 4  # Connection error
    fi
}

# Update MoonFRP script
update_moonfrp_script() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║         MoonFRP Updater              ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    echo -e "\n${CYAN}🔍 Checking for updates...${NC}"

    local update_status=0
    check_moonfrp_updates
    update_status=$?

    case $update_status in
        0)
            # Update available
            echo -e "\n${GREEN}🎉 New version available!${NC}"
            echo -e "${YELLOW}Do you want to update MoonFRP? (y/N):${NC} "
            read -r confirm_update

            if [[ "$confirm_update" =~ ^[Yy]$ ]]; then
                perform_moonfrp_update
            else
                log "INFO" "Update cancelled by user"
            fi
            ;;
        1)
            echo -e "\n${GREEN}✅ MoonFRP is already up to date!${NC}"
            echo -e "${CYAN}Current version: v$MOONFRP_VERSION${NC}"
            echo -e "\n${YELLOW}Force update anyway? (Y/n):${NC} "
            read -r force_update

            # Default to Y if user just presses Enter
            if [[ -z "$force_update" ]] || [[ "$force_update" =~ ^[Yy]$ ]]; then
                perform_moonfrp_update
            else
                log "INFO" "Update cancelled by user"
            fi
            ;;
        2)
            echo -e "\n${RED}❌ Error extracting version from remote script${NC}"
            echo -e "${YELLOW}The remote script may have a different format${NC}"
            echo -e "\n${YELLOW}Force update anyway? (y/N):${NC} "
            read -r force_update

            if [[ "$force_update" =~ ^[Yy]$ ]]; then
                perform_moonfrp_update
            fi
            ;;
        3)
            echo -e "\n${RED}❌ Downloaded file is empty or invalid${NC}"
            echo -e "${YELLOW}There may be an issue with the repository${NC}"
            echo -e "\n${YELLOW}Force update anyway? (y/N):${NC} "
            read -r force_update

            if [[ "$force_update" =~ ^[Yy]$ ]]; then
                perform_moonfrp_update
            fi
            ;;
        4)
            echo -e "\n${RED}❌ Cannot connect to GitHub repository${NC}"
            echo -e "${YELLOW}Please check your internet connection${NC}"
            echo -e "${YELLOW}Repository: https://github.com/k4lantar4/moonfrp${NC}"
            echo -e "\n${YELLOW}Force update anyway? (y/N):${NC} "
            read -r force_update

            if [[ "$force_update" =~ ^[Yy]$ ]]; then
                perform_moonfrp_update
            fi
            ;;
    esac

    read -p "Press Enter to continue..."
}

# Perform the actual update
perform_moonfrp_update() {
    log "INFO" "Starting MoonFRP update process..."

    # Check if current installation exists
    if [[ ! -f "$MOONFRP_INSTALL_PATH" ]]; then
        log "WARN" "Current installation not found at: $MOONFRP_INSTALL_PATH"
        log "INFO" "Proceeding with fresh installation..."
        MOONFRP_INSTALL_PATH="/usr/local/bin/moonfrp"
        # Create directory if it doesn't exist
        mkdir -p "$(dirname "$MOONFRP_INSTALL_PATH")"
    fi

    # Create backup directory
    local backup_dir="/tmp/moonfrp_backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"

    # Backup current script if it exists
    if [[ -f "$MOONFRP_INSTALL_PATH" ]]; then
        cp "$MOONFRP_INSTALL_PATH" "$backup_dir/moonfrp_old.sh"
        log "INFO" "Current script backed up to: $backup_dir/moonfrp_old.sh"
    fi

    # Download new version
    log "INFO" "Downloading latest MoonFRP script..."

    local temp_script="$TEMP_DIR/moonfrp_new.sh"

    if curl -fsSL "$MOONFRP_SCRIPT_URL" -o "$temp_script"; then
        # Verify download
        if [[ -f "$temp_script" ]] && [[ -s "$temp_script" ]]; then
            # Basic validation - check if it's a valid bash script
            if head -1 "$temp_script" | grep -q "#!/bin/bash"; then
                # Check if it contains MoonFRP signatures
                if grep -q "MoonFRP" "$temp_script" && grep -q "MOONFRP_VERSION" "$temp_script"; then
                    log "INFO" "Downloaded script validated successfully"

                    # Make executable
                    chmod +x "$temp_script"

                    # Replace current script
                    mv "$temp_script" "$MOONFRP_INSTALL_PATH"
                else
                    log "ERROR" "Downloaded file doesn't appear to be a valid MoonFRP script"
                    [[ -f "$temp_script" ]] && rm -f "$temp_script"
                    return 1
                fi
            else
                log "ERROR" "Downloaded file is not a valid bash script"
                [[ -f "$temp_script" ]] && rm -f "$temp_script"
                return 1
            fi

            # Update symlinks if they exist
            [[ -L "/usr/bin/moonfrp" ]] && ln -sf "$MOONFRP_INSTALL_PATH" "/usr/bin/moonfrp"

            echo -e "\n${GREEN}✅ MoonFRP updated successfully!${NC}"
            echo -e "${CYAN}Backup location: $backup_dir${NC}"

            # Try to get the new version from the updated script
            local new_version=""
            if new_version=$(grep '^MOONFRP_VERSION=' "$MOONFRP_INSTALL_PATH" 2>/dev/null | cut -d'"' -f2); then
                echo -e "${GREEN}Updated to version: v$new_version${NC}"
            fi

            echo -e "\n${YELLOW}Changes will take effect on next run${NC}"
            echo -e "${CYAN}Run 'moonfrp' to start the updated version${NC}"

            log "INFO" "MoonFRP update completed successfully"

            # Show option to restart
            echo -e "\n${YELLOW}Restart MoonFRP now with updated version? (y/N):${NC} "
            read -r restart_now

            if [[ "$restart_now" =~ ^[Yy]$ ]]; then
                echo -e "\n${GREEN}🚀 Restarting MoonFRP...${NC}"
                sleep 2
                exec "$MOONFRP_INSTALL_PATH"
            fi

        else
            log "ERROR" "Downloaded file is invalid or empty"
            [[ -f "$temp_script" ]] && rm -f "$temp_script"
            return 1
        fi
    else
        log "ERROR" "Failed to download new version"
        return 1
    fi
}

# Check and notify about updates at startup
check_updates_at_startup() {
    local update_status=0
    check_moonfrp_updates >/dev/null 2>&1
    update_status=$?

    if [[ $update_status -eq 0 ]]; then
        echo -e "\n${YELLOW}🔔 Update Available!${NC} ${GREEN}A new version of MoonFRP is available${NC}"
        echo -e "${CYAN}   Use menu option 6 to update${NC}"
    fi
}

# Fast loading spinner for operations
show_spinner() {
    local pid=$1
    local delay=0.1
    local spinner='|/-\'

    while kill -0 "$pid" 2>/dev/null; do
        for i in $(seq 0 3); do
            echo -ne "\r${CYAN}Loading ${spinner:$i:1}${NC}"
            sleep $delay
        done
    done
    echo -ne "\r"
}

# Optimized system check functions
optimize_systemctl_calls() {
    # Reduce systemctl timeout for faster responses
    export SYSTEMD_COLORS=0
    export SYSTEMCTL_TIMEOUT=3
    # Create faster aliases for systemctl commands
    alias systemctl='timeout 3 systemctl --no-pager --quiet'
    alias journalctl='timeout 3 journalctl --no-pager --quiet'

    # Optimize systemd settings for better performance
    export SYSTEMD_PAGER=""
    export SYSTEMD_LESS=""
}

# List all FRP services with caching
list_frp_services() {
    echo -e "\n${CYAN}=== FRP Services Status ===${NC}"

    # Improved caching with longer duration for better performance
    local current_time=$(date +%s)
    if [[ -z "${CACHE_DATA["services"]}" ]] || [[ $((current_time - ${CACHE_DATA["services_time"]})) -gt 10 ]]; then
        # Much faster service detection with optimized grep
        local all_services
        all_services=$(systemctl list-units --type=service --no-legend --plain 2>/dev/null | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//')

        # Filter and cache results
        CACHE_DATA["services"]=""
        if [[ -n "$all_services" ]]; then
            CACHE_DATA["services"]="$all_services"
        fi

        CACHE_DATA["services_time"]="$current_time"
    fi

    local services=()
    if [[ -n "${CACHE_DATA["services"]}" ]]; then
        while IFS= read -r service; do
            [[ -n "$service" && "$service" != " " ]] && services+=("$service")
        done <<< "${CACHE_DATA["services"]}"
    fi

    if [[ ${#services[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No FRP services found${NC}"
        return
    fi

    # Batch get all service statuses at once for better performance
    local status_output
    status_output=$(systemctl is-active "${services[@]}" 2>/dev/null || true)

    # Convert to array
    local statuses=()
    while IFS= read -r status; do
        statuses+=("$status")
    done <<< "$status_output"

    printf "%-20s %-12s %-15s\n" "Service" "Status" "Type"
    printf "%-20s %-12s %-15s\n" "-------" "------" "----"

    for i in "${!services[@]}"; do
        local service="${services[$i]}"
        local status="${statuses[$i]:-inactive}"
        local type="Unknown"

        # Determine service type with improved pattern matching
        if [[ "$service" =~ moonfrps.*server ]]; then
            type="Server"
        elif [[ "$service" =~ moonfrpc.*client ]]; then
            type="Client"
        elif [[ "$service" =~ (frps|moonfrps) ]]; then
            type="Server"
        elif [[ "$service" =~ (frpc|moonfrpc) ]]; then
            type="Client"
        elif [[ "$service" =~ moonfrp ]]; then
            type="MoonFRP"
        fi

        # Clean up status text and limit length
        local clean_status="$status"
        if [[ ${#clean_status} -gt 10 ]]; then
            clean_status="${clean_status:0:10}"
        fi

        # Color status
        local status_color="$RED"
        case "$status" in
            "active") status_color="$GREEN" ;;
            "inactive") status_color="$RED" ;;
            "activating") status_color="$YELLOW" ;;
            "deactivating") status_color="$YELLOW" ;;
            "failed") status_color="$RED" ;;
            *) status_color="$GRAY" ;;
        esac

        printf "%-20s ${status_color}%-12s${NC} %-15s\n" "$service" "$clean_status" "$type"
    done
}

#==============================================================================
# SECTION 6: MENU SYSTEM
#==============================================================================

# Service management menu
service_management_menu() {
    while true; do
        # Check for Ctrl+C signal
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return
        fi

        clear
        echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║            MoonFRP                   ║${NC}"
        echo -e "${PURPLE}║        Service Management            ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

        list_frp_services

        echo -e "\n${CYAN}Service Management Options:${NC}"
        echo "1. Start Service"
        echo "2. Stop Service"
        echo "3. Restart Service"
        echo "4. View Service Status"
        echo "5. View Service Logs"
        echo "6. Reload Service"
        echo "7. Remove Single Service"
        echo "8. Remove All Services"
        echo "9. 🕐 Setup Cron Job (Auto-restart)"
        echo "10. Real-time Status Monitor"
        echo "11. Current Configuration Summary"
        echo "12. 🔧 Modify Server Configuration"
        echo "13. 🧹 Advanced Cleanup (Remove All FRP)"
        echo "0. Back to Main Menu"

        echo -e "\n${YELLOW}Enter your choice [0-13]:${NC} "
        read -r choice

        # Check for Ctrl+C after read
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return
        fi

        case $choice in
            1) manage_service_action "start" ;;
            2) manage_service_action "stop" ;;
            3) manage_service_action "restart" ;;
            4) manage_service_action "status" ;;
            5) manage_service_action "logs" ;;
            6) manage_service_action "reload" ;;
            7) remove_single_service ;;
            8) remove_all_services ;;
            9) setup_cron_job ;;
            10) real_time_status_monitor ;;
            11) show_current_config_summary ;;
            12) modify_server_configuration ;;
            13) cleanup_all_frp_services ;;
            0) return ;;
            *) log "WARN" "Invalid choice. Please try again." ;;
        esac
    done
}

# Enhanced service status display
show_enhanced_service_status() {
    local selected_service="$1"

    clear
    echo -e "${PURPLE}╔══════════════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║                            🔍 Enhanced Service Status                                ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════════════════════════════════════════════════════╝${NC}"

    echo -e "\n${CYAN}📋 Service: ${YELLOW}$selected_service${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    # Basic service information
    local status=$(systemctl is-active "$selected_service" 2>/dev/null || echo "inactive")
    local enabled=$(systemctl is-enabled "$selected_service" 2>/dev/null || echo "disabled")
    local uptime=$(systemctl show "$selected_service" -p ActiveEnterTimestamp --value 2>/dev/null)

    echo -e "\n${CYAN}🔧 Service Information:${NC}"
    echo -e "  Status: $([ "$status" == "active" ] && echo "${GREEN}🟢 Active${NC}" || echo "${RED}🔴 Inactive${NC}")"
    echo -e "  Enabled: $([ "$enabled" == "enabled" ] && echo "${GREEN}✅ Enabled${NC}" || echo "${YELLOW}⚠️  Disabled${NC}")"

    if [[ "$status" == "active" && -n "$uptime" ]]; then
        local uptime_formatted=$(date -d "$uptime" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
        echo -e "  Started: ${GREEN}$uptime_formatted${NC}"
    fi

    # Memory and CPU usage
    local memory_usage=$(systemctl show "$selected_service" -p MemoryCurrent --value 2>/dev/null)
    if [[ -n "$memory_usage" && "$memory_usage" != "18446744073709551615" ]]; then
        local memory_mb=$((memory_usage / 1024 / 1024))
        echo -e "  Memory: ${YELLOW}${memory_mb}MB${NC}"
    fi

    # Configuration file information
    local config_file=""
    local service_type=""

    if [[ "$selected_service" =~ moonfrps ]]; then
        config_file="$CONFIG_DIR/frps.toml"
        service_type="server"
    elif [[ "$selected_service" =~ moonfrpc ]]; then
        local ip_suffix=$(echo "$selected_service" | grep -o '[0-9]\+$')
        if [[ -n "$ip_suffix" ]]; then
            config_file="$CONFIG_DIR/frpc_${ip_suffix}.toml"
            service_type="client"
        fi
    fi

    if [[ -f "$config_file" ]]; then
        echo -e "\n${CYAN}📄 Configuration:${NC}"
        echo -e "  File: ${GREEN}$config_file${NC}"
        echo -e "  Size: ${YELLOW}$(ls -lh "$config_file" | awk '{print $5}')${NC}"
        echo -e "  Modified: ${YELLOW}$(stat -c '%y' "$config_file" | cut -d'.' -f1)${NC}"

        # Extract key configuration details
        if [[ "$service_type" == "server" ]]; then
            local bind_port=$(grep "bindPort" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
            local dashboard_port=$(grep "webServer.port" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
            local token=$(grep "auth.token" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')

            echo -e "  Bind Port: ${GREEN}${bind_port:-"Not set"}${NC}"
            echo -e "  Dashboard: ${GREEN}${dashboard_port:-"Disabled"}${NC}"
            echo -e "  Token: ${GREEN}${token:0:8}...${NC}"

        elif [[ "$service_type" == "client" ]]; then
            local server_addr=$(grep "serverAddr" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
            local server_port=$(grep "serverPort" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
            local proxy_count=$(grep -c "^\[\[proxies\]\]" "$config_file" 2>/dev/null || echo "0")

            echo -e "  Server: ${GREEN}${server_addr:-"Not set"}:${server_port:-"Not set"}${NC}"
            echo -e "  Proxies: ${GREEN}$proxy_count${NC}"
        fi
    fi

    # Connection and port status
    if [[ "$status" == "active" ]]; then
        echo -e "\n${CYAN}🌐 Connection Status:${NC}"

        if [[ "$service_type" == "server" && -f "$config_file" ]]; then
            local bind_port=$(grep "bindPort" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
            local dashboard_port=$(grep "webServer.port" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')

            if [[ -n "$bind_port" ]]; then
                if netstat -tuln 2>/dev/null | grep -q ":$bind_port "; then
                    echo -e "  Main Port $bind_port: ${GREEN}🟢 Listening${NC}"
                else
                    echo -e "  Main Port $bind_port: ${RED}🔴 Not listening${NC}"
                fi
            fi

            if [[ -n "$dashboard_port" ]]; then
                if netstat -tuln 2>/dev/null | grep -q ":$dashboard_port "; then
                    echo -e "  Dashboard Port $dashboard_port: ${GREEN}🟢 Listening${NC}"
                else
                    echo -e "  Dashboard Port $dashboard_port: ${RED}🔴 Not listening${NC}"
                fi
            fi

        elif [[ "$service_type" == "client" && -f "$config_file" ]]; then
            local server_addr=$(grep "serverAddr" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
            local server_port=$(grep "serverPort" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')

            if [[ -n "$server_addr" && -n "$server_port" ]]; then
                if timeout 3 bash -c "echo >/dev/tcp/$server_addr/$server_port" 2>/dev/null; then
                    echo -e "  Server Connection: ${GREEN}🟢 Connected${NC}"
                else
                    echo -e "  Server Connection: ${RED}🔴 Failed${NC}"
                fi
            fi

            # Check proxy ports
            local proxy_names=($(grep "name = " "$config_file" 2>/dev/null | awk '{print $3}' | tr -d '"'))
            local proxy_ports=($(grep "remotePort = " "$config_file" 2>/dev/null | awk '{print $3}' | tr -d '"'))

            if [[ ${#proxy_names[@]} -gt 0 ]]; then
                echo -e "  Proxy Status:"
                for i in "${!proxy_names[@]}"; do
                    local proxy_name="${proxy_names[$i]}"
                    local proxy_port="${proxy_ports[$i]}"
                    if [[ -n "$proxy_port" ]]; then
                        if netstat -tuln 2>/dev/null | grep -q ":$proxy_port "; then
                            echo -e "    ${proxy_name}: ${GREEN}🟢 Port $proxy_port active${NC}"
                        else
                            echo -e "    ${proxy_name}: ${YELLOW}🟡 Port $proxy_port inactive${NC}"
                        fi
                    else
                        echo -e "    ${proxy_name}: ${BLUE}🔵 No port specified${NC}"
                    fi
                done
            fi
        fi
    fi

    # Recent logs and activity
    echo -e "\n${CYAN}📊 Recent Activity:${NC}"
    local log_count=$(journalctl -u "$selected_service" -n 5 --no-pager -q 2>/dev/null | wc -l)
    if [[ $log_count -gt 0 ]]; then
        echo -e "  Recent entries: ${GREEN}$log_count${NC}"
        echo -e "  Latest logs:"
        journalctl -u "$selected_service" -n 3 --no-pager --since "10 minutes ago" -o short-precise 2>/dev/null | \
            sed 's/^/    /' | head -3
    else
        echo -e "  ${YELLOW}No recent activity${NC}"
    fi

    # Log level information
    if [[ -f "$config_file" ]]; then
        local log_level=$(grep "log.level" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
        local log_file=$(grep "log.to" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')

        if [[ -n "$log_level" || -n "$log_file" ]]; then
            echo -e "\n${CYAN}📝 Logging Configuration:${NC}"
            echo -e "  Level: ${GREEN}${log_level:-"info (default)"}${NC}"
            echo -e "  Output: ${GREEN}${log_file:-"systemd journal"}${NC}"
        fi
    fi

    # Quick actions menu
    echo -e "\n${CYAN}🔧 Quick Actions:${NC}"
    echo -e "  ${GREEN}1.${NC} View real-time logs"
    echo -e "  ${GREEN}2.${NC} Restart service"
    echo -e "  ${GREEN}3.${NC} Change log level"
    echo -e "  ${GREEN}4.${NC} Test connections"
    echo -e "  ${GREEN}5.${NC} View full systemctl status"
    echo -e "  ${GREEN}0.${NC} Back to service management"

    echo -e "\n${YELLOW}Select action [0-5]:${NC} "
    read -r action_choice

    case "$action_choice" in
        1)
            echo -e "\n${CYAN}📋 Real-time logs (Press Ctrl+C to stop):${NC}"
            journalctl -u "$selected_service" -f --output=short-precise
            ;;
        2)
            echo -e "\n${CYAN}🔄 Restarting service...${NC}"
            if systemctl restart "$selected_service"; then
                echo -e "${GREEN}✅ Service restarted successfully${NC}"
            else
                echo -e "${RED}❌ Failed to restart service${NC}"
            fi
            sleep 2
            ;;
        3)
            change_log_level "$selected_service" "$config_file"
            ;;
        4)
            test_service_connections "$selected_service" "$config_file"
            ;;
        5)
            echo -e "\n${CYAN}📊 Full systemctl status:${NC}"
            systemctl status "$selected_service" --no-pager
            ;;
        0)
            return
            ;;
        *)
            echo -e "${RED}❌ Invalid choice${NC}"
            ;;
    esac

    read -p "Press Enter to continue..."
}

# Change log level for FRP service
change_log_level() {
    local service_name="$1"
    local config_file="$2"

    if [[ ! -f "$config_file" ]]; then
        echo -e "${RED}❌ Configuration file not found${NC}"
        return 1
    fi

    echo -e "\n${CYAN}📝 Change Log Level${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    local current_level=$(grep "log.level" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
    echo -e "Current log level: ${GREEN}${current_level:-"info (default)"}${NC}"

    echo -e "\n${CYAN}Available log levels:${NC}"
    echo -e "  ${GREEN}1.${NC} trace (Most verbose - all details)"
    echo -e "  ${GREEN}2.${NC} debug (Debug information)"
    echo -e "  ${GREEN}3.${NC} info (General information) - Default"
    echo -e "  ${GREEN}4.${NC} warn (Warning messages only)"
    echo -e "  ${GREEN}5.${NC} error (Error messages only)"
    echo -e "  ${GREEN}0.${NC} Cancel"

    echo -e "\n${YELLOW}Select new log level [0-5]:${NC} "
    read -r level_choice

    local new_level=""
    case "$level_choice" in
        1) new_level="trace" ;;
        2) new_level="debug" ;;
        3) new_level="info" ;;
        4) new_level="warn" ;;
        5) new_level="error" ;;
        0) return ;;
        *)
            echo -e "${RED}❌ Invalid choice${NC}"
            return 1
            ;;
    esac

    echo -e "\n${CYAN}🔧 Updating log level to: ${YELLOW}$new_level${NC}"

    # Backup config file
    cp "$config_file" "${config_file}.backup"

    # Update log level
    if grep -q "log.level" "$config_file"; then
        # Replace existing log level
        sed -i "s/log.level = .*/log.level = \"$new_level\"/" "$config_file"
    else
        # Add log level after serverPort or other configuration
        if grep -q "serverPort" "$config_file"; then
            sed -i "/serverPort = .*/a\\nlog.level = \"$new_level\"" "$config_file"
        elif grep -q "bindPort" "$config_file"; then
            sed -i "/bindPort = .*/a\\nlog.level = \"$new_level\"" "$config_file"
        else
            # Add at the end of the file
            echo -e "\nlog.level = \"$new_level\"" >> "$config_file"
        fi
    fi

    # Add log file if not present
    if ! grep -q "log.to" "$config_file"; then
        local log_file_path="$LOG_DIR/frp_${service_name}.log"
        if grep -q "log.level" "$config_file"; then
            sed -i "/log.level = .*/a log.to = \"$log_file_path\"" "$config_file"
        else
            echo -e "log.to = \"$log_file_path\"" >> "$config_file"
        fi
        echo -e "  Added log file: ${GREEN}$log_file_path${NC}"
    fi

    echo -e "${GREEN}✅ Log level updated successfully${NC}"

    # Ask to restart service
    echo -e "\n${YELLOW}Service restart required for changes to take effect.${NC}"
    echo -e "${YELLOW}Restart $service_name now? (y/N):${NC} "
    read -r restart_choice

    if [[ "$restart_choice" =~ ^[Yy]$ ]]; then
        echo -e "\n${CYAN}🔄 Restarting service...${NC}"
        if systemctl restart "$service_name"; then
            echo -e "${GREEN}✅ Service restarted successfully${NC}"
            echo -e "${CYAN}New log level is now active${NC}"
        else
            echo -e "${RED}❌ Failed to restart service${NC}"
            echo -e "${YELLOW}Restoring backup configuration...${NC}"
            mv "${config_file}.backup" "$config_file"
        fi
    else
        echo -e "${YELLOW}⚠️  Service not restarted. Changes will take effect on next restart.${NC}"
    fi

    # Clean up backup if successful
    [[ -f "${config_file}.backup" ]] && rm -f "${config_file}.backup"
}

# Test service connections
test_service_connections() {
    local service_name="$1"
    local config_file="$2"

    echo -e "\n${CYAN}🔍 Testing Service Connections${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    if [[ ! -f "$config_file" ]]; then
        echo -e "${RED}❌ Configuration file not found${NC}"
        return 1
    fi

    # Determine service type
    local service_type=""
    if [[ "$service_name" =~ moonfrps ]]; then
        service_type="server"
    elif [[ "$service_name" =~ moonfrpc ]]; then
        service_type="client"
    fi

    if [[ "$service_type" == "server" ]]; then
        echo -e "\n${CYAN}🖥️  Server Connection Tests:${NC}"

        # Test main FRP port
        local bind_port=$(grep "bindPort" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
        if [[ -n "$bind_port" ]]; then
            echo -e "  Testing main port $bind_port..."
            if netstat -tuln 2>/dev/null | grep -q ":$bind_port "; then
                echo -e "    ${GREEN}✅ Port $bind_port is listening${NC}"
            else
                echo -e "    ${RED}❌ Port $bind_port is not listening${NC}"
            fi
        fi

        # Test dashboard port
        local dashboard_port=$(grep "webServer.port" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
        if [[ -n "$dashboard_port" ]]; then
            echo -e "  Testing dashboard port $dashboard_port..."
            if netstat -tuln 2>/dev/null | grep -q ":$dashboard_port "; then
                echo -e "    ${GREEN}✅ Dashboard port $dashboard_port is listening${NC}"

                # Test HTTP response
                if curl -s -o /dev/null -w "%{http_code}" "http://localhost:$dashboard_port" 2>/dev/null | grep -q "200\|401"; then
                    echo -e "    ${GREEN}✅ Dashboard HTTP response OK${NC}"
                else
                    echo -e "    ${YELLOW}⚠️  Dashboard HTTP response failed${NC}"
                fi
            else
                echo -e "    ${RED}❌ Dashboard port $dashboard_port is not listening${NC}"
            fi
        fi

        # Test external connectivity
        echo -e "  Testing external connectivity..."
        local public_ip=$(curl -s --connect-timeout 5 ipinfo.io/ip 2>/dev/null || echo "Unable to determine")
        echo -e "    Public IP: ${GREEN}$public_ip${NC}"

    elif [[ "$service_type" == "client" ]]; then
        echo -e "\n${CYAN}📡 Client Connection Tests:${NC}"

        # Test server connection
        local server_addr=$(grep "serverAddr" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
        local server_port=$(grep "serverPort" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')

        if [[ -n "$server_addr" && -n "$server_port" ]]; then
            echo -e "  Testing server connection $server_addr:$server_port..."
            if timeout 5 bash -c "echo >/dev/tcp/$server_addr/$server_port" 2>/dev/null; then
                echo -e "    ${GREEN}✅ Server connection successful${NC}"

                # Test with ping
                if ping -c 1 -W 2 "$server_addr" >/dev/null 2>&1; then
                    echo -e "    ${GREEN}✅ Server ping successful${NC}"
                else
                    echo -e "    ${YELLOW}⚠️  Server ping failed (may be blocked)${NC}"
                fi
            else
                echo -e "    ${RED}❌ Server connection failed${NC}"
                echo -e "    ${YELLOW}Troubleshooting server connection...${NC}"

                # DNS resolution test
                if nslookup "$server_addr" >/dev/null 2>&1; then
                    echo -e "    ${GREEN}✅ DNS resolution OK${NC}"
                else
                    echo -e "    ${RED}❌ DNS resolution failed${NC}"
                fi
            fi
        fi

        # Test local proxy ports
        echo -e "  Testing local proxy ports..."
        local proxy_names=($(grep "name = " "$config_file" 2>/dev/null | awk '{print $3}' | tr -d '"'))
        local local_ports=($(grep "localPort = " "$config_file" 2>/dev/null | awk '{print $3}' | tr -d '"'))

        if [[ ${#proxy_names[@]} -gt 0 ]]; then
            for i in "${!proxy_names[@]}"; do
                local proxy_name="${proxy_names[$i]}"
                local local_port="${local_ports[$i]}"

                if [[ -n "$local_port" ]]; then
                    echo -e "    Testing ${proxy_name} (local port $local_port)..."
                    if netstat -tuln 2>/dev/null | grep -q ":$local_port "; then
                        echo -e "      ${GREEN}✅ Local service on port $local_port is running${NC}"
                    else
                        echo -e "      ${YELLOW}⚠️  Local service on port $local_port is not running${NC}"
                    fi
                fi
            done
        fi
    fi

    # Authentication test
    echo -e "\n${CYAN}🔐 Authentication Test:${NC}"
    local token=$(grep "auth.token" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
    if [[ -n "$token" ]]; then
        echo -e "  Token configured: ${GREEN}${token:0:8}...${NC}"
        echo -e "  Token length: ${GREEN}${#token} characters${NC}"

        if [[ ${#token} -lt 8 ]]; then
            echo -e "  ${YELLOW}⚠️  Token is very short (recommended: 16+ chars)${NC}"
        fi
    else
        echo -e "  ${RED}❌ No authentication token configured${NC}"
    fi

    echo -e "\n${CYAN}📊 Connection Summary:${NC}"
    local status=$(systemctl is-active "$service_name" 2>/dev/null || echo "inactive")
    echo -e "  Service Status: $([ "$status" == "active" ] && echo "${GREEN}🟢 Active${NC}" || echo "${RED}🔴 Inactive${NC}")"

    # Process information
    local pid=$(systemctl show "$service_name" -p MainPID --value 2>/dev/null)
    if [[ -n "$pid" && "$pid" != "0" ]]; then
        echo -e "  Process ID: ${GREEN}$pid${NC}"
        local connections=$(netstat -antp 2>/dev/null | grep "$pid" | wc -l)
        echo -e "  Active connections: ${GREEN}$connections${NC}"
         fi
}

# Enhanced service logs viewer
show_enhanced_service_logs() {
    local selected_service="$1"

    while true; do
        clear
        echo -e "${PURPLE}╔══════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║                            📋 Enhanced Service Logs                                 ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════════════════════════════════════════════════════╝${NC}"

        echo -e "\n${CYAN}📋 Service: ${YELLOW}$selected_service${NC}"
        echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

        # Log statistics
        local total_logs=$(journalctl -u "$selected_service" --no-pager -q | wc -l)
        local today_logs=$(journalctl -u "$selected_service" --since today --no-pager -q | wc -l)
        local hour_logs=$(journalctl -u "$selected_service" --since "1 hour ago" --no-pager -q | wc -l)
        local error_logs=$(journalctl -u "$selected_service" --since "24 hours ago" --no-pager -q | grep -i error | wc -l)
        local warn_logs=$(journalctl -u "$selected_service" --since "24 hours ago" --no-pager -q | grep -i warn | wc -l)

        echo -e "\n${CYAN}📊 Log Statistics:${NC}"
        echo -e "  Total logs: ${GREEN}$total_logs${NC}"
        echo -e "  Today: ${GREEN}$today_logs${NC}"
        echo -e "  Last hour: ${GREEN}$hour_logs${NC}"
        echo -e "  Errors (24h): ${RED}$error_logs${NC}"
        echo -e "  Warnings (24h): ${YELLOW}$warn_logs${NC}"

        # Log file information
        local config_file=""
        if [[ "$selected_service" =~ moonfrps ]]; then
            config_file="$CONFIG_DIR/frps.toml"
        elif [[ "$selected_service" =~ moonfrpc ]]; then
            local ip_suffix=$(echo "$selected_service" | grep -o '[0-9]\+$')
            if [[ -n "$ip_suffix" ]]; then
                config_file="$CONFIG_DIR/frpc_${ip_suffix}.toml"
            fi
        fi

        if [[ -f "$config_file" ]]; then
            local log_file=$(grep "log.to" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
            local log_level=$(grep "log.level" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')

            if [[ -n "$log_file" && -f "$log_file" ]]; then
                local file_size=$(ls -lh "$log_file" | awk '{print $5}')
                echo -e "  Log file: ${GREEN}$log_file${NC} (${YELLOW}$file_size${NC})"
            fi
            echo -e "  Log level: ${GREEN}${log_level:-"info (default)"}${NC}"
        fi

        echo -e "\n${CYAN}📋 Log Viewer Options:${NC}"
        echo -e "  ${GREEN}1.${NC} Recent logs (last 50 lines)"
        echo -e "  ${GREEN}2.${NC} Real-time logs (follow mode)"
        echo -e "  ${GREEN}3.${NC} Search logs"
        echo -e "  ${GREEN}4.${NC} Filter by time range"
        echo -e "  ${GREEN}5.${NC} Filter by log level"
        echo -e "  ${GREEN}6.${NC} Error analysis"
        echo -e "  ${GREEN}7.${NC} Export logs"
        echo -e "  ${GREEN}8.${NC} Clear old logs"
        echo -e "  ${GREEN}0.${NC} Back to service management"

        echo -e "\n${YELLOW}Select option [0-8]:${NC} "
        read -r log_choice

        case "$log_choice" in
            1)
                show_recent_logs "$selected_service"
                ;;
            2)
                show_realtime_logs "$selected_service"
                ;;
            3)
                search_logs "$selected_service"
                ;;
            4)
                filter_logs_by_time "$selected_service"
                ;;
            5)
                filter_logs_by_level "$selected_service"
                ;;
            6)
                analyze_errors "$selected_service"
                ;;
            7)
                export_logs "$selected_service"
                ;;
            8)
                clear_old_logs "$selected_service"
                ;;
            0)
                return
                ;;
            *)
                echo -e "${RED}❌ Invalid choice${NC}"
                sleep 2
                ;;
        esac
    done
}

# Show recent logs
show_recent_logs() {
    local service_name="$1"

    clear
    echo -e "${CYAN}📋 Recent Logs: $service_name${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    echo -e "\n${YELLOW}How many lines to show?${NC}"
    echo -e "  ${GREEN}1.${NC} Last 20 lines"
    echo -e "  ${GREEN}2.${NC} Last 50 lines"
    echo -e "  ${GREEN}3.${NC} Last 100 lines"
    echo -e "  ${GREEN}4.${NC} Custom number"

    echo -e "\n${YELLOW}Select option [1-4]:${NC} "
    read -r lines_choice

    local lines=50
    case "$lines_choice" in
        1) lines=20 ;;
        2) lines=50 ;;
        3) lines=100 ;;
        4)
            echo -e "${YELLOW}Enter number of lines:${NC} "
            read -r custom_lines
            if [[ "$custom_lines" =~ ^[0-9]+$ ]]; then
                lines=$custom_lines
            fi
            ;;
    esac

    echo -e "\n${CYAN}📋 Last $lines log entries:${NC}"
    journalctl -u "$service_name" -n "$lines" --no-pager --output=short-precise | \
        sed -E 's/(ERROR|FAILED|FAIL)/\o033[31m&\o033[0m/g' | \
        sed -E 's/(WARN|WARNING)/\o033[33m&\o033[0m/g' | \
        sed -E 's/(INFO|SUCCESS)/\o033[32m&\o033[0m/g' | \
        sed -E 's/(DEBUG|TRACE)/\o033[36m&\o033[0m/g'

    read -p "Press Enter to continue..."
}

# Show real-time logs
show_realtime_logs() {
    local service_name="$1"

    clear
    echo -e "${CYAN}📋 Real-time Logs: $service_name${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    echo -e "\n${YELLOW}Real-time log monitoring (Press Ctrl+C to stop)${NC}"
    echo -e "${GRAY}Starting in 3 seconds...${NC}"
    sleep 3

    # Color-coded real-time logs
    journalctl -u "$service_name" -f --output=short-precise | \
        sed -E 's/(ERROR|FAILED|FAIL)/\o033[31m&\o033[0m/g' | \
        sed -E 's/(WARN|WARNING)/\o033[33m&\o033[0m/g' | \
        sed -E 's/(INFO|SUCCESS)/\o033[32m&\o033[0m/g' | \
        sed -E 's/(DEBUG|TRACE)/\o033[36m&\o033[0m/g'
}

# Search logs
search_logs() {
    local service_name="$1"

    clear
    echo -e "${CYAN}🔍 Search Logs: $service_name${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    echo -e "\n${YELLOW}Enter search term:${NC} "
    read -r search_term

    if [[ -z "$search_term" ]]; then
        echo -e "${RED}❌ Search term cannot be empty${NC}"
        read -p "Press Enter to continue..."
        return
    fi

    echo -e "\n${CYAN}🔍 Search results for: ${YELLOW}$search_term${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    local results=$(journalctl -u "$service_name" --no-pager -q | grep -i "$search_term" | wc -l)

    if [[ $results -eq 0 ]]; then
        echo -e "${YELLOW}No results found for '$search_term'${NC}"
    else
        echo -e "${GREEN}Found $results matches:${NC}\n"

        # Show search results with highlighting
        journalctl -u "$service_name" --no-pager --output=short-precise | \
            grep -i "$search_term" | \
            sed -E "s/($search_term)/\o033[43m\o033[30m&\o033[0m/gi" | \
            sed -E 's/(ERROR|FAILED|FAIL)/\o033[31m&\o033[0m/g' | \
            sed -E 's/(WARN|WARNING)/\o033[33m&\o033[0m/g' | \
            sed -E 's/(INFO|SUCCESS)/\o033[32m&\o033[0m/g' | \
            head -20

        if [[ $results -gt 20 ]]; then
            echo -e "\n${YELLOW}... and $((results - 20)) more results${NC}"
        fi
    fi

    read -p "Press Enter to continue..."
}

# Filter logs by time range
filter_logs_by_time() {
    local service_name="$1"

    clear
    echo -e "${CYAN}⏰ Filter by Time Range: $service_name${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    echo -e "\n${YELLOW}Select time range:${NC}"
    echo -e "  ${GREEN}1.${NC} Last 15 minutes"
    echo -e "  ${GREEN}2.${NC} Last hour"
    echo -e "  ${GREEN}3.${NC} Last 6 hours"
    echo -e "  ${GREEN}4.${NC} Today"
    echo -e "  ${GREEN}5.${NC} Yesterday"
    echo -e "  ${GREEN}6.${NC} Last 7 days"
    echo -e "  ${GREEN}7.${NC} Custom range"

    echo -e "\n${YELLOW}Select option [1-7]:${NC} "
    read -r time_choice

    local since_time=""
    local until_time=""

    case "$time_choice" in
        1) since_time="15 minutes ago" ;;
        2) since_time="1 hour ago" ;;
        3) since_time="6 hours ago" ;;
        4) since_time="today" ;;
        5)
            since_time="yesterday"
            until_time="today"
            ;;
        6) since_time="7 days ago" ;;
        7)
            echo -e "${YELLOW}Enter start time (e.g., '2024-01-01 10:00'):${NC} "
            read -r start_time
            echo -e "${YELLOW}Enter end time (optional, press Enter for now):${NC} "
            read -r end_time

            since_time="$start_time"
            [[ -n "$end_time" ]] && until_time="$end_time"
            ;;
        *)
            echo -e "${RED}❌ Invalid choice${NC}"
            read -p "Press Enter to continue..."
            return
            ;;
    esac

    echo -e "\n${CYAN}📋 Logs from: ${YELLOW}$since_time${NC}"
    [[ -n "$until_time" ]] && echo -e "${CYAN}Until: ${YELLOW}$until_time${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    local cmd="journalctl -u $service_name --since \"$since_time\""
    [[ -n "$until_time" ]] && cmd="$cmd --until \"$until_time\""
    cmd="$cmd --no-pager --output=short-precise"

    eval "$cmd" | \
        sed -E 's/(ERROR|FAILED|FAIL)/\o033[31m&\o033[0m/g' | \
        sed -E 's/(WARN|WARNING)/\o033[33m&\o033[0m/g' | \
        sed -E 's/(INFO|SUCCESS)/\o033[32m&\o033[0m/g' | \
        sed -E 's/(DEBUG|TRACE)/\o033[36m&\o033[0m/g'

    read -p "Press Enter to continue..."
}

# Filter logs by level
filter_logs_by_level() {
    local service_name="$1"

    clear
    echo -e "${CYAN}🔍 Filter by Log Level: $service_name${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    echo -e "\n${YELLOW}Select log level to filter:${NC}"
    echo -e "  ${GREEN}1.${NC} Errors only"
    echo -e "  ${GREEN}2.${NC} Warnings only"
    echo -e "  ${GREEN}3.${NC} Info messages"
    echo -e "  ${GREEN}4.${NC} Debug messages"
    echo -e "  ${GREEN}5.${NC} All levels"

    echo -e "\n${YELLOW}Select option [1-5]:${NC} "
    read -r level_choice

    local filter_pattern=""
    local level_name=""

    case "$level_choice" in
        1)
            filter_pattern="ERROR|FAILED|FAIL"
            level_name="Errors"
            ;;
        2)
            filter_pattern="WARN|WARNING"
            level_name="Warnings"
            ;;
        3)
            filter_pattern="INFO|SUCCESS"
            level_name="Info"
            ;;
        4)
            filter_pattern="DEBUG|TRACE"
            level_name="Debug"
            ;;
        5)
            filter_pattern=".*"
            level_name="All levels"
            ;;
        *)
            echo -e "${RED}❌ Invalid choice${NC}"
            read -p "Press Enter to continue..."
            return
            ;;
    esac

    echo -e "\n${CYAN}📋 $level_name logs:${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    local results=$(journalctl -u "$service_name" --no-pager -q | grep -iE "$filter_pattern" | wc -l)

    if [[ $results -eq 0 ]]; then
        echo -e "${YELLOW}No $level_name logs found${NC}"
    else
        echo -e "${GREEN}Found $results $level_name entries:${NC}\n"

        journalctl -u "$service_name" --no-pager --output=short-precise | \
            grep -iE "$filter_pattern" | \
            sed -E 's/(ERROR|FAILED|FAIL)/\o033[31m&\o033[0m/g' | \
            sed -E 's/(WARN|WARNING)/\o033[33m&\o033[0m/g' | \
            sed -E 's/(INFO|SUCCESS)/\o033[32m&\o033[0m/g' | \
            sed -E 's/(DEBUG|TRACE)/\o033[36m&\o033[0m/g' | \
            tail -50
    fi

    read -p "Press Enter to continue..."
}

# Analyze errors
analyze_errors() {
    local service_name="$1"

    clear
    echo -e "${CYAN}🔍 Error Analysis: $service_name${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    # Get error statistics
    local total_errors=$(journalctl -u "$service_name" --since "24 hours ago" --no-pager -q | grep -iE "ERROR|FAILED|FAIL" | wc -l)
    local connection_errors=$(journalctl -u "$service_name" --since "24 hours ago" --no-pager -q | grep -iE "connection|connect" | grep -iE "ERROR|FAILED|FAIL" | wc -l)
    local auth_errors=$(journalctl -u "$service_name" --since "24 hours ago" --no-pager -q | grep -iE "auth|token" | grep -iE "ERROR|FAILED|FAIL" | wc -l)
    local timeout_errors=$(journalctl -u "$service_name" --since "24 hours ago" --no-pager -q | grep -iE "timeout|timed out" | wc -l)

    echo -e "\n${CYAN}📊 Error Statistics (Last 24 hours):${NC}"
    echo -e "  Total errors: ${RED}$total_errors${NC}"
    echo -e "  Connection errors: ${RED}$connection_errors${NC}"
    echo -e "  Authentication errors: ${RED}$auth_errors${NC}"
    echo -e "  Timeout errors: ${RED}$timeout_errors${NC}"

    if [[ $total_errors -eq 0 ]]; then
        echo -e "\n${GREEN}✅ No errors found in the last 24 hours!${NC}"
    else
        echo -e "\n${CYAN}🔍 Common Error Patterns:${NC}"

        # Show most common error patterns
        journalctl -u "$service_name" --since "24 hours ago" --no-pager -q | \
            grep -iE "ERROR|FAILED|FAIL" | \
            awk '{for(i=6;i<=NF;i++) printf "%s ", $i; printf "\n"}' | \
            sort | uniq -c | sort -nr | head -5 | \
            while read count message; do
                echo -e "  ${RED}$count${NC}x: $message"
            done

        echo -e "\n${CYAN}📋 Recent Error Messages:${NC}"
        journalctl -u "$service_name" --since "1 hour ago" --no-pager --output=short-precise | \
            grep -iE "ERROR|FAILED|FAIL" | \
            sed -E 's/(ERROR|FAILED|FAIL)/\o033[31m&\o033[0m/g' | \
            tail -10

        echo -e "\n${CYAN}💡 Troubleshooting Suggestions:${NC}"
        if [[ $connection_errors -gt 0 ]]; then
            echo -e "  ${YELLOW}• Check network connectivity and firewall settings${NC}"
        fi
        if [[ $auth_errors -gt 0 ]]; then
            echo -e "  ${YELLOW}• Verify authentication tokens match between client and server${NC}"
        fi
        if [[ $timeout_errors -gt 0 ]]; then
            echo -e "  ${YELLOW}• Consider increasing timeout values or checking network latency${NC}"
        fi
    fi

    read -p "Press Enter to continue..."
}

# Export logs
export_logs() {
    local service_name="$1"

    clear
    echo -e "${CYAN}📤 Export Logs: $service_name${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local export_file="$LOG_DIR/${service_name}_export_${timestamp}.log"

    echo -e "\n${YELLOW}Select export range:${NC}"
    echo -e "  ${GREEN}1.${NC} Last 100 lines"
    echo -e "  ${GREEN}2.${NC} Last 24 hours"
    echo -e "  ${GREEN}3.${NC} All logs"
    echo -e "  ${GREEN}4.${NC} Custom range"

    echo -e "\n${YELLOW}Select option [1-4]:${NC} "
    read -r export_choice

    local cmd=""
    case "$export_choice" in
        1) cmd="journalctl -u $service_name -n 100 --no-pager" ;;
        2) cmd="journalctl -u $service_name --since '24 hours ago' --no-pager" ;;
        3) cmd="journalctl -u $service_name --no-pager" ;;
        4)
            echo -e "${YELLOW}Enter start time (e.g., '2024-01-01 10:00'):${NC} "
            read -r start_time
            echo -e "${YELLOW}Enter end time (optional):${NC} "
            read -r end_time

            cmd="journalctl -u $service_name --since '$start_time'"
            [[ -n "$end_time" ]] && cmd="$cmd --until '$end_time'"
            cmd="$cmd --no-pager"
            ;;
        *)
            echo -e "${RED}❌ Invalid choice${NC}"
            read -p "Press Enter to continue..."
            return
            ;;
    esac

    echo -e "\n${CYAN}📤 Exporting logs to: ${YELLOW}$export_file${NC}"

    if eval "$cmd" > "$export_file"; then
        local file_size=$(ls -lh "$export_file" | awk '{print $5}')
        echo -e "${GREEN}✅ Export completed successfully${NC}"
        echo -e "  File: ${GREEN}$export_file${NC}"
        echo -e "  Size: ${GREEN}$file_size${NC}"
        echo -e "  Lines: ${GREEN}$(wc -l < "$export_file")${NC}"

        echo -e "\n${YELLOW}Open exported file now? (y/N):${NC} "
        read -r open_choice
        if [[ "$open_choice" =~ ^[Yy]$ ]]; then
            less "$export_file"
        fi
    else
        echo -e "${RED}❌ Export failed${NC}"
    fi

    read -p "Press Enter to continue..."
}

# Clear old logs
clear_old_logs() {
    local service_name="$1"

    clear
    echo -e "${CYAN}🗑️  Clear Old Logs: $service_name${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    local current_size=$(journalctl -u "$service_name" --no-pager -q | wc -l)
    echo -e "\n${CYAN}Current log size: ${YELLOW}$current_size lines${NC}"

    echo -e "\n${YELLOW}⚠️  This will permanently delete old logs!${NC}"
    echo -e "\n${YELLOW}Select retention period:${NC}"
    echo -e "  ${GREEN}1.${NC} Keep last 24 hours"
    echo -e "  ${GREEN}2.${NC} Keep last 7 days"
    echo -e "  ${GREEN}3.${NC} Keep last 30 days"
    echo -e "  ${GREEN}4.${NC} Clear all logs"
    echo -e "  ${GREEN}0.${NC} Cancel"

    echo -e "\n${YELLOW}Select option [0-4]:${NC} "
    read -r clear_choice

    local retention_time=""
    case "$clear_choice" in
        1) retention_time="24 hours" ;;
        2) retention_time="7 days" ;;
        3) retention_time="30 days" ;;
        4) retention_time="0 seconds" ;;
        0) return ;;
        *)
            echo -e "${RED}❌ Invalid choice${NC}"
            read -p "Press Enter to continue..."
            return
            ;;
    esac

    echo -e "\n${RED}⚠️  Are you sure you want to clear logs older than $retention_time? (y/N):${NC} "
    read -r confirm_clear

    if [[ "$confirm_clear" =~ ^[Yy]$ ]]; then
        echo -e "\n${CYAN}🗑️  Clearing old logs...${NC}"

        # Clear systemd journal logs
        if journalctl --vacuum-time="$retention_time" >/dev/null 2>&1; then
            echo -e "${GREEN}✅ Systemd journal logs cleared${NC}"
        else
            echo -e "${YELLOW}⚠️  Failed to clear systemd journal logs${NC}"
        fi

        # Clear custom log files if any
        local config_file=""
        if [[ "$service_name" =~ moonfrps ]]; then
            config_file="$CONFIG_DIR/frps.toml"
        elif [[ "$service_name" =~ moonfrpc ]]; then
            local ip_suffix=$(echo "$service_name" | grep -o '[0-9]\+$')
            if [[ -n "$ip_suffix" ]]; then
                config_file="$CONFIG_DIR/frpc_${ip_suffix}.toml"
            fi
        fi

        if [[ -f "$config_file" ]]; then
            local log_file=$(grep "log.to" "$config_file" 2>/dev/null | head -1 | awk '{print $3}' | tr -d '"')
            if [[ -n "$log_file" && -f "$log_file" ]]; then
                if [[ "$retention_time" == "0 seconds" ]]; then
                    > "$log_file"
                    echo -e "${GREEN}✅ Custom log file cleared${NC}"
                else
                    echo -e "${YELLOW}⚠️  Custom log file not cleared (use log rotation)${NC}"
                fi
            fi
        fi

        local new_size=$(journalctl -u "$service_name" --no-pager -q | wc -l)
        echo -e "\n${GREEN}✅ Log cleanup completed${NC}"
        echo -e "  Previous size: ${YELLOW}$current_size lines${NC}"
        echo -e "  Current size: ${YELLOW}$new_size lines${NC}"
        echo -e "  Cleaned: ${GREEN}$((current_size - new_size)) lines${NC}"
    else
        echo -e "${YELLOW}Operation cancelled${NC}"
    fi

    read -p "Press Enter to continue..."
}

# Service action handler
manage_service_action() {
    local action="$1"

    echo -e "\n${CYAN}Available services:${NC}"

    # Use cached services if available, otherwise get fresh list
    local services=()
    if [[ -n "${CACHE_DATA["services"]}" ]]; then
        while IFS= read -r service; do
            [[ -n "$service" && "$service" != " " ]] && services+=("$service")
        done <<< "${CACHE_DATA["services"]}"
    fi
    
    if [[ ${#services[@]} -eq 0 ]]; then
        # Force refresh if cache is empty
        list_frp_services >/dev/null 2>&1
        if [[ -n "${CACHE_DATA["services"]}" ]]; then
            while IFS= read -r service; do
                [[ -n "$service" && "$service" != " " ]] && services+=("$service")
            done <<< "${CACHE_DATA["services"]}"
        fi
    fi

    if [[ ${#services[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No FRP services found${NC}"
        read -p "Press Enter to continue..."
        return
    fi

    # Batch get all service statuses for better performance
    local status_output
    status_output=$(systemctl is-active "${services[@]}" 2>/dev/null || true)

    # Convert to array
    local statuses=()
    while IFS= read -r status; do
        statuses+=("$status")
    done <<< "$status_output"

    printf "%-4s %-25s %-12s %-15s\n" "No." "Service" "Status" "Type"
    printf "%-4s %-25s %-12s %-15s\n" "---" "-------" "------" "----"

    local i=1
    for idx in "${!services[@]}"; do
        local service="${services[$idx]}"
        local status="${statuses[$idx]:-inactive}"
        local type="Unknown"

        if [[ "$service" =~ (frps|moonfrps) ]]; then
            type="Server"
        elif [[ "$service" =~ (frpc|moonfrpc) ]]; then
            type="Client"
        fi

        # Clean up status text and limit length
        local clean_status="$status"
        if [[ ${#clean_status} -gt 10 ]]; then
            clean_status="${clean_status:0:10}"
        fi

        local status_color="$RED"
        case "$status" in
            "active") status_color="$GREEN" ;;
            "inactive") status_color="$RED" ;;
            "activating") status_color="$YELLOW" ;;
            "deactivating") status_color="$YELLOW" ;;
            "failed") status_color="$RED" ;;
            *) status_color="$GRAY" ;;
        esac

        printf "%-4s %-25s ${status_color}%-12s${NC} %-15s\n" "$i." "$service" "$clean_status" "$type"
        ((i++))
    done

    echo -e "\n${YELLOW}Select service number (or 'all' for all services):${NC} "
    read -r service_num

    if [[ "$service_num" == "all" ]]; then
        # Handle all services
        echo -e "\n${CYAN}Performing '$action' on all services...${NC}"
        for service in "${services[@]}"; do
            echo -e "${CYAN}Processing: $service${NC}"
            case "$action" in
                "start") manage_service "start" "$service" ;;
                "stop") manage_service "stop" "$service" ;;
                "restart") manage_service "restart" "$service" ;;
                "reload") manage_service "reload" "$service" ;;
                "status"|"logs")
                    echo -e "${YELLOW}Skipping '$action' for $service (not supported for bulk operations)${NC}"
                    ;;
            esac
        done

        if [[ "$action" == "stop" ]]; then
            echo -e "${CYAN}Running systemctl daemon-reload...${NC}"
            systemctl daemon-reload
        fi

        log "INFO" "Completed '$action' operation on all services"
        read -p "Press Enter to continue..."
        return
    fi

    if [[ ! "$service_num" =~ ^[0-9]+$ ]] || [[ $service_num -lt 1 ]] || [[ $service_num -gt ${#services[@]} ]]; then
        log "ERROR" "Invalid service number. Please enter a number between 1-${#services[@]} or 'all'"
        read -p "Press Enter to continue..."
        return
    fi

    local selected_service="${services[$((service_num-1))]}"
    if [[ -z "$selected_service" ]]; then
        log "ERROR" "Selected service is empty or invalid"
        read -p "Press Enter to continue..."
        return
    fi

    case "$action" in
        "start")
            echo -e "\n${CYAN}Starting service: $selected_service${NC}"
            manage_service "start" "$selected_service" "validate"
            ;;
        "stop")
            echo -e "\n${CYAN}Stopping service: $selected_service${NC}"
            manage_service "stop" "$selected_service"
            ;;
        "restart")
            echo -e "\n${CYAN}Restarting service: $selected_service${NC}"
            manage_service "restart" "$selected_service"
            ;;
        "status")
            manage_service "status" "$selected_service"
            ;;
        "logs")
            view_logs "$selected_service" "enhanced"
            ;;
        "reload")
            echo -e "\n${CYAN}Reloading service: $selected_service${NC}"
            manage_service "reload" "$selected_service"
            ;;
    esac

    read -p "Press Enter to continue..."
}

# Modify server configuration
modify_server_configuration() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║     🔧 Modify Server Configuration  ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    # Find existing server configurations
    local server_configs=()
    if [[ -f "$CONFIG_DIR/frps.toml" ]]; then
        server_configs+=("frps.toml")
    fi

    if [[ ${#server_configs[@]} -eq 0 ]]; then
        echo -e "\n${YELLOW}⚠️  No existing server configurations found${NC}"
        echo -e "${CYAN}Please create a server configuration first from the main menu.${NC}"
        read -p "Press Enter to continue..."
        return
    fi

    echo -e "\n${CYAN}📋 Current Server Configuration:${NC}"
    echo -e "${GREEN}✅ Configuration file: $CONFIG_DIR/frps.toml${NC}"

    # Show current configuration summary
    if [[ -f "$CONFIG_DIR/frps.toml" ]]; then
        echo -e "\n${CYAN}Current Settings:${NC}"

        # Extract current settings
        local bind_port=$(grep "bindPort" "$CONFIG_DIR/frps.toml" | head -1 | awk '{print $3}')
        local token=$(grep "auth.token" "$CONFIG_DIR/frps.toml" | head -1 | awk '{print $3}' | tr -d '"')
        local dashboard_port=$(grep "webServer.port" "$CONFIG_DIR/frps.toml" | head -1 | awk '{print $3}')
        local subdomain=$(grep "subDomainHost" "$CONFIG_DIR/frps.toml" | head -1 | awk '{print $3}' | tr -d '"')
        local max_ports=$(grep "maxPortsPerClient" "$CONFIG_DIR/frps.toml" | head -1 | awk '{print $3}')
        local kcp_enabled=$(grep "kcpBindPort" "$CONFIG_DIR/frps.toml" | head -1 | awk '{print $3}' | wc -l)
        local quic_enabled=$(grep "quicBindPort" "$CONFIG_DIR/frps.toml" | head -1 | awk '{print $3}' | wc -l)

        echo -e "  • ${GREEN}Server Port:${NC} $bind_port"
        echo -e "  • ${GREEN}Token:${NC} ${token:0:8}..."
        [[ -n "$dashboard_port" ]] && echo -e "  • ${GREEN}Dashboard Port:${NC} $dashboard_port"
        echo -e "  • ${GREEN}Subdomain:${NC} $subdomain"
        echo -e "  • ${GREEN}Max Ports:${NC} $max_ports"
        [[ "$kcp_enabled" -gt 0 ]] && echo -e "  • ${GREEN}KCP:${NC} Enabled"
        [[ "$quic_enabled" -gt 0 ]] && echo -e "  • ${GREEN}QUIC:${NC} Enabled"
    fi

    echo -e "\n${CYAN}📝 Configuration Options:${NC}"
    echo "1. 🔑 Change Authentication Token"
    echo "2. 🚪 Change Server Port"
    echo "3. 📊 Modify Dashboard Settings"
    echo "4. 🚀 Advanced Protocol Settings"
    echo "5. 🏷️  Change Subdomain"
    echo "6. 📊 Client Connection Limits"
    echo "7. 🔄 Recreate Configuration (Full Reset)"
    echo "0. Back to Service Management"

    echo -e "\n${YELLOW}Enter your choice [0-7]:${NC} "
    read -r choice

    case $choice in
        1)
            # Change token
            echo -e "\n${CYAN}🔑 Change Authentication Token:${NC}"
            echo -e "${YELLOW}Generate new random token? (Y/n):${NC} "
            read -r auto_token

            local new_token
            if [[ "$auto_token" =~ ^[Nn]$ ]]; then
                while true; do
                    echo -e "${CYAN}Enter new token (minimum 8 characters):${NC} "
                    read -r new_token
                    if [[ ${#new_token} -ge 8 ]]; then
                        break
                    else
                        echo -e "${RED}❌ Token must be at least 8 characters${NC}"
                    fi
                done
            else
                new_token=$(generate_token)
                echo -e "${GREEN}✅ Generated new token: ${new_token:0:8}...${NC}"
            fi

            # Update configuration
            sed -i "s/auth.token = \".*\"/auth.token = \"$new_token\"/" "$CONFIG_DIR/frps.toml"
            echo -e "${GREEN}✅ Token updated successfully${NC}"

            # Restart service if running
            restart_server_services
            ;;
        2)
            # Change port
            echo -e "\n${CYAN}🚪 Change Server Port:${NC}"
            while true; do
                echo -e "${CYAN}Enter new server port:${NC} "
                read -r new_port

                if validate_port "$new_port"; then
                    break
                else
                    echo -e "${RED}❌ Invalid port number${NC}"
                fi
            done

            # Update configuration
            sed -i "s/bindPort = .*/bindPort = $new_port/" "$CONFIG_DIR/frps.toml"
            sed -i "s/kcpBindPort = .*/kcpBindPort = $new_port/" "$CONFIG_DIR/frps.toml"
            echo -e "${GREEN}✅ Server port updated to $new_port${NC}"

            # Restart service
            restart_server_services
            ;;
        3)
            # Dashboard settings
            echo -e "\n${CYAN}📊 Dashboard Settings:${NC}"
            echo -e "${YELLOW}Enable dashboard? (Y/n):${NC} "
            read -r enable_dash

            if [[ "$enable_dash" =~ ^[Nn]$ ]]; then
                # Disable dashboard
                sed -i '/webServer\./d' "$CONFIG_DIR/frps.toml"
                echo -e "${GREEN}✅ Dashboard disabled${NC}"
            else
                # Enable/modify dashboard
                echo -e "${CYAN}Dashboard port (default: 7500):${NC} "
                read -r dash_port
                [[ -z "$dash_port" ]] && dash_port="7500"

                echo -e "${CYAN}Dashboard username (default: admin):${NC} "
                read -r dash_user
                [[ -z "$dash_user" ]] && dash_user="admin"

                echo -e "${CYAN}Dashboard password (leave empty for auto-generated):${NC} "
                read -r dash_pass
                [[ -z "$dash_pass" ]] && dash_pass=$(generate_token | cut -c1-12)

                # Update configuration
                sed -i '/webServer\./d' "$CONFIG_DIR/frps.toml"
                cat >> "$CONFIG_DIR/frps.toml" << EOF

# Dashboard settings
webServer.addr = "0.0.0.0"
webServer.port = $dash_port
webServer.user = "$dash_user"
webServer.password = "$dash_pass"
EOF
                echo -e "${GREEN}✅ Dashboard configured on port $dash_port${NC}"
                echo -e "${GREEN}   Username: $dash_user${NC}"
                echo -e "${GREEN}   Password: $dash_pass${NC}"
            fi

            restart_server_services
            ;;
        4)
            # Advanced protocols
            echo -e "\n${CYAN}🚀 Advanced Protocol Settings:${NC}"
            echo -e "${YELLOW}Enable KCP protocol? (Y/n):${NC} "
            read -r kcp_choice

            echo -e "${YELLOW}Enable QUIC protocol? (y/N):${NC} "
            read -r quic_choice

            # Update KCP
            if [[ "$kcp_choice" =~ ^[Nn]$ ]]; then
                sed -i '/kcpBindPort/d' "$CONFIG_DIR/frps.toml"
                echo -e "${GREEN}✅ KCP disabled${NC}"
            else
                local server_port=$(grep "bindPort" "$CONFIG_DIR/frps.toml" | head -1 | awk '{print $3}')
                if ! grep -q "kcpBindPort" "$CONFIG_DIR/frps.toml"; then
                    echo "kcpBindPort = $server_port" >> "$CONFIG_DIR/frps.toml"
                fi
                echo -e "${GREEN}✅ KCP enabled${NC}"
            fi

            # Update QUIC
            if [[ "$quic_choice" =~ ^[Yy]$ ]]; then
                local server_port=$(grep "bindPort" "$CONFIG_DIR/frps.toml" | head -1 | awk '{print $3}')
                if ! grep -q "quicBindPort" "$CONFIG_DIR/frps.toml"; then
                    echo "quicBindPort = $((server_port + 1))" >> "$CONFIG_DIR/frps.toml"
                fi
                echo -e "${GREEN}✅ QUIC enabled${NC}"
            else
                sed -i '/quicBindPort/d' "$CONFIG_DIR/frps.toml"
                echo -e "${GREEN}✅ QUIC disabled${NC}"
            fi

            restart_server_services
            ;;
        5)
            # Change subdomain
            echo -e "\n${CYAN}🏷️  Change Subdomain:${NC}"
            echo -e "${CYAN}Enter new subdomain (default: moonfrp.local):${NC} "
            read -r new_subdomain
            [[ -z "$new_subdomain" ]] && new_subdomain="moonfrp.local"

            sed -i "s/subDomainHost = \".*\"/subDomainHost = \"$new_subdomain\"/" "$CONFIG_DIR/frps.toml"
            echo -e "${GREEN}✅ Subdomain updated to: $new_subdomain${NC}"

            restart_server_services
            ;;
        6)
            # Client limits
            echo -e "\n${CYAN}📊 Client Connection Limits:${NC}"
            echo -e "${CYAN}Maximum ports per client (default: 10):${NC} "
            read -r max_ports
            [[ -z "$max_ports" ]] && max_ports="10"

            if [[ "$max_ports" =~ ^[0-9]+$ ]]; then
                sed -i "s/maxPortsPerClient = .*/maxPortsPerClient = $max_ports/" "$CONFIG_DIR/frps.toml"
                echo -e "${GREEN}✅ Client limits updated to: $max_ports${NC}"

                restart_server_services
            else
                echo -e "${RED}❌ Invalid number${NC}"
            fi
            ;;
        7)
            # Full reset
            echo -e "\n${CYAN}🔄 Recreate Configuration:${NC}"
            echo -e "${YELLOW}This will delete current configuration and create a new one.${NC}"
            echo -e "${RED}⚠️  Are you sure? (y/N):${NC} "
            read -r confirm_reset

            if [[ "$confirm_reset" =~ ^[Yy]$ ]]; then
                # Stop services
                local services=($(systemctl list-units --type=service --all --no-legend --plain | grep moonfrps | awk '{print $1}' | sed 's/\.service//'))
                for service in "${services[@]}"; do
                    systemctl stop "$service" 2>/dev/null || true
                done

                # Remove config and recreate
                rm -f "$CONFIG_DIR/frps.toml"
                echo -e "${GREEN}✅ Configuration removed${NC}"

                # Call the main creation function
                create_iran_server_config
                return
            else
                echo -e "${YELLOW}Operation cancelled${NC}"
            fi
            ;;
        0)
            return
            ;;
        *)
            echo -e "${RED}❌ Invalid choice${NC}"
            ;;
    esac

    read -p "Press Enter to continue..."
}

# Helper function to restart server services
restart_server_services() {
    local services=($(systemctl list-units --type=service --all --no-legend --plain | grep moonfrps | awk '{print $1}' | sed 's/\.service//'))

    if [[ ${#services[@]} -gt 0 ]]; then
        echo -e "\n${CYAN}🔄 Restarting server services...${NC}"
        for service in "${services[@]}"; do
            systemctl restart "$service" 2>/dev/null && echo -e "${GREEN}✅ Restarted: $service${NC}" || echo -e "${RED}❌ Failed to restart: $service${NC}"
        done
    else
        echo -e "\n${YELLOW}⚠️  No active server services found${NC}"
    fi
}

# Configuration creation menu (optimized)
config_creation_menu() {
    while true; do
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return
        fi

        clear
        echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║            MoonFRP                   ║${NC}"
        echo -e "${PURPLE}║     Quick Configuration Setup       ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

        echo -e "\n${CYAN}Select Configuration Type:${NC}"
        echo -e "${GREEN}1.${NC} ${CYAN}Iran Server${NC} ${YELLOW}(Host FRP server)${NC}"
        echo -e "${GREEN}2.${NC} ${CYAN}Foreign Client${NC} ${YELLOW}(Connect to Iran server)${NC}"
        echo -e "${GREEN}0.${NC} Back to Main Menu"

        echo -e "\n${YELLOW}Choice [0-2]:${NC} "
        read -r choice

        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return
        fi

        [[ -z "$choice" ]] && choice=1

        case $choice in
            1) create_iran_server_config ;;
            2) create_foreign_client_config ;;
            0) return ;;
            *) echo -e "${RED}Invalid choice${NC}"; sleep 1 ;;
        esac
    done
}

# Create Iran server configuration (streamlined)
create_iran_server_config() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║         Iran Server Setup           ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    local token dashboard_user dashboard_password
    local bind_port=7000 dashboard_port=7500 enable_dashboard="y"

    echo -e "\n${CYAN}📝 Server Configuration${NC}"

    # Quick token setup
    echo -e "\n${YELLOW}Auto-generate secure token? (Y/n):${NC} "
    read -r auto_token

    if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
        MENU_STATE["ctrl_c_pressed"]="false"
        return
    fi

    if [[ "$auto_token" =~ ^[Nn]$ ]]; then
        while true; do
            echo -e "${CYAN}Custom token (8+ chars):${NC} "
            read -r token
            if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
                MENU_STATE["ctrl_c_pressed"]="false"
                return
            fi
            [[ ${#token} -ge 8 ]] && break
            echo -e "${RED}Too short${NC}"
        done
    else
        token=$(generate_token)
        echo -e "${GREEN}✅ Token: ${token:0:8}...${NC}"
    fi

    # Port setup
    echo -e "\n${CYAN}Server port (default 7000):${NC} "
    read -r user_bind_port
    if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
        MENU_STATE["ctrl_c_pressed"]="false"
        return
    fi

    if [[ -n "$user_bind_port" ]] && validate_port "$user_bind_port"; then
        bind_port="$user_bind_port"
    fi
    echo -e "${GREEN}✅ Port: $bind_port${NC}"

    # Dashboard setup
    echo -e "\n${CYAN}Enable web dashboard? (Y/n):${NC} "
    read -r enable_dashboard
    if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
        MENU_STATE["ctrl_c_pressed"]="false"
        return
    fi

    if [[ ! "$enable_dashboard" =~ ^[Nn]$ ]]; then
        echo -e "${CYAN}Dashboard port (7500):${NC} "
        read -r user_dashboard_port
        if [[ -n "$user_dashboard_port" ]] && validate_port "$user_dashboard_port" && [[ "$user_dashboard_port" != "$bind_port" ]]; then
            dashboard_port="$user_dashboard_port"
        fi

        echo -e "${CYAN}Username (admin):${NC} "
        read -r dashboard_user
        [[ -z "$dashboard_user" ]] && dashboard_user="admin"

        echo -e "${CYAN}Password (auto):${NC} "
        read -r dashboard_password
        [[ -z "$dashboard_password" ]] && dashboard_password=$(generate_token | cut -c1-12)

        echo -e "${GREEN}✅ Dashboard: $dashboard_user @ :$dashboard_port${NC}"
    else
        dashboard_port=""
        dashboard_user=""
        dashboard_password=""
    fi

    # Use optimized defaults
    local enable_kcp="true" enable_quic="false" custom_subdomain="moonfrp.local" max_clients="0"

    echo -e "\n${CYAN}📋 Summary:${NC}"
    echo -e "  Server Port: ${GREEN}$bind_port${NC}"
    echo -e "  Token: ${GREEN}${token:0:8}...${NC}"
    [[ -n "$dashboard_port" ]] && echo -e "  Dashboard: ${GREEN}$dashboard_user @ :$dashboard_port${NC}"
    echo -e "  Protocols: ${GREEN}All supported${NC}"

    echo -e "\n${YELLOW}Create server? (Y/n):${NC} "
    read -r confirm

    if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
        MENU_STATE["ctrl_c_pressed"]="false"
        return
    fi

    if [[ "$confirm" =~ ^[Nn]$ ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        read -p "Press Enter to continue..."
        return
    fi

    # Check for existing server configurations and services
    local existing_servers=($(systemctl list-units --type=service --all --no-legend --plain 2>/dev/null | grep moonfrps | awk '{print $1}' | sed 's/\.service//'))
    local existing_server_configs=($(ls "$CONFIG_DIR"/frps*.toml 2>/dev/null))

    if [[ ${#existing_servers[@]} -gt 0 ]] || [[ ${#existing_server_configs[@]} -gt 0 ]]; then
        echo -e "\n${YELLOW}⚠️  Existing server configurations detected:${NC}"

        if [[ ${#existing_servers[@]} -gt 0 ]]; then
            echo -e "${CYAN}Server Services:${NC}"
            for server in "${existing_servers[@]}"; do
                local server_status=$(systemctl is-active "$server" 2>/dev/null || echo "inactive")
                echo -e "  • $server: ${server_status}"
            done
        fi

        if [[ ${#existing_server_configs[@]} -gt 0 ]]; then
            echo -e "${CYAN}Server Configuration files:${NC}"
            for config in "${existing_server_configs[@]}"; do
                echo -e "  • $(basename "$config")"
            done
        fi

        echo -e "\n${CYAN}Remove all existing server configurations and services? (Y/n):${NC} "
        read -r remove_existing

        if [[ ! "$remove_existing" =~ ^[Nn]$ ]]; then
            echo -e "${YELLOW}Removing existing server configurations and services...${NC}"

            # Stop and remove services
            for server in "${existing_servers[@]}"; do
                systemctl stop "$server" 2>/dev/null || true
                systemctl disable "$server" 2>/dev/null || true
                rm -f "/etc/systemd/system/${server}.service"
            done

            # Remove config files
            for config in "${existing_server_configs[@]}"; do
                rm -f "$config"
            done

            systemctl daemon-reload
            echo -e "${GREEN}✅ Existing server configurations and services removed${NC}"
        else
            echo -e "${GREEN}Keeping existing server configurations...${NC}"
        fi
    fi

    # Generate configuration with unique filename
    local timestamp=$(date +%s)
    local config_suffix="server-${timestamp}"
    local server_config_file="$CONFIG_DIR/frps_${config_suffix}.toml"

    echo -e "\n${CYAN}🔧 Generating server configuration...${NC}"
    echo -e "${CYAN}Configuration file: ${GREEN}$server_config_file${NC}"

    # Temporarily modify CONFIG_DIR for unique file generation
    local original_config_dir="$CONFIG_DIR"

    if generate_frps_config "$token" "$bind_port" "$dashboard_port" "$dashboard_user" "$dashboard_password" "$enable_kcp" "$enable_quic" "$custom_subdomain" "$max_clients" "$config_suffix"; then
        echo -e "${GREEN}✅ Server configuration generated successfully${NC}"

        # Verify config file was created
        if [[ -f "$server_config_file" && -s "$server_config_file" ]]; then
            echo -e "${GREEN}✅ Configuration file verified: $server_config_file${NC}"
        else
            echo -e "${RED}❌ Configuration file not found or empty${NC}"
            read -p "Press Enter to continue..."
            return
        fi

        # Create systemd service with improved naming (prevent conflicts)
        local timestamp=$(date +%s)
        local random_suffix=$(head -c 4 /dev/urandom | base64 | tr -d '=+/' | head -c4)
        local server_service_name="moonfrps-server-${timestamp}-${random_suffix}"

        # Ensure unique service name
        local counter=1
        while [[ -f "/etc/systemd/system/${server_service_name}.service" ]]; do
            server_service_name="moonfrps-server-${timestamp}-${random_suffix}-${counter}"
            ((counter++))
        done

        # Validate configuration before creating service
        echo -e "\n${CYAN}🔍 Validating server configuration...${NC}"
        if validate_frp_config "$server_config_file"; then
            echo -e "${GREEN}✅ Server configuration validated${NC}"
        else
            echo -e "${RED}❌ Configuration validation failed${NC}"
            read -p "Press Enter to continue..."
            return
        fi

        echo -e "\n${CYAN}🔧 Creating systemd service...${NC}"
        if create_systemd_service "$server_service_name" "frps" "$server_config_file"; then
            echo -e "${GREEN}✅ Service created: $server_service_name${NC}"
        else
            echo -e "${RED}❌ Failed to create service${NC}"
            read -p "Press Enter to continue..."
            return
        fi

        # Start service
        echo -e "\n${CYAN}🚀 Starting service: $server_service_name${NC}"
        if start_service "$server_service_name"; then
            echo -e "${GREEN}✅ Service started successfully${NC}"

            # Wait a moment and check service status
            sleep 3
            local service_status=$(get_service_status "$server_service_name")
            if [[ "$service_status" == "active" ]]; then
                echo -e "${GREEN}✅ Service is running properly${NC}"
            else
                echo -e "${YELLOW}⚠️  Service status: $service_status${NC}"
                echo -e "${CYAN}Checking logs for errors...${NC}"
                journalctl -u "$server_service_name" -n 5 --no-pager
            fi
        else
            echo -e "${RED}❌ Failed to start service${NC}"
            echo -e "${CYAN}Checking logs for errors...${NC}"
            journalctl -u "$server_service_name" -n 10 --no-pager
            read -p "Press Enter to continue..."
            return
        fi

        # Enhanced success summary
        clear
        echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║     🎉 Server Setup Complete!       ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

        echo -e "\n${GREEN}✅ Iran server configuration created successfully!${NC}"

        echo -e "\n${CYAN}📋 Server Information:${NC}"
        echo -e "${GREEN}• Service Name:${NC} $server_service_name"
        echo -e "${GREEN}• Configuration:${NC} $CONFIG_DIR/frps.toml"
        echo -e "${GREEN}• Service Status:${NC} $(get_service_status "$server_service_name")"

        # Get server IP information
        local primary_ip=$(hostname -I | awk '{print $1}')
        # Get public IPv4 addresses (exclude local, private, and IPv6)
        local public_ips=$(hostname -I | tr ' ' '\n' | grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$' | grep -v -E '^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.)' | tr '\n' ',' | sed 's/,$//')
        [[ -z "$public_ips" ]] && public_ips="$primary_ip"

        echo -e "\n${CYAN}🌐 Connection Information:${NC}"
        echo -e "${GREEN}• Server Public IPs:${NC} $public_ips"
        echo -e "${GREEN}• FRP Port:${NC} $bind_port"
        echo -e "${GREEN}• Auth Token:${NC} $token"

        if [[ -n "$dashboard_port" ]]; then
            echo -e "\n${CYAN}📊 Dashboard Access:${NC}"
            echo -e "${GREEN}• URL:${NC} http://$primary_ip:$dashboard_port"
            echo -e "${GREEN}• Username:${NC} $dashboard_user"
            echo -e "${GREEN}• Password:${NC} $dashboard_password"
        fi

        echo -e "\n${CYAN}💡 Next Steps:${NC}"
        echo -e "  1. Configure firewall: ${GREEN}ufw allow $bind_port/tcp${NC}"
        if [[ -n "$dashboard_port" ]]; then
            echo -e "  2. Allow dashboard: ${GREEN}ufw allow $dashboard_port/tcp${NC}"
        fi
        echo -e "  3. Share with clients:"
        echo -e "     ${YELLOW}• Server IPs: $public_ips${NC}"
        echo -e "     ${YELLOW}• Server Port: $bind_port${NC}"
        echo -e "     ${YELLOW}• Token: $token${NC}"

        echo -e "\n${CYAN}🔧 Management Commands:${NC}"
        echo -e "  • Check status: ${GREEN}systemctl status $server_service_name${NC}"
        echo -e "  • View logs: ${GREEN}journalctl -u $server_service_name -f${NC}"
        echo -e "  • Restart: ${GREEN}systemctl restart $server_service_name${NC}"

    else
        echo -e "${RED}❌ Failed to generate server configuration${NC}"
        read -p "Press Enter to continue..."
        return
    fi

    read -p "Press Enter to continue..."
}

# Create foreign client configuration
create_foreign_client_config() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║      Foreign Client Setup           ║${NC}"
    echo -e "${PURPLE}║     (frpc Configuration)             ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    local server_ips server_port token ports proxy_type="tcp"

    echo -e "\n${CYAN}🌍 Client Configuration${NC}"
    echo -e "${GRAY}This will create FRP client configuration for foreign location${NC}"

    # Server Connection Settings
    echo -e "\n${CYAN}🔗 Server Connection Settings:${NC}"

    # Server IP input with validation
    while true; do
        echo -e "${CYAN}Iran Server IP Address:${NC} "
        read -r server_ips

        # Check for Ctrl+C
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return
        fi

        if [[ -z "$server_ips" ]]; then
            echo -e "${RED}❌ Server IP is required${NC}"
            continue
        fi

        if validate_ips_list "$server_ips"; then
            echo -e "${GREEN}✅ Server IP(s) validated: $server_ips${NC}"
            break
        else
            echo -e "${RED}❌ Invalid IP address format${NC}"
            echo -e "${YELLOW}Example: 89.47.198.149 or 89.47.198.149,85.15.65.147${NC}"
        fi
    done

    # Server Port input with validation
    while true; do
        echo -e "${CYAN}Server Port (default: 7000):${NC} "
        read -r server_port
        [[ -z "$server_port" ]] && server_port=7000

        if validate_port "$server_port"; then
            echo -e "${GREEN}✅ Server Port: $server_port${NC}"
            break
        else
            echo -e "${RED}❌ Invalid port number. Please enter a port between 1-65535${NC}"
        fi
    done

    # Authentication Token
    while true; do
        echo -e "${CYAN}Authentication Token:${NC} "
        read -r token

        if [[ -z "$token" ]]; then
            echo -e "${RED}❌ Authentication token is required${NC}"
            continue
        elif [[ ${#token} -lt 8 ]]; then
            echo -e "${RED}❌ Token should be at least 8 characters for security${NC}"
            echo -e "${YELLOW}Continue anyway? (y/N):${NC} "
            read -r continue_token
            if [[ "$continue_token" =~ ^[Yy]$ ]]; then
                break
            fi
        else
            echo -e "${GREEN}✅ Authentication token validated${NC}"
            break
        fi
    done

    # Port Configuration Method
    echo -e "\n${CYAN}🚪 Port Configuration:${NC}"
    echo -e "${YELLOW}How would you like to configure ports?${NC}"
    echo "1. Manual port entry (Recommended)"
    echo "2. Use configuration template"

    local config_method=""
    while true; do
        echo -e "${CYAN}Choose method [1-2] (default: 1):${NC} "
        read -r config_method
        [[ -z "$config_method" ]] && config_method=1

        case $config_method in
            1|2) break ;;
            *) echo -e "${RED}❌ Please enter 1 or 2${NC}" ;;
        esac
    done

    case $config_method in
        1)
            # Manual port configuration
            echo -e "\n${CYAN}📝 Manual Port Configuration:${NC}"
            echo -e "${GRAY}Enter the ports you want to forward from this server${NC}"

            while true; do
                echo -e "${CYAN}Local ports to forward (comma-separated):${NC}"
                echo -e "${YELLOW}Example: 9005,8005,7005 or 22,80,443${NC} "
                read -r ports

                if [[ -z "$ports" ]]; then
                    echo -e "${RED}❌ At least one port is required${NC}"
                    continue
                fi

                if validate_ports_list "$ports"; then
                    echo -e "${GREEN}✅ Ports validated: $ports${NC}"

                    # Show port mapping preview
                    echo -e "\n${CYAN}📋 Port Mapping Preview:${NC}"
                    IFS=',' read -ra PORT_ARRAY <<< "$ports"
                    for port in "${PORT_ARRAY[@]}"; do
                        port=$(echo "$port" | tr -d ' ')
                        echo -e "  ${YELLOW}Local:$port${NC} → ${GREEN}Remote:$port${NC}"
                    done
                    break
                else
                    echo -e "${RED}❌ Invalid port format${NC}"
                    echo -e "${YELLOW}Please use format: port1,port2,port3 (e.g., 22,80,443)${NC}"
                fi
            done
            ;;
        2)
            # Template configuration
            if get_config_template; then
                if confirm_template_configuration; then
                    ports="$TEMPLATE_CONFIG["ports"]"
                    proxy_type="$TEMPLATE_CONFIG["proxy_type"]"
                    echo -e "\n${GREEN}✅ Using template: $TEMPLATE_CONFIG["name"]${NC}"
                    echo -e "${GREEN}✅ Ports configured: $ports${NC}"
                else
                    log "INFO" "Template configuration cancelled"
                    read -p "Press Enter to continue..."
                    return
                fi
            else
                log "INFO" "Template selection cancelled"
                read -p "Press Enter to continue..."
                return
            fi
            ;;
    esac

    # Proxy Type Selection (if not from template)
    if [[ $config_method -eq 1 ]]; then
        echo -e "\n${CYAN}🔌 Proxy Type Selection:${NC}"
        echo -e "${YELLOW}What type of traffic will you forward?${NC}"
        echo "1. TCP (Default - for SSH, databases, games, etc.)"
        echo "2. HTTP (Web services with domain names)"
        echo "3. HTTPS (Secure web services)"
        echo "4. UDP (Games, DNS, streaming)"
        echo "5. TCPMUX (TCP multiplexing over HTTP CONNECT)"
        echo "6. STCP (Secret TCP - P2P secure tunneling)"
        echo "7. SUDP (Secret UDP - P2P secure tunneling)"
        echo "8. TCPMUX-Direct (TCP-like access with TCPMUX benefits)"
        echo "9. XTCP (P2P TCP - Direct peer-to-peer connection)"
        echo "10. Plugin System (Unix sockets, HTTP/SOCKS5 proxy, Static files)"

        local proxy_choice=""
        while true; do
            echo -e "${CYAN}Choose proxy type [1-10] (default: 1):${NC} "
            read -r proxy_choice
            [[ -z "$proxy_choice" ]] && proxy_choice=1

            case $proxy_choice in
                1) proxy_type="tcp"; echo -e "${GREEN}✅ TCP proxy selected${NC}"; break ;;
                2) proxy_type="http"; echo -e "${GREEN}✅ HTTP proxy selected${NC}"; break ;;
                3) proxy_type="https"; echo -e "${GREEN}✅ HTTPS proxy selected${NC}"; break ;;
                4) proxy_type="udp"; echo -e "${GREEN}✅ UDP proxy selected${NC}"; break ;;
                5) proxy_type="tcpmux"; echo -e "${GREEN}✅ TCPMUX proxy selected${NC}"; break ;;
                6) proxy_type="stcp"; echo -e "${GREEN}✅ STCP proxy selected${NC}"; break ;;
                7) proxy_type="sudp"; echo -e "${GREEN}✅ SUDP proxy selected${NC}"; break ;;
                8) proxy_type="tcpmux-direct"; echo -e "${GREEN}✅ TCPMUX-Direct proxy selected${NC}"; break ;;
                9) proxy_type="xtcp"; echo -e "${GREEN}✅ XTCP proxy selected${NC}"; break ;;
                10)
                    echo -e "\n${CYAN}Plugin Type Selection:${NC}"
                    echo "1. Unix Domain Socket"
                    echo "2. HTTP Proxy"
                    echo "3. SOCKS5 Proxy"
                    echo "4. Static File Server"
                    echo "5. HTTPS2HTTP"
                    echo "6. HTTP2HTTPS"
                    echo "7. Virtual Network (VNet)"
                    read -p "Choose plugin [1-7]: " plugin_choice
                    case $plugin_choice in
                        1) proxy_type="plugin_unix_socket"; echo -e "${GREEN}✅ Unix Domain Socket plugin selected${NC}"; break ;;
                        2) proxy_type="plugin_http_proxy"; echo -e "${GREEN}✅ HTTP Proxy plugin selected${NC}"; break ;;
                        3) proxy_type="plugin_socks5"; echo -e "${GREEN}✅ SOCKS5 Proxy plugin selected${NC}"; break ;;
                        4) proxy_type="plugin_static_file"; echo -e "${GREEN}✅ Static File Server plugin selected${NC}"; break ;;
                        5) proxy_type="plugin_https2http"; echo -e "${GREEN}✅ HTTPS2HTTP plugin selected${NC}"; break ;;
                        6) proxy_type="plugin_http2https"; echo -e "${GREEN}✅ HTTP2HTTPS plugin selected${NC}"; break ;;
                        7) proxy_type="plugin_virtual_net"; echo -e "${GREEN}✅ Virtual Network plugin selected${NC}"; break ;;
                        *) echo -e "${RED}❌ Invalid plugin choice${NC}"; continue ;;
                    esac
                    break ;;
                *) echo -e "${RED}❌ Please enter 1, 2, 3, 4, 5, 6, 7, 8, 9, or 10${NC}" ;;
            esac
        done
    fi

    # 🚀 Transport Protocol Selection
    echo -e "\n${CYAN}🚀 Transport Protocol Configuration:${NC}"
    echo -e "${YELLOW}Select transport protocol for client connections${NC}"
    configure_transport_protocol

    # 🚀 Bandwidth Configuration
    echo -e "\n${CYAN}📊 Bandwidth Configuration:${NC}"
    echo -e "${YELLOW}Configure bandwidth limits (optional)${NC}"
    configure_global_bandwidth

    # Custom domains for HTTP/HTTPS/TCPMUX
    local custom_domains=""
    if [[ "$proxy_type" == "http" || "$proxy_type" == "https" || "$proxy_type" == "tcpmux" ]]; then
        echo -e "\n${CYAN}🌐 Domain Configuration:${NC}"
        echo -e "${YELLOW}Configure custom domains? (y/N):${NC} "
        read -r use_domains

        if [[ "$use_domains" =~ ^[Yy]$ ]]; then
            get_custom_domains "$ports"
            custom_domains="$CUSTOM_DOMAINS"
        fi
    fi

    # Configuration Summary
    echo -e "\n${CYAN}📋 Configuration Summary:${NC}"
    echo -e "${GRAY}┌─────────────────────────────────────────────────┐${NC}"
    echo -e "${GRAY}│${NC} ${GREEN}Server IP(s):${NC} $server_ips"
    echo -e "${GRAY}│${NC} ${GREEN}Server Port:${NC} $server_port"
    echo -e "${GRAY}│${NC} ${GREEN}Auth Token:${NC} ${token:0:8}..."
    echo -e "${GRAY}│${NC} ${GREEN}Proxy Type:${NC} $proxy_type"
    echo -e "${GRAY}│${NC} ${GREEN}Transport Protocol:${NC} $GLOBAL_TRANSPORT_PROTOCOL"
    echo -e "${GRAY}│${NC} ${GREEN}Ports:${NC} $ports"
    if [[ -n "$custom_domains" ]]; then
        echo -e "${GRAY}│${NC} ${GREEN}Domains:${NC} $custom_domains"
    fi
    if [[ "$GLOBAL_BANDWIDTH_PROFILE" != "none" ]]; then
        echo -e "${GRAY}│${NC} ${GREEN}Bandwidth Profile:${NC} $GLOBAL_BANDWIDTH_PROFILE"
    fi
    echo -e "${GRAY}└─────────────────────────────────────────────────┘${NC}"

    echo -e "\n${YELLOW}Proceed with this configuration? (Y/n):${NC} "
    read -r confirm
    if [[ "$confirm" =~ ^[Nn]$ ]]; then
        log "INFO" "Configuration cancelled by user"
        read -p "Press Enter to continue..."
        return
    fi

    # Check for existing client configurations and services
    local existing_clients=($(systemctl list-units --type=service --all --no-legend --plain 2>/dev/null | grep moonfrpc | awk '{print $1}' | sed 's/\.service//'))
    local existing_configs=($(ls "$CONFIG_DIR"/frpc_*.toml "$CONFIG_DIR"/frpc_visitor_*.toml 2>/dev/null))

    if [[ ${#existing_clients[@]} -gt 0 ]] || [[ ${#existing_configs[@]} -gt 0 ]]; then
        echo -e "\n${YELLOW}⚠️  Existing client configurations detected:${NC}"

        if [[ ${#existing_clients[@]} -gt 0 ]]; then
            echo -e "${CYAN}Client Services:${NC}"
            for client in "${existing_clients[@]}"; do
                local client_status=$(systemctl is-active "$client" 2>/dev/null || echo "inactive")
                echo -e "  • $client: ${client_status}"
            done
        fi

        if [[ ${#existing_configs[@]} -gt 0 ]]; then
            echo -e "${CYAN}Client Configuration files:${NC}"
            for config in "${existing_configs[@]}"; do
                echo -e "  • $(basename "$config")"
            done
        fi

        echo -e "\n${CYAN}Remove all existing client configurations and services? (Y/n):${NC} "
        read -r remove_existing

        if [[ ! "$remove_existing" =~ ^[Nn]$ ]]; then
            echo -e "${YELLOW}Removing existing client configurations and services...${NC}"

            # Stop and remove services
            for client in "${existing_clients[@]}"; do
                systemctl stop "$client" 2>/dev/null || true
                systemctl disable "$client" 2>/dev/null || true
                rm -f "/etc/systemd/system/${client}.service"
            done

            # Remove config files (including visitor configs)
            for config in "${existing_configs[@]}"; do
                rm -f "$config"
            done

            # Also clean up log files
            rm -f "$LOG_DIR"/frpc_*.log "$LOG_DIR"/frpc_visitor_*.log

            systemctl daemon-reload
            echo -e "${GREEN}✅ Existing client configurations and services removed${NC}"
        else
            echo -e "${GREEN}Keeping existing client configurations...${NC}"
        fi
    fi

    # Server Connection Validation
    echo -e "\n${CYAN}🔍 Validating server connections...${NC}"
    IFS=',' read -ra IP_ARRAY <<< "$server_ips"
    local connection_failed=false

    for ip in "${IP_ARRAY[@]}"; do
        ip=$(echo "$ip" | tr -d ' ')
        echo -e "${CYAN}Testing connection to $ip:$server_port...${NC}"

        if validate_server_connection "$ip" "$server_port"; then
            echo -e "${GREEN}✅ Connection successful${NC}"
        else
            echo -e "${RED}❌ Connection failed${NC}"
            connection_failed=true
        fi
    done

    if [[ "$connection_failed" == "true" ]]; then
        echo -e "\n${YELLOW}⚠️  Some server connections failed${NC}"
        echo -e "${CYAN}This might be due to:${NC}"
        echo -e "  • Server not running or not accessible"
        echo -e "  • Firewall blocking the connection"
        echo -e "  • Incorrect IP or port"
        echo -e "\n${YELLOW}Continue anyway? (y/N):${NC} "
        read -r continue_anyway
        if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
            log "INFO" "Configuration cancelled due to connection issues"
            read -p "Press Enter to continue..."
            return
        fi
    fi

    # Process each IP with progress indicator
    echo -e "\n${CYAN}🚀 Creating configurations...${NC}"
    local config_count=0
    local failed_count=0
    local total_ips=${#IP_ARRAY[@]}
    local current_ip=0

    for ip in "${IP_ARRAY[@]}"; do
        ip=$(echo "$ip" | tr -d ' ')
        ((current_ip++))
        local ip_suffix=$(echo "$ip" | cut -d'.' -f4)

        echo -e "\n${CYAN}[$current_ip/$total_ips] Processing IP: $ip${NC}"

        # Generate client configuration
        if generate_frpc_config "$ip" "$server_port" "$token" "$ip" "$ports" "$ip_suffix" "$proxy_type" "$custom_domains" "$GLOBAL_TRANSPORT_PROTOCOL"; then
            echo -e "${GREEN}✅ Configuration generated${NC}"

            # Verbose configuration output
            echo -e "${CYAN}📋 Configuration Details:${NC}"
            echo -e "  ${GREEN}Config File:${NC} $CONFIG_DIR/frpc_${ip_suffix}.toml"
            echo -e "  ${GREEN}Server:${NC} $ip:$server_port"
            echo -e "  ${GREEN}Protocol:${NC} $proxy_type"
            echo -e "  ${GREEN}Ports:${NC} $ports"
            if [[ -n "$custom_domains" ]]; then
                echo -e "  ${GREEN}Domains:${NC} $custom_domains"
            fi
            echo -e "  ${GREEN}Service:${NC} moonfrpc-${ip_suffix}"
            echo -e "  ${GREEN}Log:${NC} $LOG_DIR/frpc_${ip_suffix}.log"
            if [[ "$proxy_type" == "stcp" || "$proxy_type" == "xtcp" ]]; then
                echo -e "  ${GREEN}Visitor Config:${NC} $CONFIG_DIR/frpc_visitor_${ip_suffix}.toml"
                echo -e "  ${GREEN}Visitor Log:${NC} $LOG_DIR/frpc_visitor_${ip_suffix}.log"
            fi

            # Create systemd service with improved naming (prevent conflicts)
            local client_timestamp=$(date +%s)
            local client_random=$(head -c 4 /dev/urandom | base64 | tr -d '=+/' | head -c4)
            local client_service_name="moonfrpc-client-${ip_suffix}-${client_timestamp}-${client_random}"

            # Ensure unique service name
            local client_counter=1
            while [[ -f "/etc/systemd/system/${client_service_name}.service" ]]; do
                client_service_name="moonfrpc-client-${ip_suffix}-${client_timestamp}-${client_random}-${client_counter}"
                ((client_counter++))
            done
            if create_systemd_service "$client_service_name" "frpc" "$CONFIG_DIR/frpc_${ip_suffix}.toml" "$ip_suffix"; then
                echo -e "${GREEN}✅ Service created: $client_service_name${NC}"
            else
                echo -e "${RED}❌ Failed to create service${NC}"
                ((failed_count++))
                continue
            fi

            # Start service
            if start_service "$client_service_name"; then
                ((config_count++))
                echo -e "${GREEN}✅ Service started successfully${NC}"
            else
                ((failed_count++))
                echo -e "${RED}❌ Failed to start service${NC}"
            fi
        else
            ((failed_count++))
            echo -e "${RED}❌ Failed to generate configuration${NC}"
        fi
    done

    # Configuration Results Summary
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║    🎉 Client Setup Complete!        ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    echo -e "\n${CYAN}📊 Configuration Results:${NC}"
    echo -e "${GREEN}✅ Successful:${NC} $config_count"
    echo -e "${RED}❌ Failed:${NC} $failed_count"
    echo -e "${CYAN}📋 Proxy Type:${NC} $proxy_type"
    echo -e "${CYAN}🚪 Ports:${NC} $ports"

    if [[ $config_count -gt 0 ]]; then
        echo -e "\n${GREEN}✅ Created $config_count client configuration(s) successfully!${NC}"

        # Show service status
        echo -e "\n${CYAN}📋 Service Status:${NC}"
        echo -e "${GRAY}┌─────────────────────────────────────────────────┐${NC}"
        printf "${GRAY}│${NC} %-20s %-15s %-10s ${GRAY}│${NC}\n" "Service" "Server IP" "Status"
        echo -e "${GRAY}├─────────────────────────────────────────────────┤${NC}"

        for ip in "${IP_ARRAY[@]}"; do
            ip=$(echo "$ip" | tr -d ' ')
            local ip_suffix=$(echo "$ip" | cut -d'.' -f4)
            local service_name="moonfrpc-$ip_suffix"
            local service_status=$(get_service_status "$service_name")
            local status_icon="❌"
            local status_color="$RED"

            if [[ "$service_status" == "active" ]]; then
                status_icon="✅"
                status_color="$GREEN"
            fi

            printf "${GRAY}│${NC} %-20s %-15s ${status_color}%-10s${NC} ${GRAY}│${NC}\n" \
                "$service_name" "$ip" "$service_status"
        done
        echo -e "${GRAY}└─────────────────────────────────────────────────┘${NC}"

        # Show access information
        echo -e "\n${CYAN}🌐 Access Information:${NC}"
        IFS=',' read -ra PORT_ARRAY <<< "$ports"

        for port in "${PORT_ARRAY[@]}"; do
            port=$(echo "$port" | tr -d ' ')
            echo -e "${GREEN}Port $port:${NC}"

            case "$proxy_type" in
                "tcp"|"udp")
                    echo -e "  • Access via: ${YELLOW}${IP_ARRAY[0]}:$port${NC}"
                    ;;
                "http"|"https")
                    if [[ -n "$custom_domains" ]]; then
                        IFS=',' read -ra DOMAIN_ARRAY <<< "$custom_domains"
                        local port_index=0
                        for domain in "${DOMAIN_ARRAY[@]}"; do
                            domain=$(echo "$domain" | tr -d ' ')
                            echo -e "  • Access via: ${YELLOW}$proxy_type://$domain${NC}"
                            break
                        done
                    else
                        echo -e "  • Access via: ${YELLOW}$proxy_type://app${port}.moonfrp.local${NC}"
                    fi
                    ;;
                "tcpmux")
                    if [[ -n "$custom_domains" ]]; then
                        IFS=',' read -ra DOMAIN_ARRAY <<< "$custom_domains"
                        local port_index=0
                        for domain in "${DOMAIN_ARRAY[@]}"; do
                            domain=$(echo "$domain" | tr -d ' ')
                            echo -e "  • Access via: ${YELLOW}HTTP CONNECT to $domain${NC}"
                            break
                        done
                    else
                        echo -e "  • Access via: ${YELLOW}HTTP CONNECT to tunnel${port}${NC}"
                    fi
                    ;;
                "stcp"|"sudp")
                    echo -e "  • ${YELLOW}Secure P2P tunnel - requires visitor configuration${NC}"
                    echo -e "  • Check config file for visitor setup instructions"
                    ;;
                "xtcp")
                    echo -e "  • ${YELLOW}P2P TCP with NAT traversal - requires visitor configuration${NC}"
                    echo -e "  • Direct P2P connection with automatic fallback"
                    echo -e "  • Check config file for visitor setup instructions"
                    ;;
                "plugin_"*)
                    local plugin_name="${proxy_type#plugin_}"
                    echo -e "  • ${YELLOW}Plugin: ${plugin_name}${NC}"
                    case "$plugin_name" in
                        "unix_socket") echo -e "  • Unix domain socket forwarding" ;;
                        "http_proxy") echo -e "  • HTTP proxy server with authentication" ;;
                        "socks5") echo -e "  • SOCKS5 proxy server with authentication" ;;
                        "static_file") echo -e "  • Static file server with authentication" ;;
                        "https2http") echo -e "  • HTTPS to HTTP converter" ;;
                        "http2https") echo -e "  • HTTP to HTTPS converter" ;;
                        "virtual_net") echo -e "  • Virtual network for direct client communication" ;;
                    esac
                    echo -e "  • Check config file for plugin usage instructions"
                    ;;
            esac
        done

        echo -e "\n${CYAN}🔧 Management Commands:${NC}"
        echo -e "  • Check all services: ${GREEN}systemctl status moonfrpc-*${NC}"
        echo -e "  • View logs: ${GREEN}journalctl -u moonfrpc-* -f${NC}"
        echo -e "  • Restart all: ${GREEN}systemctl restart moonfrpc-*${NC}"
        echo -e "  • Stop all: ${GREEN}systemctl stop moonfrpc-*${NC}"

        echo -e "\n${YELLOW}💡 Troubleshooting:${NC}"
        echo -e "  • Use menu option 5 for detailed diagnostics"
        echo -e "  • Verify server is running and accessible"
        echo -e "  • Check firewall settings on both ends"

        if [[ $failed_count -gt 0 ]]; then
            echo -e "\n${RED}⚠️  Some configurations failed:${NC}"
            echo -e "  • Check server connectivity"
            echo -e "  • Verify authentication token"
            echo -e "  • Review service logs for details"
        fi
    fi

    read -p "Press Enter to continue..."
}

# Service removal menu
service_removal_menu() {
    while true; do
        clear
        echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║            MoonFRP                   ║${NC}"
        echo -e "${PURPLE}║        Service Removal               ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

        list_frp_services

        echo -e "\n${CYAN}Removal Options:${NC}"
        echo "1. Remove Single Service"
        echo "2. Remove All Services"
        echo "0. Back to Main Menu"

        echo -e "\n${YELLOW}Enter your choice [0-2]:${NC} "
        read -r choice

        case $choice in
            1) remove_single_service ;;
            2) remove_all_services ;;
            0) return ;;
            *) log "WARN" "Invalid choice. Please try again." ;;
        esac
    done
}

# Remove service menu (includes both single and all)

# Remove single service
remove_single_service() {
    local services=($(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//'))

    if [[ ${#services[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No FRP services found${NC}"
        read -p "Press Enter to continue..."
        return
    fi

    echo -e "\n${CYAN}Select service to remove:${NC}"
    local i=1
    for service in "${services[@]}"; do
        echo "$i. $service"
        ((i++))
    done

    echo -e "\n${YELLOW}Select service number:${NC} "
    read -r service_num

    if [[ ! "$service_num" =~ ^[0-9]+$ ]] || [[ $service_num -lt 1 ]] || [[ $service_num -gt ${#services[@]} ]]; then
        log "ERROR" "Invalid service number. Please enter a number between 1-${#services[@]}"
        read -p "Press Enter to continue..."
        return
    fi

    local selected_service="${services[$((service_num-1))]}"
    if [[ -z "$selected_service" ]]; then
        log "ERROR" "Selected service is empty or invalid"
        read -p "Press Enter to continue..."
        return
    fi

    echo -e "\n${RED}Are you sure you want to remove service '$selected_service'? (y/N):${NC} "
    read -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        remove_service "$selected_service"
        log "INFO" "Service '$selected_service' removed successfully"
    else
        log "INFO" "Service removal cancelled"
    fi

    read -p "Press Enter to continue..."
}

# Setup cron job for auto-restart services
setup_cron_job() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║            MoonFRP                   ║${NC}"
    echo -e "${PURPLE}║       Setup Cron Job                ║${NC}"
    echo -e "${PURPLE}║    (Auto-restart Services)           ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    local services=($(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//'))

    if [[ ${#services[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No FRP services found${NC}"
        read -p "Press Enter to continue..."
        return
    fi

    echo -e "\n${CYAN}📋 Available Services:${NC}"
    list_frp_services

    echo -e "\n${CYAN}Select service to setup cron job:${NC}"
    local i=1
    for service in "${services[@]}"; do
        echo "$i. $service"
        ((i++))
    done
    echo "$i. Setup for ALL services"

    echo -e "\n${YELLOW}Select service number:${NC} "
    read -r service_num

    local selected_services=()
    if [[ "$service_num" == "$i" ]]; then
        # All services
        selected_services=("${services[@]}")
        echo -e "${GREEN}✅ Selected: ALL services${NC}"
    elif [[ "$service_num" =~ ^[0-9]+$ ]] && [[ $service_num -ge 1 ]] && [[ $service_num -le ${#services[@]} ]]; then
        selected_services=("${services[$((service_num-1))]}")
        echo -e "${GREEN}✅ Selected: ${selected_services[0]}${NC}"
    else
        log "ERROR" "Invalid service number"
        read -p "Press Enter to continue..."
        return
    fi

    # Select cron schedule
    echo -e "\n${CYAN}🕐 Select Auto-restart Schedule:${NC}"
    echo -e "${YELLOW}How often should the service(s) be checked and restarted if needed?${NC}"
    echo ""
    echo "1. Every 30 minutes"
    echo "2. Every 1 hour"
    echo "3. Every 2 hours"
    echo "4. Every 6 hours"
    echo "5. Every 12 hours"
    echo "6. Every 24 hours"
    echo "0. Cancel"

    echo -e "\n${YELLOW}Select schedule [0-6]:${NC} "
    read -r schedule_choice

    local cron_schedule=""
    local schedule_desc=""

    case $schedule_choice in
        1)
            cron_schedule="*/30 * * * *"
            schedule_desc="Every 30 minutes"
            ;;
        2)
            cron_schedule="0 * * * *"
            schedule_desc="Every 1 hour"
            ;;
        3)
            cron_schedule="0 */2 * * *"
            schedule_desc="Every 2 hours"
            ;;
        4)
            cron_schedule="0 */6 * * *"
            schedule_desc="Every 6 hours"
            ;;
        5)
            cron_schedule="0 */12 * * *"
            schedule_desc="Every 12 hours"
            ;;
        6)
            cron_schedule="0 0 * * *"
            schedule_desc="Every 24 hours (midnight)"
            ;;
        0)
            echo -e "${YELLOW}Cron job setup cancelled${NC}"
            read -p "Press Enter to continue..."
            return
            ;;
        *)
            log "ERROR" "Invalid schedule choice"
            read -p "Press Enter to continue..."
            return
            ;;
    esac

    # Show summary and confirm
    echo -e "\n${CYAN}📋 Cron Job Summary:${NC}"
    echo -e "  ${GREEN}Services:${NC} ${#selected_services[@]} service(s)"
    for svc in "${selected_services[@]}"; do
        echo -e "    • $svc"
    done
    echo -e "  ${GREEN}Schedule:${NC} $schedule_desc"
    echo -e "  ${GREEN}Cron Pattern:${NC} $cron_schedule"
    echo -e "  ${GREEN}Action:${NC} Check and restart if not active"

    echo -e "\n${YELLOW}⚠️  This will add entries to root's crontab${NC}"
    echo -e "${YELLOW}Create cron job(s)? (y/N):${NC} "
    read -r confirm_cron

    if [[ ! "$confirm_cron" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Cron job setup cancelled${NC}"
        read -p "Press Enter to continue..."
        return
    fi

    # Create cron job entries
    echo -e "\n${CYAN}🔧 Setting up cron job(s)...${NC}"

    # Create backup of current crontab
    crontab -l > /tmp/moonfrp_crontab_backup_$(date +%s) 2>/dev/null || true

    # Create temporary crontab file
    local temp_crontab="/tmp/moonfrp_new_crontab_$(date +%s)"

    # Get current crontab (excluding old MoonFRP entries)
    crontab -l 2>/dev/null | grep -v "# MoonFRP Auto-restart" > "$temp_crontab" || true

    # Add new entries
    echo "" >> "$temp_crontab"
    echo "# MoonFRP Auto-restart Jobs - Generated $(date)" >> "$temp_crontab"

    for service in "${selected_services[@]}"; do
        local cron_command="systemctl is-active $service >/dev/null || systemctl restart $service"
        echo "$cron_schedule $cron_command # MoonFRP Auto-restart: $service" >> "$temp_crontab"
        echo -e "${GREEN}✅ Added cron job for: $service${NC}"
    done

    # Install new crontab
    if crontab "$temp_crontab"; then
        echo -e "\n${GREEN}✅ Cron job(s) installed successfully!${NC}"

        # Show current MoonFRP cron jobs
        echo -e "\n${CYAN}📋 Current MoonFRP Cron Jobs:${NC}"
        crontab -l | grep "MoonFRP Auto-restart" | while read -r line; do
            echo -e "  ${YELLOW}$line${NC}"
        done

        echo -e "\n${CYAN}💡 Management Commands:${NC}"
        echo -e "  • View all cron jobs: ${GREEN}crontab -l${NC}"
        echo -e "  • Edit cron jobs: ${GREEN}crontab -e${NC}"
        echo -e "  • Remove all cron jobs: ${GREEN}crontab -r${NC}"

        log "INFO" "Cron job(s) created successfully for ${#selected_services[@]} service(s)"
    else
        echo -e "\n${RED}❌ Failed to install cron job(s)${NC}"
        log "ERROR" "Failed to install crontab"
    fi

    # Cleanup
    rm -f "$temp_crontab"

    read -p "Press Enter to continue..."
}

# Remove all services
remove_all_services() {
    local services=($(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//'))

    if [[ ${#services[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No FRP services found${NC}"
        read -p "Press Enter to continue..."
        return
    fi

    echo -e "\n${RED}Are you sure you want to remove ALL FRP services? This cannot be undone! (y/N):${NC} "
    read -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "\n${CYAN}Removing all FRP services...${NC}"
        for service in "${services[@]}"; do
            remove_service "$service"
        done

        # Final cleanup and daemon reload
        echo -e "\n${CYAN}Performing final cleanup...${NC}"
        systemctl daemon-reload

        log "INFO" "All FRP services removed successfully"
    else
        log "INFO" "Service removal cancelled"
    fi

    read -p "Press Enter to continue..."
}

# Remove service function
remove_service() {
    local service_name="$1"

    # Stop and disable service with improved error handling
    echo -e "${CYAN}Stopping service: $service_name${NC}"
    systemctl stop "$service_name" 2>/dev/null || true
    systemctl disable "$service_name" 2>/dev/null || true

    # Remove service file
    local service_file="$SERVICE_DIR/${service_name}.service"
    if [[ -f "$service_file" ]]; then
        rm -f "$service_file"
        echo -e "${GREEN}✅ Removed service file: $service_file${NC}"
    fi

    # Remove configuration file
    if [[ "$service_name" =~ (frps|moonfrps) ]]; then
        if [[ -f "$CONFIG_DIR/frps.toml" ]]; then
            rm -f "$CONFIG_DIR/frps.toml"
            echo -e "${GREEN}✅ Removed server configuration: $CONFIG_DIR/frps.toml${NC}"
        fi
    elif [[ "$service_name" =~ (frpc|moonfrpc) ]]; then
        local config_pattern="$CONFIG_DIR/frpc_*.toml"
        for config_file in $config_pattern; do
            if [[ -f "$config_file" ]]; then
                rm -f "$config_file"
                echo -e "${GREEN}✅ Removed client configuration: $config_file${NC}"
            fi
        done
    fi

    # Reload systemd daemon
    echo -e "${CYAN}Reloading systemd daemon...${NC}"
    systemctl daemon-reload

    # Clear all performance caches
    clear_performance_caches

    log "INFO" "Successfully removed service: $service_name"
}

# Fast FRP installation check with caching
check_frp_installation_cached() {
    if [[ -z "${CACHE_DATA["frp_installation"]}" ]]; then
        if [[ -f "$FRP_DIR/frps" ]] && [[ -f "$FRP_DIR/frpc" ]]; then
            CACHE_DATA["frp_installation"]="installed"
        else
            CACHE_DATA["frp_installation"]="not_installed"
        fi
    fi

    [[ "${CACHE_DATA["frp_installation"]}" == "installed" ]]
}

# Check updates only once per session
check_updates_cached() {
    if [[ "${CACHE_DATA["update_check_done"]}" == "false" ]]; then
        CACHE_DATA["update_check_done"]="true"

        # Run update check in background to avoid blocking
        (
            local update_status=0
            check_moonfrp_updates >/dev/null 2>&1
            update_status=$?

            if [[ $update_status -eq 0 ]]; then
                CACHE_DATA["last_update_check"]="available"
            else
                CACHE_DATA["last_update_check"]="none"
            fi
        ) &

        # Don't wait for background process
        disown
    fi
}

# Main menu
main_menu() {
    # Initialize cached values on first run
    [[ -z "${CACHE_DATA["frp_installation"]}" ]] && check_frp_installation_cached >/dev/null
    [[ "${CACHE_DATA["update_check_done"]}" == "false" ]] && check_updates_cached

    # Set main menu depth
    MENU_STATE["depth"]="0"
    MENU_STATE["stack"]=""

    # Add safety check to prevent infinite loops
    local menu_iterations=0
    local max_iterations=1000

    while true; do
        # Check for Ctrl+C in main menu
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            echo -e "\n${GREEN}Thank you for using MoonFRP! 🚀${NC}"
            cleanup_and_exit
        fi

        # Safety check
        ((menu_iterations++))
        if [[ $menu_iterations -gt $max_iterations ]]; then
            log "ERROR" "Menu exceeded maximum iterations, exiting..."
            cleanup_and_exit
        fi
        # Fast clear with optimized escape sequences
        printf '\033[2J\033[H'
        echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║            MoonFRP                   ║${NC}"
        echo -e "${PURPLE}║    Advanced FRP Management Tool     ║${NC}"
        echo -e "${PURPLE}║          Version $MOONFRP_VERSION              ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

        # Show FRP installation status (cached)
        if check_frp_installation_cached; then
            echo -e "\n${GREEN}✅ FRP Status: Installed${NC}"
        else
            echo -e "\n${RED}❌ FRP Status: Not Installed${NC}"
        fi

        # Show update notification only if available (non-blocking)
        if [[ "${CACHE_DATA["last_update_check"]}" == "available" ]]; then
            echo -e "\n${YELLOW}🔔 Update Available!${NC} ${GREEN}A new version of MoonFRP is available${NC}"
            echo -e "${CYAN}   Use menu option 6 to update${NC}"
        fi

        echo -e "\n${CYAN}Main Menu:${NC}"
        echo "1. Create FRP Configuration"
        echo "2. Service Management"
        echo "3. Download & Install FRP v$FRP_VERSION"
        echo "4. Install from Local Archive"
        echo "5. Troubleshooting & Diagnostics"
        echo "6. Update MoonFRP Script"
        echo "7. About & Version Info"
        echo "8. Configuration Summary"
        echo "0. Exit"

        # Show performance info in debug mode
        if [[ "${DEBUG:-}" == "1" ]]; then
            local service_count=0
            if [[ -n "${CACHE_DATA["services"]}" ]]; then
                service_count=$(echo "${CACHE_DATA["services"]}" | wc -l)
            fi
            echo -e "\n${GRAY}[Debug] Menu load time: $(date +%T) | Services cached: $service_count | FRP status: ${CACHE_DATA["frp_installation"]}${NC}"
        fi

        echo -e "\n${YELLOW}Enter your choice [0-9]:${NC} "
        read -r choice

        case $choice in
            1)
                enter_submenu "config_creation"
                config_creation_menu
                exit_submenu
                ;;
            2)
                enter_submenu "service_management"
                service_management_menu
                exit_submenu
                ;;
            3)
                enter_submenu "download_install"
                download_and_install_frp
                exit_submenu
                read -p "Press Enter to continue..."
                ;;
            4)
                enter_submenu "install_local"
                install_from_local
                exit_submenu
                read -p "Press Enter to continue..."
                ;;
            5)
                enter_submenu "troubleshooting"
                troubleshooting_menu
                exit_submenu
                ;;
            6)
                enter_submenu "update_script"
                update_moonfrp_script
                exit_submenu
                read -p "Press Enter to continue..."
                ;;
            7)
                enter_submenu "about_info"
                show_about_info
                exit_submenu
                read -p "Press Enter to continue..."
                ;;
            8)
                enter_submenu "config_summary"
                show_current_config_summary
                exit_submenu
                read -p "Press Enter to continue..."
                ;;
            0)
                echo -e "\n${GREEN}Thank you for using MoonFRP! 🚀${NC}"
                cleanup_and_exit
                ;;
            *)
                log "WARN" "Invalid choice. Please try again."
                sleep 1
                ;;
        esac
    done
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        log "ERROR" "This script must be run as root"
        exit 1
    fi
}

# Check dependencies
check_dependencies() {
    local deps=("curl" "tar" "systemctl" "openssl")
    local optional_deps=("netstat" "nc")
    local missing_deps=()
    local missing_optional=()

    # Check required dependencies
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_deps+=("$dep")
        fi
    done

    # Check optional dependencies
    for dep in "${optional_deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_optional+=("$dep")
        fi
    done

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log "ERROR" "Missing required dependencies: ${missing_deps[*]}"
        log "INFO" "Please install missing dependencies and try again"
        log "INFO" "Ubuntu/Debian: sudo apt install ${missing_deps[*]}"
        log "INFO" "CentOS/RHEL: sudo yum install ${missing_deps[*]}"
        exit 1
    fi

    if [[ ${#missing_optional[@]} -gt 0 ]]; then
        log "WARN" "Missing optional dependencies: ${missing_optional[*]}"
        log "WARN" "Some features may not work properly"
        log "INFO" "Install with: sudo apt install ${missing_optional[*]}"
    fi
}

# Initialize script
init() {
    check_root

    # Setup signal handlers first
    setup_signal_handlers

    # Run non-critical checks in background for faster startup
    (
        check_dependencies
        create_directories
    ) >/dev/null 2>&1 &

    # Apply performance optimizations
    optimize_systemctl_calls >/dev/null 2>&1

    # Initialize caches and flags
    CACHE_DATA["frp_installation"]=""
    CACHE_DATA["update_check_done"]="false"
    CACHE_DATA["services"]=""
    MENU_STATE["ctrl_c_pressed"]="false"

    log "INFO" "MoonFRP script initialized successfully"
}

# Cleanup and exit function
cleanup_and_exit() {
    # Clean up temporary files
    [[ -d "$TEMP_DIR" ]] && rm -rf "$TEMP_DIR"

    # Log exit
    log "INFO" "MoonFRP session ended"

    # Exit gracefully
    exit 0
}

#==============================================================================
# UNIFIED MENU SYSTEM FUNCTIONS
#==============================================================================

# Unified menu rendering function
render_menu() {
    local title="$1"
    local subtitle="$2"
    local options="$3"    # Array of menu options
    local prompt="$4"     # Input prompt
    local debug_info="$5" # Optional debug information

    # Clear screen with optimized escape sequences
    printf '\033[2J\033[H'
    
    # Render header
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║            MoonFRP                   ║${NC}"
    if [[ -n "$subtitle" ]]; then
        echo -e "${PURPLE}║        $subtitle${NC}"
    fi
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    # Render menu options
    if [[ -n "$options" ]]; then
        echo -e "\n${CYAN}$title:${NC}"
        echo "$options"
    fi

    # Show debug info if provided
    if [[ -n "$debug_info" && "${DEBUG:-}" == "1" ]]; then
        echo -e "\n${GRAY}[Debug] $debug_info${NC}"
    fi

    # Render prompt
    if [[ -n "$prompt" ]]; then
        echo -e "\n${YELLOW}$prompt${NC} "
    fi
}

# Unified menu choice handling function
handle_menu_choice() {
    local menu_name="$1"
    local choices="$2"    # Associative array of choices
    local default_action="$3"  # Default action for unknown choices

    # Read user input
    read -r choice

    # Check for Ctrl+C after read
    if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
        MENU_STATE["ctrl_c_pressed"]="false"
        return 1
    fi

    # Handle special cases
    case "$choice" in
        "0"|"q"|"quit"|"exit")
            return 1  # Signal to go back
            ;;
        "h"|"help")
            echo -e "${CYAN}Help: Use number keys to select options, 0/q to go back${NC}"
            read -p "Press Enter to continue..."
            return 2  # Signal to redraw menu
            ;;
        "")
            echo -e "${YELLOW}Please enter a choice${NC}"
            read -p "Press Enter to continue..."
            return 2  # Signal to redraw menu
            ;;
    esac

    # Execute the chosen action
    if [[ -n "${choices[$choice]}" ]]; then
        eval "${choices[$choice]}"
        return 0
    else
        if [[ -n "$default_action" ]]; then
            eval "$default_action"
        else
            echo -e "${RED}Invalid choice: $choice${NC}"
            read -p "Press Enter to continue..."
        fi
        return 2  # Signal to redraw menu
    fi
}

# Unified menu loop function
run_menu() {
    local menu_name="$1"
    local title="$2"
    local subtitle="$3"
    local options="$4"
    local choices="$5"     # Associative array of choices
    local prompt="$6"
    local debug_info="$7"

    while true; do
        # Check for Ctrl+C signal
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return
        fi

        # Render menu
        render_menu "$title" "$subtitle" "$options" "$prompt" "$debug_info"

        # Handle choice
        local result
        handle_menu_choice "$menu_name" "$choices" "$default_action"
        result=$?

        case $result in
            0) continue ;;  # Choice executed successfully
            1) return ;;    # Go back
            2) continue ;;  # Redraw menu
        esac
    done
}

#==============================================================================
# UNIFIED ERROR HANDLING & SAFE EXECUTION
#==============================================================================

# Safe command execution wrapper with comprehensive error handling
safe_execute() {
    local command="$1"
    local description="${2:-Executing command}"
    local timeout="${3:-30}"
    local retries="${4:-3}"
    local critical="${5:-false}"  # If true, script exits on failure
    
    # Validate inputs
    if [[ -z "$command" ]]; then
        log "ERROR" "No command provided to safe_execute"
        return 1
    fi
    
    log "DEBUG" "Safe execute: $description"
    log "DEBUG" "Command: $command"
    
    local attempt=1
    local last_error=""
    
    while [[ $attempt -le $retries ]]; do
        # Execute command with timeout
        if timeout "$timeout" bash -c "$command" 2>/dev/null; then
            log "DEBUG" "Command succeeded on attempt $attempt"
            return 0
        else
            local exit_code=$?
            last_error="Exit code: $exit_code"
            
            if [[ $attempt -lt $retries ]]; then
                log "WARN" "Command failed (attempt $attempt/$retries): $description"
                log "WARN" "Error: $last_error, retrying in 2 seconds..."
                sleep 2
            else
                log "ERROR" "Command failed after $retries attempts: $description"
                log "ERROR" "Final error: $last_error"
                
                if [[ "$critical" == "true" ]]; then
                    log "ERROR" "Critical command failed, exiting..."
                    cleanup_and_exit 1
                fi
                
                return 1
            fi
        fi
        
        ((attempt++))
    done
}

# Enhanced error handling with context
handle_error() {
    local error_code="$1"
    local context="$2"
    local suggestion="${3:-}"
    
    # Log the error with context
    log "ERROR" "Error $error_code in context: $context"
    
    # Provide helpful suggestions based on error type
    case $error_code in
        1)
            log "ERROR" "General error occurred"
            ;;
        2)
            log "ERROR" "Misuse of shell builtins"
            ;;
        126)
            log "ERROR" "Command invoked cannot execute (permission denied or not executable)"
            ;;
        127)
            log "ERROR" "Command not found"
            ;;
        128)
            log "ERROR" "Invalid argument to exit"
            ;;
        130)
            log "ERROR" "Script terminated by Ctrl+C"
            ;;
        255)
            log "ERROR" "Exit status out of range"
            ;;
        *)
            log "ERROR" "Unknown error code: $error_code"
            ;;
    esac
    
    # Show suggestion if provided
    if [[ -n "$suggestion" ]]; then
        echo -e "${YELLOW}Suggestion: $suggestion${NC}"
    fi
    
    # Return the error code for further handling
    return $error_code
}

# Validate command dependencies
validate_command() {
    local command="$1"
    local package="${2:-}"
    
    if ! command -v "$command" >/dev/null 2>&1; then
        log "ERROR" "Required command '$command' not found"
        if [[ -n "$package" ]]; then
            log "ERROR" "Please install package: $package"
        fi
        return 1
    fi
    
    return 0
}

# Validate file/directory permissions
validate_permissions() {
    local path="$1"
    local required_perms="${2:-r}"
    local description="${3:-File/directory}"
    
    if [[ ! -e "$path" ]]; then
        log "ERROR" "$description does not exist: $path"
        return 1
    fi
    
    case "$required_perms" in
        "r")
            if [[ ! -r "$path" ]]; then
                log "ERROR" "$description is not readable: $path"
                return 1
            fi
            ;;
        "w")
            if [[ ! -w "$path" ]]; then
                log "ERROR" "$description is not writable: $path"
                return 1
            fi
            ;;
        "x")
            if [[ ! -x "$path" ]]; then
                log "ERROR" "$description is not executable: $path"
                return 1
            fi
            ;;
        "rw")
            if [[ ! -r "$path" || ! -w "$path" ]]; then
                log "ERROR" "$description is not readable/writable: $path"
                return 1
            fi
            ;;
        "rwx")
            if [[ ! -r "$path" || ! -w "$path" || ! -x "$path" ]]; then
                log "ERROR" "$description is not readable/writable/executable: $path"
                return 1
            fi
            ;;
    esac
    
    return 0
}

#==============================================================================
# UNIFIED VALIDATION & SANITIZATION
#==============================================================================

# Unified validation function for all input types
validate() {
    local type="$1"        # Type of validation: ip, port, domain, service_name, etc.
    local value="$2"       # Value to validate
    local options="${3:-}"  # Additional options (e.g., "required", "range:1-65535")
    
    # Validate inputs
    if [[ -z "$type" || -z "$value" ]]; then
        log "ERROR" "Missing validation parameters: type and value required"
        return 1
    fi
    
    # Check if value is required
    if [[ "$options" == *"required"* && -z "$value" ]]; then
        log "ERROR" "Value is required but empty"
        return 1
    fi
    
    # Skip validation if value is empty and not required
    if [[ -z "$value" && "$options" != *"required"* ]]; then
        return 0
    fi
    
    case "$type" in
        "ip")
            validate_ip "$value"
            ;;
        "port")
            validate_port "$value" "$options"
            ;;
        "domain")
            validate_domain "$value"
            ;;
        "service_name")
            validate_service_name "$value"
            ;;
        "proxy_name")
            validate_proxy_name "$value"
            ;;
        "token")
            validate_token "$value"
            ;;
        "path")
            validate_path "$value" "$options"
            ;;
        "url")
            validate_url "$value"
            ;;
        "email")
            validate_email "$value"
            ;;
        "numeric")
            validate_numeric "$value" "$options"
            ;;
        "alphanumeric")
            validate_alphanumeric "$value" "$options"
            ;;
        *)
            log "ERROR" "Unknown validation type: $type"
            return 1
            ;;
    esac
}

# IP address validation
validate_ip() {
    local ip="$1"
    
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        IFS='.' read -ra ADDR <<< "$ip"
        for i in "${ADDR[@]}"; do
            if [[ $i -gt 255 ]]; then
                log "ERROR" "Invalid IP address: $ip (octet $i > 255)"
                return 1
            fi
        done
        return 0
    else
        log "ERROR" "Invalid IP address format: $ip"
        return 1
    fi
}

# Port validation with range support
validate_port() {
    local port="$1"
    local options="$2"
    
    # Check if it's a number
    if ! [[ "$port" =~ ^[0-9]+$ ]]; then
        log "ERROR" "Port must be a number: $port"
        return 1
    fi
    
    # Check range if specified
    if [[ "$options" =~ range:([0-9]+)-([0-9]+) ]]; then
        local min_port="${BASH_REMATCH[1]}"
        local max_port="${BASH_REMATCH[2]}"
        
        if [[ $port -lt $min_port || $port -gt $max_port ]]; then
            log "ERROR" "Port $port is out of range ($min_port-$max_port)"
            return 1
        fi
    else
        # Default port range
        if [[ $port -lt 1 || $port -gt 65535 ]]; then
            log "ERROR" "Port $port is out of range (1-65535)"
            return 1
        fi
    fi
    
    return 0
}

# Domain name validation
validate_domain() {
    local domain="$1"
    
    if [[ $domain =~ ^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        # Check length
        if [[ ${#domain} -gt 253 ]]; then
            log "ERROR" "Domain name too long: $domain (max 253 characters)"
            return 1
        fi
        return 0
    else
        log "ERROR" "Invalid domain name format: $domain"
        return 1
    fi
}

# Service name validation
validate_service_name() {
    local service="$1"
    
    # Check length
    if [[ ${#service} -gt 256 ]]; then
        log "ERROR" "Service name too long: $service (max 256 characters)"
        return 1
    fi
    
    # Check for valid characters (alphanumeric, hyphens, underscores)
    if [[ ! $service =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log "ERROR" "Service name contains invalid characters: $service (only alphanumeric, hyphens, underscores allowed)"
        return 1
    fi
    
    return 0
}

# Proxy name validation
validate_proxy_name() {
    local proxy="$1"
    
    # Check length
    if [[ ${#proxy} -gt 64 ]]; then
        log "ERROR" "Proxy name too long: $proxy (max 64 characters)"
        return 1
    fi
    
    # Check for valid characters
    if [[ ! $proxy =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log "ERROR" "Proxy name contains invalid characters: $proxy (only alphanumeric, hyphens, underscores allowed)"
        return 1
    fi
    
    return 0
}

# Token validation
validate_token() {
    local token="$1"
    
    # Check length
    if [[ ${#token} -lt 8 ]]; then
        log "ERROR" "Token too short: $token (min 8 characters)"
        return 1
    fi
    
    if [[ ${#token} -gt 128 ]]; then
        log "ERROR" "Token too long: $token (max 128 characters)"
        return 1
    fi
    
    return 0
}

# Path validation
validate_path() {
    local path="$1"
    local options="$2"
    
    # Check if path exists
    if [[ "$options" == *"exists"* && ! -e "$path" ]]; then
        log "ERROR" "Path does not exist: $path"
        return 1
    fi
    
    # Check if it's a directory
    if [[ "$options" == *"directory"* && ! -d "$path" ]]; then
        log "ERROR" "Path is not a directory: $path"
        return 1
    fi
    
    # Check if it's a file
    if [[ "$options" == *"file"* && ! -f "$path" ]]; then
        log "ERROR" "Path is not a file: $path"
        return 1
    fi
    
    return 0
}

# URL validation
validate_url() {
    local url="$1"
    
    if [[ $url =~ ^https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(/.*)?$ ]]; then
        return 0
    else
        log "ERROR" "Invalid URL format: $url"
        return 1
    fi
}

# Email validation
validate_email() {
    local email="$1"
    
    if [[ $email =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        return 0
    else
        log "ERROR" "Invalid email format: $email"
        return 1
    fi
}

# Numeric validation
validate_numeric() {
    local value="$1"
    local options="$2"
    
    if ! [[ "$value" =~ ^[0-9]+$ ]]; then
        log "ERROR" "Value must be numeric: $value"
        return 1
    fi
    
    # Check range if specified
    if [[ "$options" =~ range:([0-9]+)-([0-9]+) ]]; then
        local min_val="${BASH_REMATCH[1]}"
        local max_val="${BASH_REMATCH[2]}"
        
        if [[ $value -lt $min_val || $value -gt $max_val ]]; then
            log "ERROR" "Value $value is out of range ($min_val-$max_val)"
            return 1
        fi
    fi
    
    return 0
}

# Alphanumeric validation
validate_alphanumeric() {
    local value="$1"
    local options="$2"
    
    # Check length if specified
    if [[ "$options" =~ length:([0-9]+)-([0-9]+) ]]; then
        local min_len="${BASH_REMATCH[1]}"
        local max_len="${BASH_REMATCH[2]}"
        
        if [[ ${#value} -lt $min_len || ${#value} -gt $max_len ]]; then
            log "ERROR" "Value length ${#value} is out of range ($min_len-$max_len)"
            return 1
        fi
    fi
    
    # Check for valid characters
    if [[ ! $value =~ ^[a-zA-Z0-9]+$ ]]; then
        log "ERROR" "Value contains invalid characters: $value (only alphanumeric allowed)"
        return 1
    fi
    
    return 0
}

# Sanitize input to prevent injection attacks
sanitize_input() {
    local input="$1"
    local type="${2:-general}"  # general, filename, url, etc.
    
    case "$type" in
        "filename")
            # Remove dangerous characters for filenames
            echo "$input" | sed 's/[^a-zA-Z0-9._-]//g'
            ;;
        "url")
            # Basic URL sanitization
            echo "$input" | sed 's/[^a-zA-Z0-9:/?#\[\]@!$&'"'"'()*+,;=._~-]//g'
            ;;
        "general")
            # Remove control characters and some special chars
            echo "$input" | sed 's/[[:cntrl:]]//g' | sed 's/[<>|&;`$]//g'
            ;;
        *)
            # Default sanitization
            echo "$input" | sed 's/[[:cntrl:]]//g'
            ;;
    esac
}

#==============================================================================
# CONFIG TEMPLATE SYSTEM WITH BACKUP & VALIDATION
#==============================================================================

# Apply configuration template with variable substitution
apply_config_template() {
    local template_file="$1"
    local output_file="$2"
    local variables="$3"    # Associative array of variables to substitute
    
    # Validate inputs
    if [[ -z "$template_file" || -z "$output_file" ]]; then
        log "ERROR" "Template file and output file are required"
        return 1
    fi
    
    # Check if template file exists
    if [[ ! -f "$template_file" ]]; then
        log "ERROR" "Template file not found: $template_file"
        return 1
    fi
    
    # Create output directory if it doesn't exist
    local output_dir=$(dirname "$output_file")
    if [[ ! -d "$output_dir" ]]; then
        mkdir -p "$output_dir" || {
            log "ERROR" "Failed to create output directory: $output_dir"
            return 1
        }
    fi
    
    # Backup existing file if it exists
    if [[ -f "$output_file" ]]; then
        backup_config "$output_file" "auto_backup"
    fi
    
    # Apply template with variable substitution
    local temp_file=$(mktemp)
    cp "$template_file" "$temp_file"
    
    # Substitute variables
    for var_name in "${!variables[@]}"; do
        local var_value="${variables[$var_name]}"
        # Escape special characters for sed
        local escaped_value=$(printf '%s\n' "$var_value" | sed 's/[[\.*^$()+?{|]/\\&/g')
        sed -i "s/\${$var_name}/$escaped_value/g" "$temp_file"
    done
    
    # Move temp file to output
    mv "$temp_file" "$output_file" || {
        log "ERROR" "Failed to write output file: $output_file"
        return 1
    }
    
    log "INFO" "Template applied successfully: $template_file -> $output_file"
    return 0
}

# Backup configuration file with timestamp
backup_config() {
    local config_file="$1"
    local backup_type="${2:-manual}"  # manual, auto_backup, update_backup
    
    if [[ ! -f "$config_file" ]]; then
        log "WARN" "Config file not found for backup: $config_file"
        return 1
    fi
    
    local backup_dir="$BACKUP_DIR"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local filename=$(basename "$config_file")
    local backup_file="$backup_dir/${filename}.${backup_type}.${timestamp}.bak"
    
    # Create backup directory if it doesn't exist
    mkdir -p "$backup_dir" || {
        log "ERROR" "Failed to create backup directory: $backup_dir"
        return 1
    }
    
    # Create backup
    cp "$config_file" "$backup_file" || {
        log "ERROR" "Failed to create backup: $backup_file"
        return 1
    }
    
    # Compress backup if it's large (>1MB)
    local file_size=$(stat -f%z "$backup_file" 2>/dev/null || stat -c%s "$backup_file" 2>/dev/null)
    if [[ $file_size -gt 1048576 ]]; then
        gzip "$backup_file" && backup_file="${backup_file}.gz"
        log "INFO" "Large backup compressed: $backup_file"
    fi
    
    log "INFO" "Config backed up: $config_file -> $backup_file"
    
    # Clean up old backups (keep last 10)
    cleanup_old_backups "$backup_dir" "$filename" 10
    
    return 0
}

# Clean up old backup files
cleanup_old_backups() {
    local backup_dir="$1"
    local filename="$2"
    local keep_count="${3:-10}"
    
    # Find and remove old backups, keeping the most recent ones
    find "$backup_dir" -name "${filename}.*.bak*" -type f -printf '%T@ %p\n' | \
        sort -rn | tail -n +$((keep_count + 1)) | cut -d' ' -f2- | \
        while read -r old_backup; do
            rm -f "$old_backup" && log "DEBUG" "Removed old backup: $old_backup"
        done
}

# Validate configuration file syntax
validate_config_syntax() {
    local config_file="$1"
    local config_type="${2:-auto}"  # auto, toml, json, yaml
    
    if [[ ! -f "$config_file" ]]; then
        log "ERROR" "Config file not found: $config_file"
        return 1
    fi
    
    # Auto-detect config type if not specified
    if [[ "$config_type" == "auto" ]]; then
        case "$config_file" in
            *.toml) config_type="toml" ;;
            *.json) config_type="json" ;;
            *.yaml|*.yml) config_type="yaml" ;;
            *) config_type="toml" ;;  # Default to TOML for FRP configs
        esac
    fi
    
    case "$config_type" in
        "toml")
            validate_toml_syntax "$config_file"
            ;;
        "json")
            validate_json_syntax "$config_file"
            ;;
        "yaml")
            validate_yaml_syntax "$config_file"
            ;;
        *)
            log "ERROR" "Unknown config type: $config_type"
            return 1
            ;;
    esac
}

# Validate TOML syntax
validate_toml_syntax() {
    local toml_file="$1"
    
    # Basic TOML validation using Python if available
    if command -v python3 >/dev/null 2>&1; then
        python3 -c "
import tomllib
try:
    with open('$toml_file', 'rb') as f:
        tomllib.load(f)
    print('TOML syntax is valid')
except Exception as e:
    print(f'TOML syntax error: {e}')
    exit(1)
" 2>/dev/null && return 0
    fi
    
    # Fallback: basic syntax checking
    local errors=0
    
    # Check for basic TOML structure
    if ! grep -q "^\[" "$toml_file"; then
        log "ERROR" "No section headers found in TOML file"
        ((errors++))
    fi
    
    # Check for unclosed brackets
    local open_brackets=$(grep -o '\[' "$toml_file" | wc -l)
    local close_brackets=$(grep -o '\]' "$toml_file" | wc -l)
    if [[ $open_brackets -ne $close_brackets ]]; then
        log "ERROR" "Mismatched brackets in TOML file"
        ((errors++))
    fi
    
    # Check for basic key-value format
    if grep -q "=" "$toml_file" && ! grep -q "^[^#]*=.*$" "$toml_file"; then
        log "WARN" "Some lines may not follow key=value format"
    fi
    
    if [[ $errors -eq 0 ]]; then
        log "INFO" "TOML syntax appears valid (basic check)"
        return 0
    else
        log "ERROR" "TOML syntax validation failed with $errors errors"
        return 1
    fi
}

# Validate JSON syntax
validate_json_syntax() {
    local json_file="$1"
    
    if command -v jq >/dev/null 2>&1; then
        jq empty "$json_file" 2>/dev/null && return 0
    fi
    
    if command -v python3 >/dev/null 2>&1; then
        python3 -c "
import json
try:
    with open('$json_file', 'r') as f:
        json.load(f)
    print('JSON syntax is valid')
except Exception as e:
    print(f'JSON syntax error: {e}')
    exit(1)
" 2>/dev/null && return 0
    fi
    
    log "ERROR" "No JSON validator available (install jq or python3)"
    return 1
}

# Validate YAML syntax
validate_yaml_syntax() {
    local yaml_file="$1"
    
    if command -v yq >/dev/null 2>&1; then
        yq eval '.' "$yaml_file" >/dev/null 2>&1 && return 0
    fi
    
    if command -v python3 >/dev/null 2>&1; then
        python3 -c "
import yaml
try:
    with open('$yaml_file', 'r') as f:
        yaml.safe_load(f)
    print('YAML syntax is valid')
except Exception as e:
    print(f'YAML syntax error: {e}')
    exit(1)
" 2>/dev/null && return 0
    fi
    
    log "ERROR" "No YAML validator available (install yq or python3 with PyYAML)"
    return 1
}

# Create configuration template
create_config_template() {
    local template_name="$1"
    local template_type="${2:-frpc}"  # frpc, frps, custom
    local template_file="$TEMPLATE_DIR/${template_name}.template"
    
    # Create template directory if it doesn't exist
    mkdir -p "$TEMPLATE_DIR" || {
        log "ERROR" "Failed to create template directory: $TEMPLATE_DIR"
        return 1
    }
    
    case "$template_type" in
        "frpc")
            create_frpc_template "$template_file"
            ;;
        "frps")
            create_frps_template "$template_file"
            ;;
        "custom")
            create_custom_template "$template_file"
            ;;
        *)
            log "ERROR" "Unknown template type: $template_type"
            return 1
            ;;
    esac
    
    log "INFO" "Template created: $template_file"
    return 0
}

# Create FRP client template
create_frpc_template() {
    local template_file="$1"
    
    cat > "$template_file" << 'EOF'
# MoonFRP Client Configuration Template
# Generated on ${TIMESTAMP}
# Compatible with FRP v${FRP_VERSION}

serverAddr = "${SERVER_IP}"
serverPort = ${SERVER_PORT}

auth.method = "token"
auth.token = "${AUTH_TOKEN}"

log.to = "${LOG_DIR}/frpc_${IP_SUFFIX}.log"
log.level = "${LOG_LEVEL}"
log.maxDays = ${LOG_MAX_DAYS}
log.disablePrintColor = false

transport.poolCount = ${TRANSPORT_POOL_COUNT}
transport.protocol = "${TRANSPORT_PROTOCOL}"
transport.heartbeatTimeout = ${HEARTBEAT_TIMEOUT}
transport.heartbeatInterval = ${HEARTBEAT_INTERVAL}
transport.dialServerTimeout = ${DIAL_SERVER_TIMEOUT}
transport.dialServerKeepalive = ${DIAL_SERVER_KEEPALIVE}
transport.tcpMux = ${TCP_MUX}
transport.tcpMuxKeepaliveInterval = ${TCP_MUX_KEEPALIVE_INTERVAL}

transport.tls.enable = ${TLS_ENABLE}

loginFailExit = ${LOGIN_FAIL_EXIT}

user = "${USER_NAME}"

udpPacketSize = ${UDP_PACKET_SIZE}

# Proxy configurations will be added here
${PROXY_CONFIGS}
EOF
}

# Create FRP server template
create_frps_template() {
    local template_file="$1"
    
    cat > "$template_file" << 'EOF'
# MoonFRP Server Configuration Template
# Generated on ${TIMESTAMP}
# Compatible with FRP v${FRP_VERSION}

bindAddr = "${BIND_ADDR}"
bindPort = ${BIND_PORT}

auth.method = "token"
auth.token = "${AUTH_TOKEN}"

log.to = "${LOG_DIR}/frps.log"
log.level = "${LOG_LEVEL}"
log.maxDays = ${LOG_MAX_DAYS}
log.disablePrintColor = false

transport.poolCount = ${TRANSPORT_POOL_COUNT}
transport.protocol = "${TRANSPORT_PROTOCOL}"
transport.heartbeatTimeout = ${HEARTBEAT_TIMEOUT}
transport.heartbeatInterval = ${HEARTBEAT_INTERVAL}
transport.tcpMux = ${TCP_MUX}
transport.tcpMuxKeepaliveInterval = ${TCP_MUX_KEEPALIVE_INTERVAL}

transport.tls.enable = ${TLS_ENABLE}

maxPortsPerClient = ${MAX_PORTS_PER_CLIENT}
userConnTimeout = ${USER_CONN_TIMEOUT}

# Advanced settings
${ADVANCED_SETTINGS}
EOF
}

# Create custom template
create_custom_template() {
    local template_file="$1"
    
    cat > "$template_file" << 'EOF'
# Custom Configuration Template
# Generated on ${TIMESTAMP}

# Add your custom configuration here
# Use ${VARIABLE_NAME} for variable substitution

# Example:
# setting1 = "${VALUE1}"
# setting2 = ${VALUE2}
# setting3 = "${VALUE3}"

EOF
}

#==============================================================================
# UNIFIED CLEANUP SYSTEM
#==============================================================================

# Unified cleanup function for all cleanup operations
cleanup() {
    local operation="$1"    # Type of cleanup: services, configs, logs, temp, all, selective
    local options="${2:-}"  # Additional options: force, backup, dry_run
    local target="${3:-}"   # Specific target (service name, config file, etc.)
    
    # Validate inputs
    if [[ -z "$operation" ]]; then
        log "ERROR" "Cleanup operation is required"
        return 1
    fi
    
    log "INFO" "Starting cleanup operation: $operation"
    
    case "$operation" in
        "services")
            cleanup_services "$options" "$target"
            ;;
        "configs")
            cleanup_configs "$options" "$target"
            ;;
        "logs")
            cleanup_logs "$options" "$target"
            ;;
        "temp")
            cleanup_temp_files "$options"
            ;;
        "backups")
            cleanup_backups "$options" "$target"
            ;;
        "all")
            cleanup_all "$options"
            ;;
        "selective")
            cleanup_selective "$options" "$target"
            ;;
        *)
            log "ERROR" "Unknown cleanup operation: $operation"
            echo -e "${CYAN}Available operations:${NC} services, configs, logs, temp, backups, all, selective"
            return 1
            ;;
    esac
}

# Cleanup services (stop, disable, remove)
cleanup_services() {
    local options="$1"
    local target="$2"
    
    if [[ "$options" == *"dry_run"* ]]; then
        log "INFO" "DRY RUN: Would cleanup services"
        return 0
    fi
    
    # Get list of FRP services
    local services=($(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//'))
    
    if [[ ${#services[@]} -eq 0 ]]; then
        log "INFO" "No FRP services found to cleanup"
        return 0
    fi
    
    # Handle specific target
    if [[ -n "$target" ]]; then
        if [[ " ${services[@]} " =~ " ${target} " ]]; then
            cleanup_single_service "$target" "$options"
        else
            log "ERROR" "Service not found: $target"
            return 1
        fi
        return 0
    fi
    
    # Cleanup all services
    log "INFO" "Cleaning up ${#services[@]} FRP services..."
    
    for service in "${services[@]}"; do
        cleanup_single_service "$service" "$options"
    done
    
    # Reload systemd daemon
    systemctl daemon-reload
    
    log "INFO" "Service cleanup completed"
    return 0
}

# Cleanup single service
cleanup_single_service() {
    local service="$1"
    local options="$2"
    
    log "INFO" "Cleaning up service: $service"
    
    # Stop service
    if systemctl is-active "$service" >/dev/null 2>&1; then
        systemctl stop "$service" || log "WARN" "Failed to stop service: $service"
    fi
    
    # Disable service
    if systemctl is-enabled "$service" >/dev/null 2>&1; then
        systemctl disable "$service" || log "WARN" "Failed to disable service: $service"
    fi
    
    # Remove service file
    local service_file="$SERVICE_DIR/${service}.service"
    if [[ -f "$service_file" ]]; then
        if [[ "$options" == *"backup"* ]]; then
            backup_config "$service_file" "cleanup_backup"
        fi
        rm -f "$service_file" && log "INFO" "Removed service file: $service_file"
    fi
    
    # Clear performance caches
    clear_performance_caches
}

# Cleanup configuration files
cleanup_configs() {
    local options="$1"
    local target="$2"
    
    if [[ "$options" == *"dry_run"* ]]; then
        log "INFO" "DRY RUN: Would cleanup configs"
        return 0
    fi
    
    # Handle specific target
    if [[ -n "$target" ]]; then
        if [[ -f "$target" ]]; then
            cleanup_single_config "$target" "$options"
        else
            log "ERROR" "Config file not found: $target"
            return 1
        fi
        return 0
    fi
    
    # Cleanup all FRP configs
    local config_files=($(find "$CONFIG_DIR" -name "*.toml" -type f 2>/dev/null))
    
    if [[ ${#config_files[@]} -eq 0 ]]; then
        log "INFO" "No FRP config files found to cleanup"
        return 0
    fi
    
    log "INFO" "Cleaning up ${#config_files[@]} config files..."
    
    for config_file in "${config_files[@]}"; do
        cleanup_single_config "$config_file" "$options"
    done
    
    log "INFO" "Config cleanup completed"
    return 0
}

# Cleanup single config file
cleanup_single_config() {
    local config_file="$1"
    local options="$2"
    
    log "INFO" "Cleaning up config: $config_file"
    
    if [[ "$options" == *"backup"* ]]; then
        backup_config "$config_file" "cleanup_backup"
    fi
    
    rm -f "$config_file" && log "INFO" "Removed config file: $config_file"
}

# Cleanup log files
cleanup_logs() {
    local options="$1"
    local target="$2"
    
    if [[ "$options" == *"dry_run"* ]]; then
        log "INFO" "DRY RUN: Would cleanup logs"
        return 0
    fi
    
    # Handle specific target
    if [[ -n "$target" ]]; then
        if [[ -f "$target" ]]; then
            cleanup_single_log "$target" "$options"
        else
            log "ERROR" "Log file not found: $target"
            return 1
        fi
        return 0
    fi
    
    # Cleanup all FRP logs
    local log_files=($(find "$LOG_DIR" -name "*.log" -type f 2>/dev/null))
    
    if [[ ${#log_files[@]} -eq 0 ]]; then
        log "INFO" "No FRP log files found to cleanup"
        return 0
    fi
    
    log "INFO" "Cleaning up ${#log_files[@]} log files..."
    
    for log_file in "${log_files[@]}"; do
        cleanup_single_log "$log_file" "$options"
    done
    
    log "INFO" "Log cleanup completed"
    return 0
}

# Cleanup single log file
cleanup_single_log() {
    local log_file="$1"
    local options="$2"
    
    log "INFO" "Cleaning up log: $log_file"
    
    if [[ "$options" == *"backup"* ]]; then
        backup_config "$log_file" "log_backup"
    fi
    
    rm -f "$log_file" && log "INFO" "Removed log file: $log_file"
}

# Cleanup temporary files
cleanup_temp_files() {
    local options="$1"
    
    if [[ "$options" == *"dry_run"* ]]; then
        log "INFO" "DRY RUN: Would cleanup temp files"
        return 0
    fi
    
    log "INFO" "Cleaning up temporary files..."
    
    # Clean up temp files in /tmp
    find /tmp -name "moonfrp_*" -type f -mtime +1 -delete 2>/dev/null || true
    
    # Clean up temp files in script directory
    find "$SCRIPT_DIR" -name "*.tmp" -type f -delete 2>/dev/null || true
    
    # Clean up old lock files
    find "$SCRIPT_DIR" -name "*.lock" -type f -mtime +1 -delete 2>/dev/null || true
    
    log "INFO" "Temporary files cleanup completed"
    return 0
}

# Cleanup backup files
cleanup_backups() {
    local options="$1"
    local target="$2"
    
    if [[ "$options" == *"dry_run"* ]]; then
        log "INFO" "DRY RUN: Would cleanup backups"
        return 0
    fi
    
    # Handle specific target
    if [[ -n "$target" ]]; then
        if [[ -f "$target" ]]; then
            rm -f "$target" && log "INFO" "Removed backup: $target"
        else
            log "ERROR" "Backup file not found: $target"
            return 1
        fi
        return 0
    fi
    
    # Cleanup old backups
    local backup_dir="$BACKUP_DIR"
    if [[ -d "$backup_dir" ]]; then
        local backup_files=($(find "$backup_dir" -name "*.bak*" -type f -mtime +30 2>/dev/null))
        
        if [[ ${#backup_files[@]} -eq 0 ]]; then
            log "INFO" "No old backup files found to cleanup"
            return 0
        fi
        
        log "INFO" "Cleaning up ${#backup_files[@]} old backup files..."
        
        for backup_file in "${backup_files[@]}"; do
            rm -f "$backup_file" && log "DEBUG" "Removed old backup: $backup_file"
        done
        
        log "INFO" "Backup cleanup completed"
    else
        log "INFO" "No backup directory found"
    fi
    
    return 0
}

# Cleanup everything
cleanup_all() {
    local options="$1"
    
    if [[ "$options" == *"dry_run"* ]]; then
        log "INFO" "DRY RUN: Would cleanup everything"
        return 0
    fi
    
    log "WARN" "Starting complete cleanup of all FRP components..."
    
    # Confirm unless force option is used
    if [[ "$options" != *"force"* ]]; then
        echo -e "${RED}⚠️  WARNING: This will remove ALL FRP services, configs, and logs!${NC}"
        echo -e "${YELLOW}Are you sure you want to continue? (yes/no):${NC} "
        read -r confirmation
        
        if [[ "$confirmation" != "yes" ]]; then
            log "INFO" "Cleanup cancelled by user"
            return 0
        fi
    fi
    
    # Cleanup in order
    cleanup_services "$options"
    cleanup_configs "$options"
    cleanup_logs "$options"
    cleanup_temp_files "$options"
    
    # Clear all caches
    clear_performance_caches
    CACHE_DATA=()  # Clear all cache data
    
    log "INFO" "Complete cleanup finished"
    return 0
}

# Selective cleanup based on criteria
cleanup_selective() {
    local options="$1"
    local criteria="$2"
    
    if [[ "$options" == *"dry_run"* ]]; then
        log "INFO" "DRY RUN: Would perform selective cleanup"
        return 0
    fi
    
    case "$criteria" in
        "inactive_services")
            cleanup_inactive_services "$options"
            ;;
        "old_logs")
            cleanup_old_logs "$options"
            ;;
        "unused_configs")
            cleanup_unused_configs "$options"
            ;;
        *)
            log "ERROR" "Unknown selective cleanup criteria: $criteria"
            echo -e "${CYAN}Available criteria:${NC} inactive_services, old_logs, unused_configs"
            return 1
            ;;
    esac
}

# Cleanup inactive services
cleanup_inactive_services() {
    local options="$1"
    
    local inactive_services=($(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | grep "inactive" | awk '{print $1}' | sed 's/\.service//'))
    
    if [[ ${#inactive_services[@]} -eq 0 ]]; then
        log "INFO" "No inactive FRP services found"
        return 0
    fi
    
    log "INFO" "Found ${#inactive_services[@]} inactive services to cleanup..."
    
    for service in "${inactive_services[@]}"; do
        cleanup_single_service "$service" "$options"
    done
    
    log "INFO" "Inactive services cleanup completed"
    return 0
}

# Cleanup old log files
cleanup_old_logs() {
    local options="$1"
    local days="${2:-7}"
    
    local old_logs=($(find "$LOG_DIR" -name "*.log" -type f -mtime +$days 2>/dev/null))
    
    if [[ ${#old_logs[@]} -eq 0 ]]; then
        log "INFO" "No old log files found (older than $days days)"
        return 0
    fi
    
    log "INFO" "Found ${#old_logs[@]} old log files to cleanup..."
    
    for log_file in "${old_logs[@]}"; do
        cleanup_single_log "$log_file" "$options"
    done
    
    log "INFO" "Old logs cleanup completed"
    return 0
}

# Cleanup unused config files
cleanup_unused_configs() {
    local options="$1"
    
    # Find config files that don't have corresponding active services
    local config_files=($(find "$CONFIG_DIR" -name "*.toml" -type f 2>/dev/null))
    local active_services=($(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | grep "active" | awk '{print $1}' | sed 's/\.service//'))
    
    local unused_configs=()
    
    for config_file in "${config_files[@]}"; do
        local config_name=$(basename "$config_file" .toml)
        local is_used=false
        
        for service in "${active_services[@]}"; do
            if [[ "$service" == *"$config_name"* ]]; then
                is_used=true
                break
            fi
        done
        
        if [[ "$is_used" == "false" ]]; then
            unused_configs+=("$config_file")
        fi
    done
    
    if [[ ${#unused_configs[@]} -eq 0 ]]; then
        log "INFO" "No unused config files found"
        return 0
    fi
    
    log "INFO" "Found ${#unused_configs[@]} unused config files to cleanup..."
    
    for config_file in "${unused_configs[@]}"; do
        cleanup_single_config "$config_file" "$options"
    done
    
    log "INFO" "Unused configs cleanup completed"
    return 0
}

#==============================================================================
# PERFORMANCE OPTIMIZATION & CACHE MANAGEMENT
#==============================================================================

# Enhanced cache management with TTL
manage_cache() {
    local operation="$1"    # get, set, clear, invalidate, stats
    local key="$2"          # Cache key
    local value="${3:-}"    # Value to cache (for set operation)
    local ttl="${4:-300}"   # Time to live in seconds (default 5 minutes)
    
    case "$operation" in
        "get")
            get_cached_value "$key" "$ttl"
            ;;
        "set")
            set_cached_value "$key" "$value" "$ttl"
            ;;
        "clear")
            clear_cache_entry "$key"
            ;;
        "invalidate")
            invalidate_cache_entry "$key"
            ;;
        "stats")
            show_cache_stats
            ;;
        *)
            log "ERROR" "Unknown cache operation: $operation"
            return 1
            ;;
    esac
}

# Get cached value with TTL check
get_cached_value() {
    local key="$1"
    local ttl="${2:-300}"
    
    # Check if cache entry exists and is not expired
    if [[ -n "${CACHE_DATA["${key}_value"]:-}" ]]; then
        local timestamp="${CACHE_DATA["${key}_timestamp"]:-0}"
        local current_time=$(date +%s)
        
        if [[ $((current_time - timestamp)) -lt $ttl ]]; then
            echo "${CACHE_DATA["${key}_value"]}"
            return 0
        else
            # Cache expired, remove it
            unset CACHE_DATA["${key}_value"]
            unset CACHE_DATA["${key}_timestamp"]
        fi
    fi
    
    return 1
}

# Set cached value with timestamp
set_cached_value() {
    local key="$1"
    local value="$2"
    local ttl="${3:-300}"
    local timestamp=$(date +%s)
    
    CACHE_DATA["${key}_value"]="$value"
    CACHE_DATA["${key}_timestamp"]="$timestamp"
    
    log "DEBUG" "Cached value for key '$key' (TTL: ${ttl}s)"
}

# Clear specific cache entry
clear_cache_entry() {
    local key="$1"
    
    unset CACHE_DATA["${key}_value"]
    unset CACHE_DATA["${key}_timestamp"]
    
    log "DEBUG" "Cleared cache entry: $key"
}

# Invalidate cache entry (mark as expired)
invalidate_cache_entry() {
    local key="$1"
    
    if [[ -n "${CACHE_DATA["${key}_timestamp"]}" ]]; then
        CACHE_DATA["${key}_timestamp"]="0"  # Mark as expired
        log "DEBUG" "Invalidated cache entry: $key"
    fi
}

# Show cache statistics
show_cache_stats() {
    local total_entries=0
    local expired_entries=0
    local current_time=$(date +%s)
    
    echo -e "${CYAN}Cache Statistics:${NC}"
    echo "=================="
    
    for key in "${!CACHE_DATA[@]}"; do
        if [[ "$key" == *"_timestamp" ]]; then
            local base_key="${key%_timestamp}"
            local timestamp="${CACHE_DATA[$key]}"
            local value_key="${base_key}_value"
            
            if [[ -n "${CACHE_DATA[$value_key]}" ]]; then
                ((total_entries++))
                
                if [[ $timestamp -eq 0 ]] || [[ $((current_time - timestamp)) -gt 300 ]]; then
                    ((expired_entries++))
                fi
            fi
        fi
    done
    
    echo "Total entries: $total_entries"
    echo "Expired entries: $expired_entries"
    echo "Active entries: $((total_entries - expired_entries))"
    echo "Cache hit ratio: $(calculate_cache_hit_ratio)"
}

# Calculate cache hit ratio
calculate_cache_hit_ratio() {
    local hits="${CACHE_DATA["cache_hits"]:-0}"
    local misses="${CACHE_DATA["cache_misses"]:-0}"
    local total=$((hits + misses))
    
    if [[ $total -eq 0 ]]; then
        echo "0%"
    else
        local ratio=$((hits * 100 / total))
        echo "${ratio}%"
    fi
}

# Batch systemctl operations for better performance
batch_systemctl_operation() {
    local operation="$1"    # start, stop, restart, status, enable, disable
    local services="$2"     # Space-separated list of services
    local options="$3"      # Additional options
    
    # Validate inputs
    if [[ -z "$operation" || -z "$services" ]]; then
        log "ERROR" "Operation and services list are required"
        return 1
    fi
    
    # Convert services string to array
    local service_array=($services)
    local failed_services=()
    local success_count=0
    
    log "INFO" "Performing batch $operation on ${#service_array[@]} services..."
    
    # Execute operation on all services
    case "$operation" in
        "start"|"stop"|"restart"|"reload")
            for service in "${service_array[@]}"; do
                if systemctl "$operation" "$service" >/dev/null 2>&1; then
                    ((success_count++))
                    log "DEBUG" "Successfully $operation $service"
                else
                    failed_services+=("$service")
                    log "WARN" "Failed to $operation $service"
                fi
            done
            ;;
        "enable"|"disable")
            for service in "${service_array[@]}"; do
                if systemctl "$operation" "$service" >/dev/null 2>&1; then
                    ((success_count++))
                    log "DEBUG" "Successfully $operation $service"
                else
                    failed_services+=("$service")
                    log "WARN" "Failed to $operation $service"
                fi
            done
            ;;
        "status")
            # Batch status check
            local status_output
            status_output=$(systemctl is-active "${service_array[@]}" 2>/dev/null || true)
            
            local status_array=()
            while IFS= read -r status; do
                status_array+=("$status")
            done <<< "$status_output"
            
            # Display results
            printf "%-4s %-30s %-12s\n" "No." "Service" "Status"
            printf "%-4s %-30s %-12s\n" "---" "-------" "------"
            
            local i=1
            for idx in "${!service_array[@]}"; do
                local service="${service_array[$idx]}"
                local status="${status_array[$idx]:-unknown}"
                
                local status_color="$RED"
                case "$status" in
                    "active") status_color="$GREEN" ;;
                    "inactive") status_color="$RED" ;;
                    "activating") status_color="$YELLOW" ;;
                    "deactivating") status_color="$YELLOW" ;;
                    "failed") status_color="$RED" ;;
                    *) status_color="$GRAY" ;;
                esac
                
                printf "%-4s %-30s ${status_color}%-12s${NC}\n" "$i." "$service" "$status"
                ((i++))
            done
            
            return 0
            ;;
        *)
            log "ERROR" "Unsupported batch operation: $operation"
            return 1
            ;;
    esac
    
    # Report results
    log "INFO" "Batch operation completed: $success_count/${#service_array[@]} services succeeded"
    
    if [[ ${#failed_services[@]} -gt 0 ]]; then
        log "WARN" "Failed services: ${failed_services[*]}"
        return 1
    fi
    
    return 0
}

# Optimized service listing with caching
get_services_optimized() {
    local force_refresh="${1:-false}"
    local cache_key="services_list"
    local cache_ttl=60  # 1 minute cache
    
    # Check cache first
    if [[ "$force_refresh" != "true" ]]; then
        local cached_services
        if cached_services=$(get_cached_value "$cache_key" "$cache_ttl"); then
            echo "$cached_services"
            return 0
        fi
    fi
    
    # Get fresh service list
    local services
    services=$(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//' | tr '\n' ' ')
    
    # Cache the result
    set_cached_value "$cache_key" "$services" "$cache_ttl"
    
    echo "$services"
    return 0
}

# Optimized service status checking
get_service_status_optimized() {
    local service="$1"
    local cache_key="status_${service}"
    local cache_ttl=30  # 30 seconds cache
    
    # Check cache first
    local cached_status
    if cached_status=$(get_cached_value "$cache_key" "$cache_ttl"); then
        echo "$cached_status"
        return 0
    fi
    
    # Get fresh status
    local status
    status=$(systemctl is-active "$service" 2>/dev/null || echo "inactive")
    
    # Cache the result
    set_cached_value "$cache_key" "$status" "$cache_ttl"
    
    echo "$status"
    return 0
}

# Performance monitoring and optimization
monitor_performance() {
    local duration="${1:-60}"  # Monitor for 60 seconds by default
    
    log "INFO" "Starting performance monitoring for ${duration}s..."
    
    local start_time=$(date +%s)
    local end_time=$((start_time + duration))
    local sample_count=0
    local total_response_time=0
    
    while [[ $(date +%s) -lt $end_time ]]; do
        local sample_start=$(date +%s%3N)
        
        # Sample operation (get service list)
        get_services_optimized "true" >/dev/null
        
        local sample_end=$(date +%s%3N)
        local response_time=$((sample_end - sample_start))
        
        total_response_time=$((total_response_time + response_time))
        ((sample_count++))
        
        # Log every 10 samples
        if [[ $((sample_count % 10)) -eq 0 ]]; then
            local avg_response_time=$((total_response_time / sample_count))
            log "DEBUG" "Performance sample $sample_count: avg response time ${avg_response_time}ms"
        fi
        
        sleep 1
    done
    
    local avg_response_time=$((total_response_time / sample_count))
    log "INFO" "Performance monitoring completed:"
    log "INFO" "  Samples: $sample_count"
    log "INFO" "  Average response time: ${avg_response_time}ms"
    log "INFO" "  Cache hit ratio: $(calculate_cache_hit_ratio)"
}

# Clear all performance caches
clear_performance_caches() {
    # Clear service-related caches
    clear_cache_entry "services_list"
    clear_cache_entry "frp_installation"
    
    # Clear all status caches
    for key in "${!CACHE_DATA[@]}"; do
        if [[ "$key" == status_* ]]; then
            clear_cache_entry "${key%_value}"
        fi
    done
    
    log "DEBUG" "Performance caches cleared"
}

# Optimize systemctl daemon operations
optimize_systemctl() {
    local operation="$1"
    
    case "$operation" in
        "reload")
            # Reload systemd daemon
            systemctl daemon-reload
            log "INFO" "Systemd daemon reloaded"
            ;;
        "reset-failed")
            # Reset failed services
            systemctl reset-failed
            log "INFO" "Failed services reset"
            ;;
        "status")
            # Show systemd status
            systemctl status --no-pager -l
            ;;
        *)
            log "ERROR" "Unknown systemctl optimization: $operation"
            return 1
            ;;
    esac
    
    return 0
}

#==============================================================================
# SECTION 7: DIAGNOSTICS & TROUBLESHOOTING
#==============================================================================

# Troubleshooting and diagnostics menu
troubleshooting_menu() {
    while true; do
        # Check for Ctrl+C signal
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return
        fi

        clear
        echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║            MoonFRP                   ║${NC}"
        echo -e "${PURPLE}║         Troubleshooting              ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

        echo -e "\n${CYAN}Troubleshooting Options:${NC}"
        echo "1. Check Proxy Name Conflicts"
        echo "2. Check Port Conflicts"
        echo "3. Validate Server Connections"
        echo "4. Check Service Logs"
        echo "5. Fix Common Issues"
        echo "6. Generate Diagnostic Report"
        echo "7. Quick Help for Common Errors"
        echo "8. Fix Web Panel Issues (HTTP 503)"
        echo "9. Performance Monitoring"
        echo "0. Back to Main Menu"

        echo -e "\n${YELLOW}Enter your choice [0-9]:${NC} "
        read -r choice

        # Check for Ctrl+C after read
        if [[ "${MENU_STATE["ctrl_c_pressed"]}" == "true" ]]; then
            MENU_STATE["ctrl_c_pressed"]="false"
            return
        fi

        case $choice in
            1) check_all_proxy_conflicts; read -p "Press Enter to continue..." ;;
            2) check_all_port_conflicts; read -p "Press Enter to continue..." ;;
            3) validate_all_connections; read -p "Press Enter to continue..." ;;
            4) view_service_logs_menu; read -p "Press Enter to continue..." ;;
            5) fix_common_issues; read -p "Press Enter to continue..." ;;
            6) generate_diagnostic_report; read -p "Press Enter to continue..." ;;
            7) show_quick_help; read -p "Press Enter to continue..." ;;
            8) fix_web_panel_issues; read -p "Press Enter to continue..." ;;
            9) monitor_all_proxies; read -p "Press Enter to continue..." ;;
            0) return ;;
            *) log "WARN" "Invalid choice. Please try again." ;;
        esac
    done
}

# Check all proxy name conflicts
check_all_proxy_conflicts() {
    clear
    echo -e "${CYAN}🔍 Checking for proxy name conflicts...${NC}"

    local conflicts_found=false
    local proxy_names=()

    # Collect all proxy names
    for config_file in "$CONFIG_DIR"/frpc_*.toml; do
        [[ ! -f "$config_file" ]] && continue

        while IFS= read -r line; do
            if [[ $line =~ name\ =\ \"([^\"]+)\" ]]; then
                local proxy_name="${BASH_REMATCH[1]}"

                # Check if this name already exists
                for existing_name in "${proxy_names[@]}"; do
                    if [[ "$existing_name" == "$proxy_name" ]]; then
                        log "ERROR" "❌ Duplicate proxy name found: $proxy_name"
                        log "ERROR" "   In file: $config_file"
                        conflicts_found=true
                        break
                    fi
                done

                proxy_names+=("$proxy_name")
            fi
        done < "$config_file"
    done

    if [[ "$conflicts_found" == "false" ]]; then
        log "INFO" "✅ No proxy name conflicts found"
        echo -e "${GREEN}Total unique proxy names: ${#proxy_names[@]}${NC}"
    else
        echo -e "\n${YELLOW}💡 To fix conflicts:${NC}"
        echo -e "  1. Stop conflicting services"
        echo -e "  2. Remove duplicate configurations"
        echo -e "  3. Regenerate configurations with unique names"
    fi
}

# Check all port conflicts
check_all_port_conflicts() {
    clear
    echo -e "${CYAN}🔍 Checking for port conflicts...${NC}"

    local conflicts_found=false
    local used_ports=()

    # Check FRP configuration files
    for config_file in "$CONFIG_DIR"/frpc_*.toml; do
        [[ ! -f "$config_file" ]] && continue

        while IFS= read -r line; do
            if [[ $line =~ remotePort\ =\ ([0-9]+) ]]; then
                local port="${BASH_REMATCH[1]}"

                # Check if port is already used
                for used_port in "${used_ports[@]}"; do
                    if [[ "$used_port" == "$port" ]]; then
                        log "ERROR" "❌ Duplicate port found: $port"
                        log "ERROR" "   In file: $config_file"
                        conflicts_found=true
                        break
                    fi
                done

                used_ports+=("$port")
            fi
        done < "$config_file"
    done

    # Check system port usage
    echo -e "\n${CYAN}Checking system port usage...${NC}"
    for port in "${used_ports[@]}"; do
        if netstat -tlnp 2>/dev/null | grep -q ":$port "; then
            log "WARN" "⚠️  Port $port is in use by system process"
        fi
    done

    if [[ "$conflicts_found" == "false" ]]; then
        log "INFO" "✅ No port conflicts found in FRP configurations"
        echo -e "${GREEN}Total ports configured: ${#used_ports[@]}${NC}"
    fi
}

# Validate all server connections
validate_all_connections() {
    clear
    echo -e "${CYAN}🔍 Validating all server connections...${NC}"

    local servers_checked=0
    local servers_failed=0

    for config_file in "$CONFIG_DIR"/frpc_*.toml; do
        [[ ! -f "$config_file" ]] && continue

        local server_addr=""
        local server_port=""

        while IFS= read -r line; do
            if [[ $line =~ serverAddr\ =\ \"([^\"]+)\" ]]; then
                server_addr="${BASH_REMATCH[1]}"
            elif [[ $line =~ serverPort\ =\ ([0-9]+) ]]; then
                server_port="${BASH_REMATCH[1]}"
            fi
        done < "$config_file"

        if [[ -n "$server_addr" && -n "$server_port" ]]; then
            ((servers_checked++))
            echo -e "\n${CYAN}Testing: $server_addr:$server_port${NC}"

            if ! validate_server_connection "$server_addr" "$server_port"; then
                ((servers_failed++))
            fi
        fi
    done

    echo -e "\n${CYAN}📊 Connection Summary:${NC}"
    echo -e "  Servers tested: $servers_checked"
    echo -e "  Failed connections: $servers_failed"
    if [[ $servers_checked -gt 0 ]]; then
        echo -e "  Success rate: $(( (servers_checked - servers_failed) * 100 / servers_checked ))%"
    else
        echo -e "  No servers found to test"
    fi
}

#==============================================================================
# UNIFIED LOG VIEWING SYSTEM
#==============================================================================

# Unified log viewing function
view_logs() {
    local service="$1"
    local mode="$2"        # recent|realtime|search|filter|enhanced|menu
    local filter="$3"      # time|level|keyword
    local options="$4"    # additional parameters

    # Validate inputs
    if [[ -z "$service" ]]; then
        log "ERROR" "Service name is required"
        return 1
    fi

    # Check if service exists
    if ! systemctl list-units --type=service --all --no-legend --plain | grep -q "^${service}\.service"; then
        log "ERROR" "Service '$service' not found"
        return 1
    fi

    case "$mode" in
        "recent")
            echo -e "${YELLOW}Recent logs functionality moved to view_logs_enhanced${NC}"
            ;;
        "realtime")
            echo -e "${YELLOW}Realtime logs functionality moved to view_logs_enhanced${NC}"
            ;;
        "search")
            view_logs_search "$service" "$filter"
            ;;
        "filter")
            view_logs_filter "$service" "$filter" "$options"
            ;;
        "enhanced")
            view_logs_enhanced "$service"
            ;;
        "menu")
            view_logs_menu "$service"
            ;;
        *)
            log "ERROR" "Unknown log mode: $mode"
            echo -e "${CYAN}Available modes:${NC} recent, realtime, search, filter, enhanced, menu"
            return 1
            ;;
    esac
}


# Filter logs by time
view_logs_filter_by_time() {
    local service="$1"
    local time_filter="${2:-1 hour ago}"

    echo -e "\n${YELLOW}Filtering logs since: $time_filter${NC}"
    echo -e "${GRAY}Press any key to continue...${NC}"
    
    # Color-coded time-filtered logs
    journalctl -u "$service" --since "$time_filter" --no-pager --output=short-precise | \
        sed -E 's/(ERROR|FAILED|FAIL)/\o033[31m&\o033[0m/g' | \
        sed -E 's/(WARN|WARNING)/\o033[33m&\o033[0m/g' | \
        sed -E 's/(INFO|SUCCESS)/\o033[32m&\o033[0m/g' | \
        sed -E 's/(DEBUG|TRACE)/\o033[36m&\o033[0m/g'
    
    read -n 1 -s
}

# Filter logs by level
view_logs_filter_by_level() {
    local service="$1"
    local level="${2:-ERROR}"

    echo -e "\n${YELLOW}Filtering logs by level: $level${NC}"
    echo -e "${GRAY}Press any key to continue...${NC}"
    
    # Color-coded level-filtered logs
    journalctl -u "$service" --no-pager --output=short-precise | grep -i "$level" | \
        sed -E 's/(ERROR|FAILED|FAIL)/\o033[31m&\o033[0m/g' | \
        sed -E 's/(WARN|WARNING)/\o033[33m&\o033[0m/g' | \
        sed -E 's/(INFO|SUCCESS)/\o033[32m&\o033[0m/g' | \
        sed -E 's/(DEBUG|TRACE)/\o033[36m&\o033[0m/g'
    
    read -n 1 -s
}

# Enhanced logs viewer with statistics
view_logs_enhanced() {
    local service="$1"

    while true; do
        clear
        echo -e "${PURPLE}╔══════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${PURPLE}║                            📋 Enhanced Service Logs                                 ║${NC}"
        echo -e "${PURPLE}╚══════════════════════════════════════════════════════════════════════════════════════╝${NC}"

        echo -e "\n${CYAN}📋 Service: ${YELLOW}$service${NC}"
        echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

        # Log statistics
        local total_logs=$(journalctl -u "$service" --no-pager -q | wc -l)
        local today_logs=$(journalctl -u "$service" --since today --no-pager -q | wc -l)
        local hour_logs=$(journalctl -u "$service" --since "1 hour ago" --no-pager -q | wc -l)
        local error_logs=$(journalctl -u "$service" --since "24 hours ago" --no-pager -q | grep -i error | wc -l)
        local warn_logs=$(journalctl -u "$service" --since "24 hours ago" --no-pager -q | grep -i warn | wc -l)

        echo -e "\n${CYAN}📊 Log Statistics:${NC}"
        echo -e "  Total logs: ${GREEN}$total_logs${NC}"
        echo -e "  Today: ${GREEN}$today_logs${NC}"
        echo -e "  Last hour: ${GREEN}$hour_logs${NC}"
        echo -e "  Errors (24h): ${RED}$error_logs${NC}"
        echo -e "  Warnings (24h): ${YELLOW}$warn_logs${NC}"

        echo -e "\n${CYAN}Log Viewing Options:${NC}"
        echo "1. Recent Logs (50 lines)"
        echo "2. Real-time Logs"
        echo "3. Search Logs"
        echo "4. Filter by Time"
        echo "5. Filter by Level"
        echo "6. Export Logs"
        echo "0. Back"

        echo -e "\n${YELLOW}Enter your choice [0-6]:${NC} "
        read -r choice

        case $choice in
            1) echo -e "${YELLOW}Recent logs functionality moved to view_logs_enhanced${NC}" ;;
            2) echo -e "${YELLOW}Realtime logs functionality moved to view_logs_enhanced${NC}" ;;
            3) view_logs_search "$service" ;;
            4) 
                echo -e "${YELLOW}Enter time filter (e.g., '1 hour ago', 'today', 'yesterday'):${NC} "
                read -r time_filter
                view_logs_filter_by_time "$service" "$time_filter"
                ;;
            5)
                echo -e "${YELLOW}Enter log level (ERROR, WARN, INFO, DEBUG):${NC} "
                read -r level
                view_logs_filter_by_level "$service" "$level"
                ;;
            6) export_logs "$service" ;;
            0) return ;;
            *) log "WARN" "Invalid choice. Please try again." ;;
        esac
    done
}

# Log viewing menu
view_logs_menu() {
    local service="$1"
    
    if [[ -z "$service" ]]; then
        clear
        echo -e "${CYAN}📋 Service Logs Viewer${NC}"

        local services=($(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//'))

        if [[ ${#services[@]} -eq 0 ]]; then
            echo -e "\n${YELLOW}No FRP services found${NC}"
            read -p "Press Enter to continue..."
            return
        fi

        echo -e "\n${CYAN}Available services:${NC}"
        for i in "${!services[@]}"; do
            echo "$((i+1)). ${services[$i]}"
        done

        echo -e "\n${YELLOW}Select service number:${NC} "
        read -r service_num

        if [[ ! "$service_num" =~ ^[0-9]+$ ]] || [[ $service_num -lt 1 ]] || [[ $service_num -gt ${#services[@]} ]]; then
            log "ERROR" "Invalid service number"
            return 1
        fi

        service="${services[$((service_num-1))]}"
    fi

    view_logs_enhanced "$service"
}

# View service logs
view_service_logs_menu() {
    clear
    echo -e "${CYAN}📋 Service Logs Viewer${NC}"

    local services=($(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//'))

    if [[ ${#services[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No FRP services found${NC}"
        return
    fi

    echo -e "\n${CYAN}Select service to view logs:${NC}"
    local i=1
    for service in "${services[@]}"; do
        echo "$i. $service"
        ((i++))
    done
    echo "$i. View all logs"

    echo -e "\n${YELLOW}Select service number:${NC} "
    read -r service_num

    if [[ "$service_num" == "$i" ]]; then
        # View all logs
        echo -e "\n${CYAN}All FRP Service Logs:${NC}"
        for service in "${services[@]}"; do
            echo -e "\n${YELLOW}=== $service ===${NC}"
            journalctl -u "$service" -n 10 --no-pager
        done
    elif [[ "$service_num" =~ ^[0-9]+$ ]] && [[ $service_num -ge 1 ]] && [[ $service_num -le ${#services[@]} ]]; then
        local selected_service="${services[$((service_num-1))]}"
        echo -e "\n${CYAN}Logs for $selected_service:${NC}"
        journalctl -u "$selected_service" -n 50 --no-pager
    else
        log "ERROR" "Invalid service number"
    fi
}

# Fix common issues
fix_common_issues() {
    clear
    echo -e "${CYAN}🔧 Fix Common Issues${NC}"

    echo -e "\n${CYAN}Available fixes:${NC}"
    echo "1. Remove duplicate proxy configurations"
    echo "2. Reset all client configurations"
    echo "3. Fix service permissions"
    echo "4. Clear log files"
    echo "5. Restart all services"
    echo "0. Back"

    echo -e "\n${YELLOW}Select fix [0-5]:${NC} "
    read -r fix_choice

    case $fix_choice in
        1)
            echo -e "\n${YELLOW}This will backup and recreate all client configs. Continue? (y/N):${NC} "
            read -r confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                cleanup_old_configs "backup"
                log "INFO" "Please recreate configurations from main menu"
            fi
            ;;
        2)
            echo -e "\n${RED}This will remove ALL client configurations! Continue? (y/N):${NC} "
            read -r confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                remove_all_services
                rm -f "$CONFIG_DIR"/frpc_*.toml
                log "INFO" "All client configurations removed"
            fi
            ;;
        3)
            chmod +x "$FRP_DIR"/frp*
            chown root:root "$FRP_DIR"/frp*
            chmod 644 "$CONFIG_DIR"/*.toml 2>/dev/null || true
            log "INFO" "Fixed file permissions"
            ;;
        4)
            rm -f "$LOG_DIR"/*.log
            log "INFO" "Cleared all log files"
            ;;
        5)
            local services=($(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//'))
            for service in "${services[@]}"; do
                restart_service "$service"
            done
            log "INFO" "Restarted all FRP services"
            ;;
        0)
            return
            ;;
        *)
            log "ERROR" "Invalid choice"
            ;;
    esac
}

# Generate diagnostic report
generate_diagnostic_report() {
    clear
    echo -e "${CYAN}📋 Generating diagnostic report...${NC}"

    local report_file="/tmp/moonfrp_diagnostic_$(date +%Y%m%d_%H%M%S).txt"

    {
        echo "MoonFRP Diagnostic Report"
        echo "Generated on: $(date)"
        echo "System: $(uname -a)"
        echo

        echo "=== FRP Installation ==="
        echo "FRP Directory: $FRP_DIR"
        ls -la "$FRP_DIR" 2>/dev/null || echo "FRP not installed"
        echo

        echo "=== Configuration Files ==="
        echo "Config Directory: $CONFIG_DIR"
        ls -la "$CONFIG_DIR" 2>/dev/null || echo "No configs found"
        echo

        echo "=== Services Status ==="
        systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" || echo "No FRP services found"
        echo

        echo "=== Network Connectivity ==="
        for config_file in "$CONFIG_DIR"/frpc_*.toml; do
            [[ ! -f "$config_file" ]] && continue

            local server_addr=""
            local server_port=""

            while IFS= read -r line; do
                if [[ $line =~ serverAddr\ =\ \"([^\"]+)\" ]]; then
                    server_addr="${BASH_REMATCH[1]}"
                elif [[ $line =~ serverPort\ =\ ([0-9]+) ]]; then
                    server_port="${BASH_REMATCH[1]}"
                fi
            done < "$config_file"

            if [[ -n "$server_addr" && -n "$server_port" ]]; then
                echo "Testing $server_addr:$server_port"
                timeout 3 nc -z "$server_addr" "$server_port" && echo "  ✅ Connected" || echo "  ❌ Failed"
            fi
        done
        echo

        echo "=== Recent Logs ==="
        for service in $(systemctl list-units --type=service --all --no-legend --plain | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//'); do
            echo "--- $service ---"
            journalctl -u "$service" -n 5 --no-pager 2>/dev/null || echo "No logs found"
            echo
        done

    } > "$report_file"

    log "INFO" "Diagnostic report saved to: $report_file"
    echo -e "\n${CYAN}Report preview:${NC}"
    head -30 "$report_file"
    echo -e "\n${YELLOW}... (truncated, see full report in file)${NC}"
}

# Show about and version information
show_about_info() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║         MoonFRP About & Info         ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    echo -e "\n${CYAN}📋 Version Information:${NC}"
    echo -e "  MoonFRP Version: ${GREEN}v$MOONFRP_VERSION${NC}"
    echo -e "  FRP Version: ${GREEN}v$FRP_VERSION${NC}"
    echo -e "  Architecture: ${GREEN}$FRP_ARCH${NC}"

    echo -e "\n${CYAN}💻 System Information:${NC}"
    echo -e "  OS: ${GREEN}$(uname -s)${NC}"
    echo -e "  Kernel: ${GREEN}$(uname -r)${NC}"
    echo -e "  Architecture: ${GREEN}$(uname -m)${NC}"
    echo -e "  Hostname: ${GREEN}$(hostname)${NC}"

    echo -e "\n${CYAN}📁 Installation Paths:${NC}"
    echo -e "  Script Location: ${GREEN}$MOONFRP_INSTALL_PATH${NC}"
    echo -e "  FRP Binaries: ${GREEN}$FRP_DIR${NC}"
    echo -e "  Configurations: ${GREEN}$CONFIG_DIR${NC}"
    echo -e "  Log Files: ${GREEN}$LOG_DIR${NC}"

    echo -e "\n${CYAN}🔗 Repository Information:${NC}"
    echo -e "  GitHub: ${GREEN}https://github.com/k4lantar4/moonfrp${NC}"
    echo -e "  Issues: ${GREEN}https://github.com/k4lantar4/moonfrp/issues${NC}"
    echo -e "  Latest Releases: ${GREEN}https://github.com/k4lantar4/moonfrp/releases${NC}"

    echo -e "\n${CYAN}📊 Current Status:${NC}"

    # Check FRP installation
    if check_frp_installation; then
        echo -e "  FRP Installation: ${GREEN}✅ Installed${NC}"
        echo -e "    frps: $(ls -la $FRP_DIR/frps 2>/dev/null | awk '{print $5, $6, $7, $8}' || echo 'Not found')"
        echo -e "    frpc: $(ls -la $FRP_DIR/frpc 2>/dev/null | awk '{print $5, $6, $7, $8}' || echo 'Not found')"
    else
        echo -e "  FRP Installation: ${RED}❌ Not Installed${NC}"
    fi

    # Check services
    local services=($(systemctl list-units --type=service --all --no-legend --plain 2>/dev/null | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//' || echo ""))
    if [[ ${#services[@]} -gt 0 ]] && [[ "${services[0]}" != "" ]]; then
        echo -e "  Active Services: ${GREEN}${#services[@]} service(s)${NC}"
        for service in "${services[@]}"; do
            local status=$(get_service_status "$service")
            local status_icon="❌"
            local status_color="$RED"
            [[ "$status" == "active" ]] && status_icon="✅" && status_color="$GREEN"
            echo -e "    $status_icon $service: ${status_color}$status${NC}"
        done
    else
        echo -e "  Active Services: ${YELLOW}⚠️  No services found${NC}"
    fi

    # Check configurations
    local config_count=$(ls "$CONFIG_DIR"/*.toml 2>/dev/null | wc -l)
    if [[ $config_count -gt 0 ]]; then
        echo -e "  Configurations: ${GREEN}✅ $config_count file(s)${NC}"
    else
        echo -e "  Configurations: ${YELLOW}⚠️  No configurations found${NC}"
    fi

    # Check update status
    echo -e "\n${CYAN}🔄 Update Status:${NC}"
    local update_status=0
    check_moonfrp_updates >/dev/null 2>&1
    update_status=$?

    case $update_status in
        0)
            echo -e "  Status: ${YELLOW}⚠️  Update available${NC}"
            echo -e "  Action: ${GREEN}Use menu option 6 to update${NC}"
            ;;
        1)
            echo -e "  Status: ${GREEN}✅ Up to date${NC}"
            ;;
        *)
            echo -e "  Status: ${BLUE}ℹ️  Cannot check (offline)${NC}"
            ;;
    esac

    echo -e "\n${CYAN}ℹ️  Quick Commands:${NC}"
    echo -e "  Check logs: ${GREEN}journalctl -u moonfrp-* -f${NC}"
    echo -e "  Restart services: ${GREEN}systemctl restart moonfrp-*${NC}"
    echo -e "  Check status: ${GREEN}systemctl status moonfrp-*${NC}"

    echo -e "\n${YELLOW}💡 Need Help?${NC}"
    echo -e "  • Use menu option 6 for troubleshooting"
    echo -e "  • Check the GitHub repository for documentation"
    echo -e "  • Submit issues for bugs or feature requests"

    echo -e "\n${CYAN}📝 Recent Updates (v$MOONFRP_VERSION):${NC}"
    echo -e "  ✨ Auto-update functionality added"
    echo -e "  🔧 Advanced troubleshooting tools"
    echo -e "  🛡️ Improved proxy conflict resolution"
    echo -e "  📊 Enhanced diagnostic reporting"
    echo -e "  🚀 Better error handling and validation"

    echo -e "\n${GREEN}🌙 Thank you for using MoonFRP!${NC}"

    read -p "Press Enter to continue..."
}

# Real-time status monitor
real_time_status_monitor() {
    # Initialize monitoring
    local update_interval=2
    local iteration=0
    local last_refresh=0

    # Trap Ctrl+C for clean exit
    trap 'echo -e "\n${GREEN}Monitoring stopped${NC}"; read -p "Press Enter to continue..."; trap - INT; return' INT

    echo -e "${CYAN}🔄 Starting real-time monitoring...${NC}"
    echo -e "${YELLOW}Press Ctrl+C to exit monitoring${NC}"
    sleep 1

    while true; do
        ((iteration++))
        local current_time=$(date +%s)

        # Only refresh if enough time has passed (prevent flicker)
        if [[ $((current_time - last_refresh)) -ge $update_interval ]]; then
            last_refresh=$current_time

            # Use more stable clear method
            printf '\033[2J\033[H'

            # Header with fixed position
            echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
            echo -e "${PURPLE}║        Real-time Status Monitor     ║${NC}"
            echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

            echo -e "${CYAN}📊 Live Status (Update #$iteration - Every ${update_interval}s)${NC}"
            echo -e "${GRAY}$(date)${NC}"
            echo ""

            # Get all services with fresh data (avoid cache issues)
            local services=($(systemctl list-units --type=service --no-legend --plain 2>/dev/null | grep -E "(moonfrp|frp)" | awk '{print $1}' | sed 's/\.service//'))

            if [[ ${#services[@]} -eq 0 ]]; then
                echo -e "${YELLOW}⚠️  No FRP services found${NC}"
                echo ""
            fi

            # Services status table (stable layout)
            printf "%-25s %-12s %-15s %-20s\n" "Service" "Status" "Type" "Uptime"
            printf "%-25s %-12s %-15s %-20s\n" "-------" "------" "----" "------"

            if [[ ${#services[@]} -eq 0 ]]; then
                printf "%-25s %-12s %-15s %-20s\n" "No services found" "${YELLOW}N/A${NC}" "N/A" "N/A"
            else
                for service in "${services[@]}"; do
                    [[ -z "$service" ]] && continue

                    # Get status efficiently
                    local status=$(systemctl is-active "$service" 2>/dev/null || echo "inactive")
                    local type="Unknown"
                    local uptime="N/A"

                    # Determine service type
                    if [[ "$service" =~ (frps|moonfrps) ]]; then
                        type="Server"
                    elif [[ "$service" =~ (frpc|moonfrpc) ]]; then
                        type="Client"
                    fi

                    # Get uptime for active services
                    if [[ "$status" == "active" ]]; then
                        uptime=$(systemctl show -p ActiveEnterTimestamp "$service" 2>/dev/null | cut -d= -f2-)
                        if [[ -n "$uptime" && "$uptime" != "n/a" ]]; then
                            local start_time=$(date -d "$uptime" +%s 2>/dev/null || echo "0")
                            local current_time=$(date +%s)
                            local diff=$((current_time - start_time))

                            if [[ $diff -gt 86400 ]]; then
                                uptime="$((diff / 86400))d"
                            elif [[ $diff -gt 3600 ]]; then
                                uptime="$((diff / 3600))h"
                            elif [[ $diff -gt 60 ]]; then
                                uptime="$((diff / 60))m"
                            else
                                uptime="${diff}s"
                            fi
                        else
                            uptime="unknown"
                        fi
                    fi

                    # Color status
                    local status_color="$RED"
                    case "$status" in
                        "active") status_color="$GREEN" ;;
                        "inactive") status_color="$RED" ;;
                        "activating") status_color="$YELLOW" ;;
                        "deactivating") status_color="$YELLOW" ;;
                        "failed") status_color="$RED" ;;
                        *) status_color="$GRAY" ;;
                    esac

                    printf "%-25s ${status_color}%-12s${NC} %-15s %-20s\n" \
                        "${service:0:24}" "$status" "$type" "$uptime"
                done
            fi

        # Configuration files status (always show)
        echo ""
        echo -e "${CYAN}📁 Configuration Files:${NC}"
        printf "%-30s %-10s %-15s\n" "File" "Size" "Modified"
        printf "%-30s %-10s %-15s\n" "----" "----" "--------"

        local config_found=false
        for config_file in "$CONFIG_DIR"/*.toml; do
            [[ ! -f "$config_file" ]] && continue

            local filename=$(basename "$config_file")
            local filesize=$(ls -lh "$config_file" | awk '{print $5}')
            local modified=$(stat -c %y "$config_file" 2>/dev/null | cut -d' ' -f1 || echo "Unknown")

            printf "%-30s %-10s %-15s\n" "$filename" "$filesize" "$modified"
            config_found=true
        done

        if [[ "$config_found" == "false" ]]; then
            printf "%-30s %-10s %-15s\n" "No config files found" "N/A" "N/A"
        fi

        # Connection status for clients (always show)
        echo ""
        echo -e "${CYAN}🌐 Connection Status:${NC}"

        local client_found=false
        for config_file in "$CONFIG_DIR"/frpc_*.toml; do
            [[ ! -f "$config_file" ]] && continue

            # Skip visitor configuration files
            [[ "$config_file" =~ visitor ]] && continue

            local server_addr=""
            local server_port=""
            local ip_suffix=$(basename "$config_file" | sed 's/frpc_//' | sed 's/.toml//')

            # Extract server info
            while IFS= read -r line; do
                if [[ $line =~ serverAddr\ =\ \"([^\"]+)\" ]]; then
                    server_addr="${BASH_REMATCH[1]}"
                elif [[ $line =~ serverPort\ =\ ([0-9]+) ]]; then
                    server_port="${BASH_REMATCH[1]}"
                fi
            done < "$config_file"

            if [[ -n "$server_addr" && -n "$server_port" ]]; then
                # Count proxies in this config
                local proxy_count=$(grep -c "^\[\[proxies\]\]" "$config_file" 2>/dev/null || echo "0")

                # Get all ports from config
                local ports_in_config=()
                while IFS= read -r line; do
                    if [[ $line =~ localPort\ =\ ([0-9]+) ]]; then
                        ports_in_config+=("${BASH_REMATCH[1]}")
                    fi
                done < "$config_file"

                # Format ports list
                local ports_list=""
                if [[ ${#ports_in_config[@]} -gt 0 ]]; then
                    IFS=','
                    ports_list="${ports_in_config[*]}"
                    IFS=' '  # Reset IFS
                fi

                # Check service status
                local service_name="moonfrpc-$ip_suffix"
                local service_status=$(systemctl is-active "$service_name" 2>/dev/null || echo "inactive")
                local status_icon="❌"
                local status_color="$RED"

                if [[ "$service_status" == "active" ]]; then
                    status_icon="✅"
                    status_color="$GREEN"
                fi

                printf "    %-15s -> %-20s [%s] " \
                    "Client-$ip_suffix" "$server_addr" "$ports_list"
                echo -e "${status_color}${status_icon}${NC}"
                client_found=true
            fi
        done

        if [[ "$client_found" == "false" ]]; then
            echo "    No client configurations found (Server-only mode)"
        fi

        # Show server dashboard info if available
        echo ""
        echo -e "${CYAN}📊 Server Dashboard:${NC}"

        local dashboard_found=false
        if [[ -f "$CONFIG_DIR/frps.toml" ]]; then
            local dashboard_port=""
            local dashboard_user=""
            local bind_port=""

            while IFS= read -r line; do
                if [[ $line =~ webServer\.port\ =\ ([0-9]+) ]]; then
                    dashboard_port="${BASH_REMATCH[1]}"
                elif [[ $line =~ webServer\.user\ =\ \"([^\"]+)\" ]]; then
                    dashboard_user="${BASH_REMATCH[1]}"
                elif [[ $line =~ ^bindPort\ =\ ([0-9]+) ]]; then
                    bind_port="${BASH_REMATCH[1]}"
                fi
            done < "$CONFIG_DIR/frps.toml"

            if [[ -n "$dashboard_port" ]]; then
                echo "Dashboard: http://localhost:$dashboard_port (User: $dashboard_user)"
                echo "Server Port: $bind_port"
                dashboard_found=true
            fi
        fi

        if [[ "$dashboard_found" == "false" ]]; then
            echo "No server dashboard configured"
        fi

        # Show proxy information for active services
        echo ""
        echo -e "${CYAN}🚀 Active Proxies:${NC}"

        local proxy_found=false
        for config_file in "$CONFIG_DIR"/*.toml; do
            [[ ! -f "$config_file" ]] && continue

            local filename=$(basename "$config_file")
            local proxy_count=$(grep -c "^\[\[proxies\]\]" "$config_file" 2>/dev/null || echo "0")
            # Ensure proxy_count is a valid number
            [[ ! "$proxy_count" =~ ^[0-9]+$ ]] && proxy_count=0

            if [[ "$proxy_count" -gt 0 ]]; then
                printf "%-30s %s proxies\n" "$filename" "$proxy_count"
                proxy_found=true

                # Show proxy details
                local proxy_names=()
                while IFS= read -r line; do
                    if [[ $line =~ name\ =\ \"([^\"]+)\" ]]; then
                        proxy_names+=("${BASH_REMATCH[1]}")
                    fi
                done < "$config_file"

                if [[ ${#proxy_names[@]} -gt 0 ]]; then
                    local names_str=$(printf ", %s" "${proxy_names[@]}")
                    names_str=${names_str:2}  # Remove leading ", "
                    echo "  └─ Proxies: $names_str"
                fi
            fi
        done

        if [[ "$proxy_found" == "false" ]]; then
            echo "No active proxies found"
        fi

        # Show system resources
        echo ""
        echo -e "${CYAN}💻 System Resources:${NC}"

        # Memory usage
        local mem_info=$(free -h | grep "Mem:" | awk '{print $3 "/" $2}')
        echo "Memory: $mem_info"

        # CPU load
        local cpu_load=$(uptime | awk -F'load average:' '{print $2}' | sed 's/^ *//')
        echo "Load: $cpu_load"

        # Network connections
        local tcp_connections=$(ss -t state established 2>/dev/null | wc -l)
        if [[ "$tcp_connections" -gt 0 ]]; then
            ((tcp_connections--))  # Remove header line
        fi
        echo "TCP Connections: $tcp_connections"

        echo ""
        echo -e "${GRAY}Press Ctrl+C to exit monitoring${NC}"


            echo ""
            echo -e "${GRAY}Last update: $(date '+%H:%M:%S') | Next update in ${update_interval}s | Press Ctrl+C to exit${NC}"
        fi

        # Short sleep to prevent busy waiting
        sleep 0.5
    done
}

# Show current configuration summary
show_current_config_summary() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║      Configuration Summary          ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    echo -e "\n${CYAN}📋 Current MoonFRP Configuration:${NC}"

    # Server configurations
    echo -e "\n${GREEN}🏠 Server Configurations (Iran):${NC}"
    if [[ -f "$CONFIG_DIR/frps.toml" ]]; then
        local bind_port=""
        local token=""
        local dashboard_port=""

        while IFS= read -r line; do
            if [[ $line =~ ^bindPort\ =\ ([0-9]+) ]]; then
                bind_port="${BASH_REMATCH[1]}"
            elif [[ $line =~ auth\.token\ =\ \"([^\"]+)\" ]]; then
                token="${BASH_REMATCH[1]}"
            elif [[ $line =~ webServer\.port\ =\ ([0-9]+) ]]; then
                dashboard_port="${BASH_REMATCH[1]}"
            fi
        done < "$CONFIG_DIR/frps.toml"

        echo -e "  ${CYAN}Server Port:${NC} ${GREEN}$bind_port${NC}"
        echo -e "  ${CYAN}Auth Token:${NC} ${GREEN}${token:0:8}...${NC}"
        [[ -n "$dashboard_port" ]] && echo -e "  ${CYAN}Dashboard:${NC} ${GREEN}http://SERVER-IP:$dashboard_port${NC}"

        # Share with clients information - Auto-detect public IPs
        local primary_ip=$(hostname -I | awk '{print $1}')
        local public_ips=$(hostname -I | tr ' ' '\n' | grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$' | grep -v -E '^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.)' | tr '\n' ',' | sed 's/,$//')
        [[ -z "$public_ips" ]] && public_ips="$primary_ip"

        echo -e "\n  ${CYAN}3. Share with clients:${NC}"
        echo -e "     ${YELLOW}• Server IPs:${NC} ${GREEN}$public_ips${NC}"
        echo -e "     ${YELLOW}• Server Port:${NC} ${GREEN}$bind_port${NC}"
        echo -e "     ${YELLOW}• Token:${NC} ${GREEN}$token${NC}"

        # Check server status
        local server_services=($(systemctl list-units --type=service --state=active --no-legend --plain 2>/dev/null | grep moonfrps | awk '{print $1}' | sed 's/\.service//'))
        if [[ ${#server_services[@]} -gt 0 ]]; then
            echo -e "  ${CYAN}Status:${NC} ${GREEN}✅ Active (${#server_services[@]} service(s))${NC}"
        else
            echo -e "  ${CYAN}Status:${NC} ${RED}❌ Inactive${NC}"
        fi
    else
        echo -e "  ${YELLOW}No server configuration found${NC}"
    fi

    # Client configurations
    echo -e "\n${GREEN}🌍 Client Configurations (Foreign):${NC}"

    local client_configs=($(ls "$CONFIG_DIR"/frpc_*.toml 2>/dev/null))
    if [[ ${#client_configs[@]} -gt 0 ]]; then
        local all_ips=()
        local all_ports=()
        local common_token=""
        local total_proxies=0

        echo -e "  ${CYAN}Total Configs:${NC} ${GREEN}${#client_configs[@]}${NC}"

        for config_file in "${client_configs[@]}"; do
            local server_addr=""
            local server_port=""
            local token=""
            local proxy_count=0
            local ports_in_config=()

            while IFS= read -r line; do
                if [[ $line =~ serverAddr\ =\ \"([^\"]+)\" ]]; then
                    server_addr="${BASH_REMATCH[1]}"
                elif [[ $line =~ serverPort\ =\ ([0-9]+) ]]; then
                    server_port="${BASH_REMATCH[1]}"
                elif [[ $line =~ auth\.token\ =\ \"([^\"]+)\" ]]; then
                    token="${BASH_REMATCH[1]}"
                elif [[ $line =~ localPort\ =\ ([0-9]+) ]]; then
                    ports_in_config+=("${BASH_REMATCH[1]}")
                    ((total_proxies++))
                fi
            done < "$config_file"

            # Collect unique IPs and ports
            [[ -n "$server_addr" ]] && ! printf '%s\n' "${all_ips[@]}" | grep -q "^${server_addr}$" && all_ips+=("$server_addr")
            [[ -n "$server_port" ]] && ! printf '%s\n' "${all_ports[@]}" | grep -q "^${server_port}$" && all_ports+=("$server_port")
            [[ -z "$common_token" ]] && common_token="$token"
        done

        # Display summary
        local ips_str=$(IFS=','; echo "${all_ips[*]}")
        local ports_str=$(IFS=','; echo "${all_ports[*]}")

        echo -e "  ${CYAN}Server IPs:${NC} ${GREEN}$ips_str${NC}"
        echo -e "  ${CYAN}Server Ports:${NC} ${GREEN}$ports_str${NC}"
        echo -e "  ${CYAN}Auth Token:${NC} ${GREEN}${common_token:0:8}...${NC}"
        echo -e "  ${CYAN}Total Proxies:${NC} ${GREEN}$total_proxies${NC}"

        # Show per-config details
        echo -e "\n  ${YELLOW}Per-Configuration Details:${NC}"
        for config_file in "${client_configs[@]}"; do
            local ip_suffix=$(basename "$config_file" | sed 's/frpc_//' | sed 's/.toml//')
            local config_ports=()
            local server_ip=""

            while IFS= read -r line; do
                if [[ $line =~ localPort\ =\ ([0-9]+) ]]; then
                    config_ports+=("${BASH_REMATCH[1]}")
                elif [[ $line =~ serverAddr\ =\ \"([^\"]+)\" ]]; then
                    server_ip="${BASH_REMATCH[1]}"
                fi
            done < "$config_file"

            local ports_list=$(IFS=','; echo "${config_ports[*]}")
            local service_name="moonfrpc-$ip_suffix"
            local service_status=$(systemctl is-active "$service_name" 2>/dev/null || echo "inactive")
            local status_icon="❌"
            local status_color="$RED"

            [[ "$service_status" == "active" ]] && status_icon="✅" && status_color="$GREEN"

            printf "    %-15s -> %-15s [%s] " \
                "Client-$ip_suffix" "$server_ip" "$ports_list"
            echo -e "${status_color}${status_icon}${NC}"
        done

        # Connection tests
        echo -e "\n  ${CYAN}🔗 Quick Connection Test:${NC}"
        for ip in "${all_ips[@]}"; do
            for port in "${all_ports[@]}"; do
                printf "    %-20s " "$ip:$port"
                if timeout 2 nc -z "$ip" "$port" 2>/dev/null; then
                    echo -e "${GREEN}✅ OK${NC}"
                else
                    echo -e "${RED}❌ Failed${NC}"
                fi
            done
        done

    else
        echo -e "  ${YELLOW}No client configurations found${NC}"
    fi

    # System information
    echo -e "\n${GREEN}🖥️  System Information:${NC}"
    echo -e "  ${CYAN}FRP Version:${NC} ${GREEN}v$FRP_VERSION${NC}"
    echo -e "  ${CYAN}MoonFRP Version:${NC} ${GREEN}v$MOONFRP_VERSION${NC}"
    echo -e "  ${CYAN}Config Directory:${NC} ${GREEN}$CONFIG_DIR${NC}"
    echo -e "  ${CYAN}Log Directory:${NC} ${GREEN}$LOG_DIR${NC}"

    # Services overview
    local active_services=$(systemctl list-units --type=service --state=active --no-legend --plain 2>/dev/null | grep -E "(moonfrps|moonfrpc)" | wc -l)
    local total_services=$(systemctl list-units --type=service --all --no-legend --plain 2>/dev/null | grep -E "(moonfrps|moonfrpc)" | wc -l)

    echo -e "  ${CYAN}Services:${NC} ${GREEN}$active_services active${NC} / ${YELLOW}$total_services total${NC}"

    echo -e "\n${YELLOW}💡 Quick Actions:${NC}"
    echo -e "  • Restart all: ${GREEN}systemctl restart moonfrp*${NC}"
    echo -e "  • Check logs: ${GREEN}journalctl -u moonfrp* -f${NC}"
    echo -e "  • Stop all: ${GREEN}systemctl stop moonfrp*${NC}"

    read -p "Press Enter to continue..."
}

# Fix web panel issues (HTTP 503 and similar)
fix_web_panel_issues() {
    clear
    echo -e "${PURPLE}╔══════════════════════════════════════╗${NC}"
    echo -e "${PURPLE}║       FRP Web Panel Diagnostics     ║${NC}"
    echo -e "${PURPLE}╚══════════════════════════════════════╝${NC}"

    echo -e "\n${CYAN}🔍 Diagnosing web panel issues...${NC}"

    # Check if frps service is running
    local server_running=false
    local dashboard_port=""
    local dashboard_user=""
    local dashboard_password=""

    if systemctl status moonfrp-server >/dev/null 2>&1; then
        server_running=true
        echo -e "${GREEN}✅ FRP Server service is running${NC}"
    else
        echo -e "${RED}❌ FRP Server service is NOT running${NC}"
        echo -e "${YELLOW}Attempting to start server...${NC}"

        if systemctl status moonfrp-server 2>/dev/null; then
            echo -e "${GREEN}✅ Server started successfully${NC}"
            server_running=true
            sleep 3
        else
            echo -e "${RED}❌ Failed to start server${NC}"
            echo -e "${CYAN}Checking server configuration...${NC}"
        fi
    fi

    # Read dashboard configuration from frps.toml
    if [[ -f "$CONFIG_DIR/frps.toml" ]]; then
        echo -e "\n${CYAN}📋 Reading dashboard configuration...${NC}"

        while IFS= read -r line; do
            if [[ $line =~ webServer\.port\ *=\ *([0-9]+) ]]; then
                dashboard_port="${BASH_REMATCH[1]}"
            elif [[ $line =~ webServer\.user\ *=\ *\"([^\"]+)\" ]]; then
                dashboard_user="${BASH_REMATCH[1]}"
            elif [[ $line =~ webServer\.password\ *=\ *\"([^\"]+)\" ]]; then
                dashboard_password="${BASH_REMATCH[1]}"
            fi
        done < "$CONFIG_DIR/frps.toml"

        if [[ -n "$dashboard_port" ]]; then
            echo -e "  Dashboard Port: ${GREEN}$dashboard_port${NC}"
        else
            echo -e "  Dashboard Port: ${RED}Not configured${NC}"
            dashboard_port="7500"
        fi

        if [[ -n "$dashboard_user" ]]; then
            echo -e "  Dashboard User: ${GREEN}$dashboard_user${NC}"
        else
            echo -e "  Dashboard User: ${RED}Not configured${NC}"
            dashboard_user="admin"
        fi

        if [[ -n "$dashboard_password" ]]; then
            echo -e "  Dashboard Password: ${GREEN}$dashboard_password${NC}"
        else
            echo -e "  Dashboard Password: ${RED}Not configured${NC}"
            dashboard_password="admin"
        fi
    else
        echo -e "\n${RED}❌ Server configuration file not found: $CONFIG_DIR/frps.toml${NC}"
        echo -e "${YELLOW}Please create server configuration first${NC}"
        return
    fi

    # Test dashboard port accessibility
    echo -e "\n${CYAN}🔌 Testing dashboard port accessibility...${NC}"

    # Check if port is listening
    if netstat -tlnp 2>/dev/null | grep -q ":$dashboard_port "; then
        echo -e "${GREEN}✅ Port $dashboard_port is listening${NC}"

        # Test HTTP connection
        echo -e "${CYAN}🌐 Testing HTTP connection...${NC}"

        local test_url="http://127.0.0.1:$dashboard_port"
        local http_status=""

        if command -v curl >/dev/null 2>&1; then
            http_status=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 "$test_url" 2>/dev/null || echo "000")

            case "$http_status" in
                "200")
                    echo -e "${GREEN}✅ HTTP 200: Dashboard is accessible${NC}"
                    ;;
                "401")
                    echo -e "${YELLOW}⚠️  HTTP 401: Authentication required (Normal)${NC}"
                    ;;
                "403")
                    echo -e "${YELLOW}⚠️  HTTP 403: Access forbidden - check credentials${NC}"
                    ;;
                "503")
                    echo -e "${RED}❌ HTTP 503: Service unavailable - server issue${NC}"
                    ;;
                "000")
                    echo -e "${RED}❌ Connection failed - service not responding${NC}"
                    ;;
                *)
                    echo -e "${YELLOW}⚠️  HTTP $http_status: Unexpected response${NC}"
                    ;;
            esac
        else
            echo -e "${YELLOW}⚠️  curl not available for HTTP testing${NC}"
        fi

    else
        echo -e "${RED}❌ Port $dashboard_port is NOT listening${NC}"
        echo -e "${YELLOW}Dashboard service may not be properly configured or started${NC}"
    fi

    # Check firewall
    echo -e "\n${CYAN}🔥 Checking firewall status...${NC}"

    if command -v ufw >/dev/null 2>&1; then
        local ufw_status=$(ufw status 2>/dev/null | grep -E "(Status: active|Status: inactive)" || echo "unknown")

        if [[ "$ufw_status" =~ "active" ]]; then
            echo -e "${YELLOW}⚠️  UFW firewall is active${NC}"

            if ufw status 2>/dev/null | grep -q "$dashboard_port"; then
                echo -e "${GREEN}✅ Port $dashboard_port is allowed in firewall${NC}"
            else
                echo -e "${RED}❌ Port $dashboard_port is NOT allowed in firewall${NC}"
                echo -e "${CYAN}Suggestion: sudo ufw allow $dashboard_port/tcp${NC}"
            fi
        else
            echo -e "${GREEN}✅ UFW firewall is inactive${NC}"
        fi
    else
        echo -e "${BLUE}ℹ️  UFW not installed, checking iptables...${NC}"

        if command -v iptables >/dev/null 2>&1; then
            local iptables_rules=$(iptables -L INPUT -n 2>/dev/null | grep -c "$dashboard_port" || echo "0")
            if [[ "$iptables_rules" -gt 0 ]]; then
                echo -e "${GREEN}✅ Found iptables rules for port $dashboard_port${NC}"
            else
                echo -e "${YELLOW}⚠️  No specific iptables rules found for port $dashboard_port${NC}"
            fi
        fi
    fi

    # Show fix options
    echo -e "\n${CYAN}🔧 Available Fixes:${NC}"
    echo "1. Restart FRP Server"
    echo "2. Regenerate Server Configuration"
    echo "3. Open Firewall Port"
    echo "4. Check Service Logs"
    echo "5. Test Dashboard Access"
    echo "6. Show Access Information"
    echo "0. Back"

    echo -e "\n${YELLOW}Select fix option [0-6]:${NC} "
    read -r fix_option

    case $fix_option in
        1)
            echo -e "\n${CYAN}🔄 Restarting FRP Server...${NC}"
            systemctl status moonfrp-server
            sleep 3

            if systemctl status moonfrp-server >/dev/null 2>&1; then
                echo -e "${GREEN}✅ Server restarted successfully${NC}"
                echo -e "${CYAN}Wait 10 seconds then try accessing the dashboard${NC}"
            else
                echo -e "${RED}❌ Failed to restart server${NC}"
                echo -e "${CYAN}Check logs: journalctl -u moonfrp-server -n 20${NC}"
            fi
            ;;
        2)
            echo -e "\n${YELLOW}⚠️  This will regenerate server configuration${NC}"
            echo -e "${YELLOW}Current settings will be backed up${NC}"
            echo -e "\n${YELLOW}Continue? (y/N):${NC} "
            read -r confirm

            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                # Backup current config
                [[ -f "$CONFIG_DIR/frps.toml" ]] && cp "$CONFIG_DIR/frps.toml" "$CONFIG_DIR/frps.toml.backup.$(date +%s)"

                # Regenerate config
                local new_token=$(generate_token)
                generate_frps_config "$new_token" "7000" "$dashboard_port" "$dashboard_user" "$dashboard_password"

                # Restart service
                systemctl status moonfrp-server

                echo -e "${GREEN}✅ Configuration regenerated and service restarted${NC}"
            fi
            ;;
        3)
            echo -e "\n${CYAN}🔥 Opening firewall port $dashboard_port...${NC}"

            if command -v ufw >/dev/null 2>&1; then
                ufw allow "$dashboard_port/tcp"
                echo -e "${GREEN}✅ UFW rule added for port $dashboard_port${NC}"
            elif command -v iptables >/dev/null 2>&1; then
                iptables -A INPUT -p tcp --dport "$dashboard_port" -j ACCEPT
                echo -e "${GREEN}✅ iptables rule added for port $dashboard_port${NC}"
                echo -e "${YELLOW}⚠️  Rule is temporary, save with: iptables-save${NC}"
            else
                echo -e "${YELLOW}⚠️  No supported firewall found${NC}"
            fi
            ;;
        4)
            echo -e "\n${CYAN}📋 Recent server logs:${NC}"
            journalctl -u moonfrp-server -n 20 --no-pager
            ;;
        5)
            echo -e "\n${CYAN}🌐 Testing dashboard access...${NC}"

            local server_ip=$(hostname -I | awk '{print $1}')
            local test_urls=(
                "http://127.0.0.1:$dashboard_port"
                "http://localhost:$dashboard_port"
                "http://$server_ip:$dashboard_port"
            )

            for url in "${test_urls[@]}"; do
                echo -e "\nTesting: $url"

                if command -v curl >/dev/null 2>&1; then
                    local status=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 3 "$url" 2>/dev/null || echo "000")
                    case "$status" in
                        "200"|"401") echo -e "  ${GREEN}✅ Accessible (HTTP $status)${NC}" ;;
                        "503") echo -e "  ${RED}❌ Service Unavailable (HTTP 503)${NC}" ;;
                        "000") echo -e "  ${RED}❌ Connection Failed${NC}" ;;
                        *) echo -e "  ${YELLOW}⚠️  HTTP $status${NC}" ;;
                    esac
                else
                    echo -e "  ${YELLOW}⚠️  curl not available for testing${NC}"
                fi
            done
            ;;
        6)
            local server_ip=$(hostname -I | awk '{print $1}')
            echo -e "\n${CYAN}🌐 Dashboard Access Information:${NC}"
            echo -e "${GREEN}URLs to try:${NC}"
            echo -e "  • http://127.0.0.1:$dashboard_port"
            echo -e "  • http://localhost:$dashboard_port"
            echo -e "  • http://$server_ip:$dashboard_port"
            echo -e "  • http://YOUR-PUBLIC-IP:$dashboard_port"
            echo -e "\n${GREEN}Credentials:${NC}"
            echo -e "  Username: ${CYAN}$dashboard_user${NC}"
            echo -e "  Password: ${CYAN}$dashboard_password${NC}"
            echo -e "\n${YELLOW}💡 Notes:${NC}"
            echo -e "  • Make sure firewall allows port $dashboard_port"
            echo -e "  • For public access, use your public IP"
            echo -e "  • Check server logs if still not working"
            ;;
        0)
            return
            ;;
        *)
            echo -e "${RED}❌ Invalid option${NC}"
            ;;
    esac
}

#==============================================================================
# SECTION 8: MAIN EXECUTION
#==============================================================================

# Main execution function
main() {
    init
    main_menu
}

# Run main function only if script is executed directly
# and not during testing or sourcing
if [[ "${BASH_SOURCE[0]}" == "${0}" ]] && [[ -z "${MOONFRP_TESTING:-}" ]]; then
    main "$@"
fi